# Manacher 算法
  Manacher 算法是一种 `线性时间` 内求解一个字符串中 `最长回文子串` 问题的算法

1. 特性
   通过在字符串中加入 `特殊字符`(如 `#`), 构造对称结构, 并在遍布过程中利用已知回文信息 `避免重复计算`, 实现 `O(n)` 

2. 时间复杂度
   `O(n)`: 每个字符最多被扩展一次

3. 空间复杂度
   `O(n)`: 主要用来存放处理后的字符串和 `P` 数组

4. 回文子串
   回文子串指的是一个字符串中某一段是 `对称` 的, 如:
   ```text
   `aba` 是回文
   `abccba` 是回文
   `abc` 不是回文
   ```

5. 实现
   - 预处理
     - 在每个字符中间插入特殊符号 `#`, 让字符串长度统一变成 `奇数`, 方便处理两种回文长度(奇数/偶数)
     ```text
     原字符串:       a    b    a    c    d
     加特殊字符后:  # a  # b  # a  # c  # d #
     索引位置      0 1  2  3 4 5  6  7 8 9 10 
     ```
     
   - 定义辅助数组
     - 用数组 `P[i]` 表示以 `i` 为中心的 `回文半径` (不包括 `i` 自己)
     - 回文子串长度是 `2 * P[i] + 1`
       - 右边界 - 左边界 + 1
       - (i + P[i]) - (i - P[i]) + 1 = 2 * P[i] + 1
  
   - 主过程(利用对称性加速)
     - 维护两变量 `C`、`R`, 初始化都为 `0`, 逐步更新
       - C: 当前已知的回文中心
       - R: 当前已知回文最右边界(C + P[C], 不包含最右边界)
       - i < R
         - 对称利用中心 `C`:
           - `i' = 2 * C - 1`(i关于 C 的对称点)
           - 初始 `P[i] = min(P[i'], R - i)`
           - 暴力扩展
       - i >= R -> 暴力扩展
       - 暴力扩展
           - 从 `P[i] + 1` 处开始扩展
           - 以 `i` 为中心, 尝试向 `左右两边一对一地比较字符串`, 看能不能形成一个回文, 如果两边字符相等, 就继续往外扩, 直到不相等或越界为止
           - 如果成功扩展, `C = i`(新的起点), `R = i + P[i]`(扩展最远的边界作为新的右边界)
       - 更新 `C`, `R`
         - 当 `i + P[i]` > R 时更新 `C`, `R`, `C = i`, `R = i + P[i]'
     - 维护当前最右回文区间 `[C - R, C + R]`, 中心点是 `C`
   - 获取结果
     - 找出 `P[i] 最大值` → 代表 `最长回文串的半径`
     - 利用 `中心索引 i` 和 `回文半径 P[i]`，定位出回文串在预处理字符串 `T` 中的位置, 范围 `(T[i - P[i]], T[i + P[i])`
     - 再将其转换回原始字符串中的索引，取出对应子串
     - 公式
       - start  = (i - P[i]) / 2
       - len    = P[i]
       - substr = original[start..start + len]
   
6. 使用场景
   - 文本编辑器或IDE中的回文检测
     - 检测文本中最长的回文串，方便语法高亮、智能提示等功能
     - 在字符串分析插件中，支持基于回文特性的代码重构或自动纠错
   - 生物信息学中的基因序列分析
     - DNA、RNA序列分析中，回文序列往往有重要的生物学意义（如识别酶的结合位点）
     - 快速找出最长回文区域可以辅助基因功能预测和序列比对
   - 数据压缩和字符串处理
     - 回文结构是某些压缩算法优化的重点，识别回文子串有助于更有效地压缩数据
     - 在文本处理时，也可以用回文检测辅助字符串归一化、相似度计算
   - 网络安全与加密
     - 某些加密算法或安全检测涉及对数据流中回文模式的识别
     - 例如，检测恶意代码或数据包中的回文序列异常模式
   - 算法竞赛和面试
     - 虽然不属于直接商业应用，但 Manacher 算法是经典的字符串算法题目，掌握后能提升面试和竞赛能力

7. 举例
   ```text
   求字符串 `abacaba` 回文串
   
   原始:    a   b  a   c   a     b     a       - 长度 7
      T:    # a # b # a # c # a  #  b  #  a  #   - 长度 15
     索引:   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
     
     1. 初始化到回文中心 C, 和最右边界 R
     C = 0
     R = 0
     P = [0; 15] -- 全为0, P[i] 扩展一次加一次
     
     i 从 0 到 14 开始遍历
     1. i = 0
        T[0] = #
        i > R -> 暴力扩展
        以 i 为中心, 向两边扩展一次: L = i - 1 = -1, R = i + 1 = 1, 越界 ❌
        无法扩展: P[0] = 0
        不更新 C 和 R
     
     2. i = 1
        T[1] = a
        i > R -> 暴力扩展
        以 i 为中心, 向两边扩展一次: L = i - 1 = 0, R = i + 1 = 2 -> T[0] = #, T[2] = # ✅
        以 i 为中心, 向两边扩展两次: L = i - 2 = -1, R = i + 2 = 3 -> 越界 ❌
        成功扩展一步 -> P[1] = 1
        C = i = 1, R = i+ P[i] = 1 + P[1] = 1 + 1 = 2
     
     3. i = 2
        T[2] = #
        i = R -> 暴力扩展
        以 i 为中心, 向两边扩展一次: L = i - 1 = 1, R = i + 1 = 3 -> T[1] = a, T[3] = b ❌
        无法扩展: P[2] = 0
        不更新 C 和 R
     
     4. i = 3
        T[3] = b
        i > R -> 暴力扩展
        以 i 为中心, 向两边扩展一次: L = i - 1 = 3 - 1 = 2, R = i + 1 = 3 + 1 = 4 -> T[2] = #, T[4] = # ✅
        以 i 为中心, 向两边扩展一次: L = i - 2 = 3 - 2 = 1, R = i + 2 = 3 + 2 = 5 -> T[1] = a, T[5] = a ✅
        以 i 为中心, 向两边扩展一次: L = i - 3 = 3 - 3 = 0, R = i + 3 = 3 + 3 = 6 -> T[0] = #, T[6] = # ✅
        以 i 为中心, 向两边扩展一次: L = i - 4 = 3 - 4 = -1, R = i + 4 = 3 + 4 = 7 -> 越界 ❌
        成功扩展三步 -> P[3] = 3
        C = i = 3, R = i+ P[i] = 3 + P[3] = 3 + 3 = 6
        
     5. i = 4
        T[4] = #
        i < R -> i' = 2 * C - i = 2 * 3 - 4 = 2
              -> P[i] = min(P[i'], R - i)
              -> P[4] = min(P[2], 2) = min(0, 2) = 0
        暴力扩展:
        以 i 为中心, 向两边扩展一次: L = i - 1 = 4 - 1 = 3, R = i + 1 = 4 + 1 = 5 -> T[3] = b, T[5] = a ❌
        最终 P[4] = 0
        不更新 C 和 R
     
     6. i = 5
        T[5] = a
        i < R -> i' = 2 * C - i = 2 * 3 - 5 = 1
              -> P[i] = min(P[i'], R - i)
              -> P[5] = min(P[1], 1) = min(1, 1) = 1
        暴力扩展:
        以 i 为中心, 向两边扩展一次: L = i - 1 = 5 - 1 = 4, R = i + 1 = 5 + 1 = 6 -> T[4] = #, T[6] = # ✅
        以 i 为中心, 向两边扩展一次: L = i - 2 = 5 - 2 = 3, R = i + 2 = 5 + 2 = 7 -> T[3] = b, T[7] = c ❌
        成功扩展一步 -> P[5] += 1 = 1 + 1 = 2
        C = i = 5, R = i + P[i] = 5 + 2 = 7
     
     7. i = 6
        T[6] = #
        i < R -> i' = 2 * C - i = 2 * 5 - 6 = 4
              -> P[i] = min(P[i'], R - i)
              -> P[6] = min(P[4], 7 - 6) = min(0, 1) = 0
        以 i 为中心, 向两边扩展一次: L = i - 1 = 6 - 1 = 5, R = i + 1 = 6 + 1 = 7 -> T[5] = a, T[7] = c ❌
        最终 P[6] = 0
        不更新 C 和 R
     
     ...
     
   最终:
      数组 P 变化过程(标记每个点扩展出的最大回文长度)
   
      原始索引            预处理字符串           P[i]
      0                  #                    0
      1                  a                    1
      2                  #                    0
      3                  b                    3
      4                  #                    0
      5                  a                    2
      6                  #                    0
      7                  c                    7
      8                  #                    0
      9                  a                    5
      10                 #                    0
      11                 b                    3
      12                 #                    0
      13                 a                    1
      14                 #                    0
   
     最终最长回文长度是 `3`（即原始字符串中的 `abaaba`）
   
   获取结果:
     最长回文串的`半径` P[i] = 7, 出现位置在 7, i = 7
     从 T 中恢复到原始字符串: 范围: (T[i - P[i]], T[i + P[i])
     获取结果 T(0, 14) = `#a#b#a#c#a#b#a#` -> 去除 `#` 后得 `abacaba`
   ```

8. `i′` 是什么?
   - `i′` 是当前点 `i` 关于当前 `回文中心 C 的对称点`。
   - 简单记作: `i′` 就是 `i` `折回对称` 到 `C 左边` 的位置(想象你用纸把 C 这个位置对折，i 折过去就是 i′)
   ```text
            ↓         ↓         ↓
   T = ...  b   #   a   #   c   #   a   #   b   ...
                ↑               ↑
                i′              C              i
   1. 整段回文左右对称
   2. 中心是 `C = 7`
   3. 当前我们正在遍历 `i = 9`
   4. 所以：关于中心 C = 7，i = 9 的对称点就是: 
   i′ = 2 * C - i = 2 * 7 - 9 = 5
   距离对称中心 C = 7，左边是 i′ = 5，右边是 i = 9
   ```
   - 以 `C 为中心` 的这整段区间是一个回文串, `100% 左右对称`
   - 如果整个回文串是 `对称` 的，那么
     - `i′` 和 `i` 的 `回文扩展能力` 也应该是一样的
     - `P[i′]` 是以 `i′` 为中心，能扩展出多长的回文子串
     - 因为 `i′` 和 `i` `对称` ⇒ 可以用 `P[i′]` 来 `估计 P[i]`
       - 当前回文串是 `以 C 为中心` 的，`右边界` `最多` 到 `R = C + P[C]`, `i` 的回文串 `不能超过 R`，即 `不能越界`
       - P[i] = min(P[i′], R - i)
   ```text
   原始字符串：abacaba
   处理后：T = # a # b # a # c # a # b # a #
   索引：       0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
   假设:
       1. 回文中心 C = 7
       2. `P[7] = 7` → 整个回文覆盖范围是 `T[0..14]`（整个串）
       3. 现在遍历到 i = 9
       4. 那么: i′ = 2 * C - i = 2*7 - 9 = 5
       5. 此时 P[5] = 5
       6. R = C + P[C] = 7 + 7 = 14
       7. 所以 R - i = 14 - 9 = 5
       8. 那么: P[9] = min(P[5], R - 9) = min(3, 5) = 3
   
   就可以 `跳过暴力扩展`，直接初值设置 P[9] = 3
   ```
   
9. 为什么通过 `P[i']` 可以算出 `P[i]`?
   - 因为 `i` 和 `i′` 是关于 `回文中心 C` 的 `对称点`
   - 如果以 `C` 为中心的回文串包含了 `i` 和 `i′`，那么, `i` 和 `i′` 能扩展多远, 也是对称的，所以可以用 `P[i′]` 来估计 `P[i]`
   - `P[i′]` 的右边界是 `i′ + P[i′]`
   - 右边界在整体边界之内(<= R), 那么 `i` 肯定也能对称扩展这么多
   - 如果 P[i′] 很大，使得 i + P[i′] > R，那就越界了, 只能使用暴力破解
   - 在当前回文区间内，我们才认为 `结构对称 ⇒ 值对称 ⇒ 扩展长度对称`
   ```text
   T[0] = #  
   T[1] = a  
   T[2] = #  
   T[3] = b  
   T[4] = #  
   T[5] = a  
   T[6] = #  
   T[7] = c  
   T[8] = #  
   T[9] = a  
   T[10] = #  
   T[11] = b  
   T[12] = #  
   T[13] = a  
   T[14] = #

   说明:
   中心点：C = 7（T[7] = c）
   扩展长度：P[7] = 6
   整个对称结构区间: T[1..13] = a # b # a # c # a # b # a(完整的对称回文区间)
   
   i = 10
   T[1]  T[2]  T[3]  T[4]  T[5]  T[6]  T[7]  T[8]  T[9]  T[10] T[11] T[12] T[13]
   a     #     b     #     a     #     c     #     a     #     b     #     a
                      ←←←←←←←←←←→→→→→→→→→
                             中心C=7        i=10


   你把 C = 7 当成镜子中心，把这整段折叠起来
   T[1]      T[2]      T[3]      T[4]     T[5]    T[6]   T[7]   T[8]   T[9]    T[10]    T[11]...
    ↑                    ↑                                     ↑                   ↑
   i′=1                i′=4                                  i=10                i=13

   如果镜像左边 i′ 能向左“看到”对称的东西，那你在右边的 i 也就一定能向右看到一样的“镜像”, 这是 `镜面对称结构` 的自然结论
   右边 i 如果离回文边界太近，它可能“撞墙”不能看远
   - i′ = 4 能扩展 3 步
   - 但 i = 10 离边界只有 2 步
     - 那 i 最多只能尝试扩展 2 步
     - 这就是为什么要取较小值（这就是 min(...) 的来源）
   ```

10. 如何理解 `i' = 2 * C - 1`(i关于 C 的对称点)
   ```text
   0   1   2   3   4   5   6   7   8
   |---|---|---|---|---|---|---|---|
           i′      C       i
           ↑               ↑
         对称点 ←←←←→→→→→→→→
  
   1. 想象 C 是一个镜子
   2. 点 i 离镜子 2 格远，那么它的对称倒影 i′ 也离镜子 2 格远，但在左边
   3. 所以 i′ = C - (i - C) = 2*C - i
   ```
  