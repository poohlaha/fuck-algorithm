# 二分查找算法(Binary Search)
  用于在一个 `有序数组(或区间)` 中查找某个特定值

1. 查找过程
   可行 ➜ 往右逼近; 不可行 ➜ 往左逼近
   维护 `low(起点索引)`, `high(终点索引)` 两指针
   - 先确定 `中间位置`，把数组（或区间）分成 `左` `右` 两部分
   - 如果 `中间值` 正好 `是目标` ，查找 `成功`
   - 如果 `目标比中间值小` ，只在 `左半部分` 继续查找
   - 如果 `目标比中间值大` ，只在 `右半部分` 继续查找
   - `重复` 以上步骤，直到 `找到目标值` 或 `查找范围为空`
   
2. 时间复杂度
   时间复杂度: O(log n)
   - 每次操作将搜索区间折半，查找区间从 `n ➜ n/2 ➜ n/4 ➜ … 直到1`
   - 因为 `2的对数` 是 `log₂(n)`，所以 `最多查找` 次数是 `log₂(n)`次

3. 举例
   假设我们有一个升序排列的数组: `[2, 4, 7, 10, 13, 18, 21, 30, 35]`, 
   - 查找 `13`
     - 先确定 `中间位置`
       - mid = (0 + 8) / 2 = 4, `中间值` 是 `13`
       - 目标值是 `13`, 正好等于 `中间值`, 查找成功, 结束
   - 查找 `18`
     - 先确定 `中间位置`
       - mid = (0 + 8) / 2 = 4, `中间值` 是 `13`
       - `18` > `13`, 在右半部分, 更新索引区间为 `[5...8]`
     - 重复以下步骤, 确定 `中间位置`  
       - mid = (5 + 8) / 2 = 6, `中间值` 是 `21`
       - `18` < `21`, 在左半部分, 更新索引区间为 `[5, 5]`
     - 重复以下步骤, 确定 `中间位置`
       - mid = (5 + 5) / 2 = 5, `中间值` 是 `18
       - 目标值是 `18`, 正好等于 `中间值`, 查找成功, 结束

4. 应用场景
   - 只能用于 `有序数据`
   - 每次都能把 `问题规模减半`，效率极高
   - 常用于：数组查找、查找插入位置、确定最值（二分答案）等场景
   
5. 木材切割问题
     有多根木头 。我们想切成 `k` 段，要求每段长度不小于 `x`。问 `x` 最大是多少？
     我们无法直接找到“x = ?”，但我们能判断: `如果每段长度 ≥ mid，能否切成 k 段？`, 用二分查找 `x`
   ```text
      假设：
       - 木头长度: [7, 9, 13, 17]
       - 需要切成 k = 5 段
      问题: 求最大化每段的最小长度
   
      1. 确定答案区间
         - 最小段长 >= 1 -> low = 1
         - 最大段长 <= L -> high = 17
   
      2. 二分过程
        - 先确定 `中间位置`
          - mid = (1 + 17) / 2 = 9
        - 判断:
            - 木头能不能切成 `5` 段, 且每段长度 >= 9 ?
              - 7 / 9 = 0
              - 9 / 9 = 1
              - 13 / 9 = 1
              - 17 / 9 = 1
            - 切成 `3` 段, 不够 -> 不满足
            - `9` 太大, 取 mid - 1 = 9 - 1, 更新 high = 8
   
        - 先确定 `中间位置`
          - mid = (1 + 8) / 2 = 4 (向下取整)
        - 判断:
          - 木头能不能切成 `5` 段, 且每段长度 >= 4 ?
            - 7 / 4 = 1
            - 9 / 4 = 2
            - 13 / 4 = 3
            - 17 / 4 = 4
          - 可以切成 `10` 段, 能切够 -> 满足
          - `4` 可能太小, 取 mid + 1 = 5, 更新 low = 5
   
        - 先确定 `中间位置`
          - mid = (5 + 8) / 2 = 6
        - 判断:
          - 木头能不能切成 `5` 段, 且每段长度 >= 6 ?
            - 7 / 5 = 1
            - 9 / 5 = 1
            - 13 / 5 = 2
            - 17 / 5 = 3
          - 可以切成 7 段, 能切够 -> 满足
          - `5` 太小, 取 mid + 1 = 7, 更新 low = 7
      
        - 先确定 `中间位置`
          - mid = (7 + 8) / 2 = 7
        - 判断:
          - 木头能不能切成 `5` 段, 且每段长度 >= 7 ?
            - 7 / 7 = 1
            - 9 / 7 = 1
            - 13 / 7 = 1
            - 17 / 7 = 2
          - 可以切成 `5` 段, 能切够 -> 满足
          - 说明 `6` 太小, 取 mid + 1 = 8, 更新 low = 8
   
        - 先确定 `中间位置`
          - mid = (8 + 8) / 2 = 8
        - 判断:
          - 木头能不能切成 `5` 段, 且每段长度 >= 8 ?
            - 7 / 8 = 0
            - 9 / 8 = 1
            - 13 / 8 = 1
            - 17 / 8 = 2
          - 可以切成 `4` 段, 不够 -> 不满足
          - 结束, 取 high = mid - 8 = 7(取最后一次不可解的值)
     
        最终:
          - low = 8，high = 7，退出循环
          - 取答案: high = 7，是最大化最小段长的可行解
        
        时间复杂度:
          - 答案区间: [low, high], 长度为 high -low
          - 每次对半, 二分到不能再分
          - 时间复杂度: O(log (high - low)), 加上每次 `判定` 的复杂度（通常是 O(n)）
   ```

6. 分配工作最小化最大工作量
   假设有若干工作, 需要把工作分成 `k` 段, 最小化 `所有工人中工作量最大值`
   可行 ➜ 往左逼近; 不可行 ➜ 往右逼近(反过来)
   ```text
    假设:
     - 工作量: [10, 20, 30, 40]
     - 有 k = 2 个工人
     问题: 给定最大工作量上限 `mid`，能否用 `≤k` 个工人完成 ?
   
     1. 确定答案区间
       - 最大工作量 low = 40
       - 总工作量 high = 10 + 20 + 30 + 40 = 100
     
     2. 二分过程
        - 先确定 `中间位置`
          - mid = (40 + 100) / 2 = 70
        - 判断
          - 给定 `70` 工作量, 能否用 <= 2 个工人完成 ?
            - 工人1: 10 + 20 + 30 = 60(再加就要超了)
            - 工人2: 40
          - 工人 <= 2, 可行 -> 满足
          - 说明 `70` 太大, 取 mid - 1 = 69, 更新 high = 69
   
         - 先确定 `中间位置`
           - mid = (40 + 69) / 2 = 54
         - 判断
           - 给定 `54` 工作量, 能否用 <= 2 个工人完成 ?
             - 工人1: 10 + 20 = 30
             - 工人2: 30
             - 工人3: 40
           - 工人 = 3 >= 2, 不可行 -> 不满足
           - 说明 `40` 太小, 取 mid + 1 = 55, 更新 low = 55
   
         - 先确定 `中间位置`
           - mid = (55 + 69) / 2 = 62
         - 判断
           - 给定 `62` 工作量, 能否用 <= 2 个工人完成 ?
             - 工人1: 10 + 20 + 30 = 60
             - 工人2: 40
           - 工人 <= 2, 可行 -> 满足
           - 说明 `62` 太大, 取 mid - 1 = 61, 更新 high = 61

         - 先确定 `中间位置`
           - mid = (55 + 61) / 2 = 58
         - 判断             
           - 给定 `58` 工作量, 能否用 <= 2 个工人完成 ?        
             - 工人1: 10 + 20 = 30
             - 工人2: 30
             - 工人3: 40
           - 工人 = 3 >= 2, 不可行 -> 不满足
           - 说明 `58` 太小, 取 mid + 1 = 59, 更新 low = 59
   
         - 先确定 `中间位置`
           - mid = (59 + 61) / 2 = 60
         - 判断
           - 给定 `60` 工作量, 能否用 <= 2 个工人完成 ?        
             - 工人1: 10 + 20 + 30 = 60
             - 工人2: 40
           - 工人 <= 2, 可行 -> 满足
           - 说明 `60` 太大,取 mid - 1 = 59, 更新 high = 59
   
         - 先确定 `中间位置`
           - mid = (59 + 59) / 2 = 59
         - 判断
           - 给定 `59` 工作量, 能否用 <= 2 个工人完成 ?       
             - 工人1: 10 + 20 = 30
             - 工人2: 30
             - 工人3: 40
           - 工人 = 3 >= 2, 不可行 -> 不满足
           - 当前工作量太小(mid太小), 工人多了, 需要增大mid才能分配更少工人
           - 结束, 取 low = mid + 1 = 60, high = 59
   
         最终:
           - low = 60，high = 59，当 low > high, 退出循环
           - 取答案: high = 59，是最大化最小段长的可行解
   ```
   