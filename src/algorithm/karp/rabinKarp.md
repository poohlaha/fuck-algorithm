# Rabin-Karp 算法(哈希匹配)
  `Rabin-Karp` 算法是一种 `字符串匹配算法`，主要用于在一个文本中查找某个 `模式串` 是否出现(或出现的位置)
  
1. 特性
   - 利用 `哈希函数` 将字符串转换为数字，从而快速比较子串是否匹配
   - 与 `KMP` 不同，不是通过部分匹配表回退指针，而是使用 `哈希技术`
     - 将模式串和文本中的子串都用某种哈希函数映射成一个整数
     - 比较 `两个哈希值是否相等`
     - 若相等，再 `逐字符对比` 以防 `哈希碰撞`
     - 若不等，`直接跳过`，无需逐字符比较
     
2. 时间复杂度
   - 最佳/平均情况
     - 构造哈希值: O(m)
     - 滑动窗口比较: O(n - m + 1)
     - 整体复杂度:
       - 预处理: O(m)
       - 匹配过程: O(n - m + 1) × O(1) = O(n)
       - 平均时间复杂度: O(n + m)
   - 最坏情况(发生大量哈希碰撞)
     - 每次哈希值都相同但字符串不同, 需要逐字符比对
     - 每次对比要 `O(m)`, 总共对比 `O(n - m + 1)` 次
     - 最坏时间复杂度: O(nm)

3. 空间复杂度
   - 哈希值本身占用 `O(1)`
   - 若用于多模式匹配, 需要存多个模式的哈希值, 复杂度为 `O(k)`, 其中 `k` 是模式数量
   - 总体空间复杂度: `O(1) ~O(k)`

4. 使用场景
   - 单一或多个模式串匹配
     - 如在文章中查找多个关键词是否出现
   - 多次重复查找同一模式串
     - 如全文搜索系统中，查找速度要求高
   - 检测重复子串
     - 在 DNA 序列、日志分析中找重复模式
   - 文档相似度检测
     - 将文档切分成句子，基于哈希判断是否相似（如抄袭检测）
   - 不适合
     - 对哈希冲突极其敏感的场景(除非有哈希碰撞处理机制)
     - 模式串特别短(还不如暴力匹配)
     - 不能容忍一定误差的地方(如密码匹配)

5. 步骤
   - 选定参数
     - 基数 p(常选小质数，如 31 或 101，用于加权字符位置)
     - 模数 q(通常选大质数，如 10^9+7，防止哈希值溢出)
   - 用一个哈希函数 `h(s)` 映射字符串 `s` 为 `数字`
     - `hash_p = Σ pattern[i] * p^(m-1 - i)(i 从 0 到 m-1)`(求和)
     - `% q`, 防止溢出: `hash_p = (Σ pattern[i] * p^(m-1 - i)) % q(i 从 0 到 m-1)`
   - 进行匹配
     - 窗口从 `0` 到 `n - m`(n 是主串 text 长度, m 为 pattern 长度, 确保每个窗口都是长度 m，没有越界)
     - 从主串 `text` 的位置 `i = 0` 开始向右滑动窗口
     - 每次取出 `text[i..i+m)`(`m` 是 `pattern 长度`)
     - 用一个哈希函数 `h(s)` 映射字符串 `text[i..i+m)` 为 `数字`
       - `hash_t = (Σ text[i + j] * p^(m-1 - j)) % q(j 从 0 到 m-1)`(求和)
     - 比较两个 hash 是否一致
       - 匹配
         - `从左向右` `逐字符比较` `text[i..i+m)` 是否和 `pattern` 相等(一个个字符对比通常 `比字符串整体比较更稳定、更高效且更安全`, 并且这是为了 `防止哈希碰撞造成误判`)
         - 如果全部匹配, 则记录位置, 右移一步
       - 不匹配, 右移一步
         - 右移后根据上一个 hash 快速求出当前 hash
          - 减去旧窗口首字符 `text[i-1] * p^(m-1)`(上一个 hash 的第一个值)
          - `剩下的部分整体乘以 p`，相当于权重提升一位(左移)
          - 加上新字符 `text[i + m - 1] * p^0`(即 `text[i + m - 1]`)
         ```text
         hash_0 是 S[i-1..i + m-2] 的哈希值（长度 m 子串）
         想得到 hash_1 是 S[i..i + m-1] 的哈希值
         
         hash_0 = S[i - 1] * p^(m - 1) + S[i] * p^(m - 2) + s[i + 1] * p^(m - 3) + ... + s[i + m - 2] * p^0
         hash_1 = S[i] * p^(m - 1) + S[i + 1] * p^(m - 2) + s[i + 2] * p^(m - 3) + ... + s[i + m - 1] * p^0
         
         现在通过 hash_1 推导 hash_0
         1. 减去旧首字符项
         hash_0 - S[i - 1] * p^(m - 1)
         
         2. 所有项都左移一位，即乘以 p
               S[i + 1] * p^(m - 2) + s[i + 2] * p^(m - 3) + ... + s[i + m - 1] * p^0
         要变成:
               S[i] * p^(m-1) + s[i + 1] * p^(m - 2) + ... + s[i + m - 2] * p^0
         
         整体 `乘以 p`
         (hash_0 - S[i - 1] * p^(m - 1)) * p
         
         3. 加上新尾字符项
         hash_1 = (hash_0 - S[i - 1] * p^(m - 1)) * p + s[i + m - 1] * p^0
         ```

6. 使用场景
   - 多模式匹配
     - 防火墙或杀毒软件维护多个 `病毒特征串`，要在文件中查找是否匹配任何一个
       - 所有模式串都可以预先计算哈希值
       - 主串滑动窗口时，每轮只需算一次哈希，与所有模式哈希比较即可
       - 快于 KMP/BM 等一个个去匹配
   - 子串重复检测
     - 给定一个字符串，找出所有长度为 10 的子串中重复出现的片段
       - 对每个长度为 10 的窗口计算哈希
       - 存入 set，判断是否已存在
       - 比逐字符比对快得多
   - 文本相似性检测
     - 检测一个长文档中是否包含另一个文章段落(比如 10 词一组)
       - 可以对文档每个长度为 m 的段落快速滑窗取哈希
       - 把所有段落的哈希值存入哈希表
       - 另一个文档滑窗查是否有匹配的哈希值
   - 结构比对与查重
     - 对代码、DNA、日志等序列快速识别相同片段
     - 实现一个字符串类，支持 is_equal(l1, r1, l2, r2) 查询两个区间是否完全相同
       - 对整个字符串预处理前缀哈希
       - 任意区间哈希值通过差分法 O(1) 计算
       - 哈希值相等 → 子串相等(可加双哈希防冲突)
   - 子串判等频繁查询
     - 比如面试题 `找出长度为 k 的重复子串`
   - 生物序列分析
     - DNA 是 ACGT 序列，例如找到重复的 12 长度序列
       - 字符集小(4个字母)，编码为 2-bit 整数
       - 滚动哈希能用位运算高效实现
       - 可快速查找重复片段或匹配指定序列

7. 举例
   ```text
   text：TTTABABACABAABACABAXABACABAABACABAY
   T T T A B A B A C A  B  A  A  B  A  C  A  B  A  X  A  B  A  C  A  B  A  A  B  A  C  A  B  A  Y
   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
   pattern: ABABACABA
   A B A B A C A B A
   0 1 2 3 4 5 6 7 8 
   m: 9
   n = 38
   
   1. 选定参数 
   基数 p = 31(也可以是其他质数)
   模数 q = 1,000,000,007(大质数防止溢出)
   
   2. 一个哈希函数 `h(s)` 映射字符串 `s` 为 `数字`
   假设用字符的 ASCII 值或简化映射(A = 1, B = 2, C = 3, ...)
   映射: A = 1, B = 2, C = 3
   哈希值:
   hash = Σ pattern[i] * p^(m - 1 - i)
        = 1 * 31^(9 - 1 - 0) + 2 * 31^(9 - 1 - 1) + 1 * 31^(9 - 1 - 2) + 2 * 31^(9 - 1 - 3) + 1 * 31^(9 - 1 - 4) + 3 * 31^(9 - 1 - 5) + 1 * 31^(9 - 1 - 6) + 2 * 31^(9 - 1 - 7) + 1 * 31^(9 - 1 - 8)
        = 1 * 31^8 + 2 * 31^7 + 1 * 31^6 + 2 * 31^5 + 1 * 31^4 + 3 * 31^3 + 1 * 31^2 + 2 * 31^1 + 1 * 31^0
   
   取模 q
   hash = (1 * 31^8 + 2 * 31^7 + 1 * 31^6 + 2 * 31^5 + 1 * 31^4 + 3 * 31^3 + 1 * 31^2 + 2 * 31^1 + 1 * 31^0) % 1000000007
   
   3. 开始匹配
   窗口 i 从 0 到 n - m = 29(因为 38 - 9 = 29)
   
   i = 0
   -> 窗口: text[i, m - 1] = text[0, 8] = "TTTABABAC"
   -> 字符映射成数字:  
   ->  T  T  T A B A B A C
   -> 20 20 20 1 2 1 2 1 3
   -> 计算哈希值: hash = (Σ text[i + j] * p^(m - 1 - j)) % q
   -> (20 * 31^8 + 20 * 31^7 + 20 * 31^6 + 1 * 31^5 + 2 * 31^4 + 1 * 31^3 + 2 * 31^2 + 1 * 31^1 + 3 * 31^0) % 1000000007
   -> 比较两个 hash 是否一致
   -> 不匹配, 滑动窗口右移, i += 1
   
   i = 1
   -> 窗口: text[i, m - 1] = text[1, 9] = "TTABABACA"
   ->  T  T A B A B A C A
   -> 20 20 1 2 1 2 1 3 1
   -> 计算哈希值: hash = Σ text[i + j] * p^(m - 1 - j)
   -> (20 * 31^8 + 20 * 31^7 + 1 * 31^6 + 2 * 31^5 + 1 * 31^4 + 2 * 31^3 + 1 * 31^2 + 3 * 31^1 + 1 * 31^0) % 1000000007
   -> hash 快速计算: (上一个 hash - text[0] * 31^8) * p + text[9] * 31^0
   -> 比较两个 hash 是否一致
   -> 不匹配, 滑动窗口右移, i += 1
   
   i = 2
   -> 窗口: text[i, m - 1] = text[2, 10] = "TABABACAB"
   ->  T A B A B A C A B
   -> 20 1 2 1 2 1 3 1 2
   -> hash 快速计算后比较两个 hash 是否一致
   -> 不匹配, 滑动窗口右移, i += 1
   
   i = 3
   -> 窗口: text[i, m - 1] = text[3, 11] = "ABABACABA"
   -> A B A B A C A B A
   -> 1 2 1 2 1 3 1 2 1
   -> hash 快速计算后比较两个 hash 是否一致
   -> 匹配, 进行逐字符比对
   -> text[3..11] 是否等于 pattern
   -> 从左向右比较字符
   -> text[3] = A, pattern[0] = A ✅
   -> text[4] = B, pattern[1] = B ✅
   -> text[5] = A, pattern[2] = A ✅
   -> text[6] = B, pattern[3] = B ✅
   -> text[7] = A, pattern[4] = A ✅
   -> text[8] = C, pattern[5] = C ✅
   -> text[9] = A, pattern[6] = A ✅
   -> text[10] = B, pattern[7] = B ✅
   -> text[11] = A, pattern[8] = A ✅
   -> 全部匹配, 确认匹配成功, 记录位置 i = 3
   -> 滑动窗口右移, i += 1
   
   i = 4
   -> 窗口: text[i, m - 1] = text[4, 12] = "BABACABAA"
   -> hash 快速计算后比较两个 hash 是否一致
   -> 不匹配, 滑动窗口右移, i += 1
   
   ...
   
   i = 26
   -> 窗口: text[i, m - 1] = text[26, 34] = "AABACABAY"
   -> hash 快速计算后比较两个 hash 是否一致
   -> 不匹配, 滑动窗口右移, i += 1
   
   i = 27
   -> 长度不够, 匹配结束
   
   总结:
   在 i = 3 位置上发现匹配项
   ```
   
8. 如何选择 `基数 p(权重系数)`
   - 原则
     - 选一个较小的质数
     - 不能太小, 否则哈希碰撞率高
     - 不能太大, 否则容易溢出或效率变差
   - 常用推荐值
   ```text
   场景               推荐值(p)              说明
   ASCII字符          31、53                 适合大小写英文字母
   Unicode           131、233               更广字符集，如中文
   多模式匹配          101、131               提高哈希分布
   ```
   
9. 如何选择 `模数 q(取模系数)` 
   - 原则
     - 必须是一个大质数
     - 要大到避免哈希冲突
     - 应小于机器整数最大范围, 防止溢出
     - 若用多个哈希函数(双哈希), 要选多个不同的质数
   - 常用推荐值
    ```text
   模数 q             说明
   10^9 + 7          1000000007，常见大质数
   10^9 + 9          1000000009，另一个安全质数
   2^61 - 1          如果你用 64 位整数且不取模
   ```  
   - 为什么是 10^9+7?
     - 是质数
     - 接近 `int64` 上限, 但不溢出
     - 可与 `p = 31` 一起使用, 冲突概率极低

10. 双哈希
    - 用 `两个不同的哈希函数(通常是不同的 (p, q) 组合)` 同时计算两个哈希值，只有 `两个哈希值都相等` 时，才认为 `匹配成功(再从左向右再逐字符比对)`, 显著降低了哈希碰撞概率
      - 单哈希碰撞概率可能为 1/q
      - 双哈希碰撞概率是约 1/q₁q₂(几乎为零)
    - 举例
    ```text
    text：TTTABABACABAABACABAXABACABAABACABAY
    T T T A B A B A C A  B  A  A  B  A  C  A  B  A  X  A  B  A  C  A  B  A  A  B  A  C  A  B  A  Y
    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
    pattern: ABABACABA
    A B A B A C A B A
    0 1 2 3 4 5 6 7 8
    1 2 1 2 1 3 1 2 1 <- 映射
    m: 9
    n = 38
    
    映射: A = 1, B = 2, C = 3, T = 30, X = 24, Y = 25
   
    1. 选定参数 
       - p1 = 31, q1 = 1,000,000,007
       - p2 = 37, q2 = 1,000,000,009
    
    2. 一个哈希函数 `h(s)` 映射字符串 `s` 为 `数字`
    哈希值:
    hash = Σ pattern[i] * p^(m - 1 - i)
    hash_p1 = (1 * 31^8 + 2 * 31^7 + 1 * 31^6 + 2 * 31^5 + 1 * 31^4 + 3 * 31^3 + 1 * 31^2 + 2 * 31^1 + 1 * 31^0) % 1000000007
    hash_p2 = (1 * 37^8 + 2 * 37^7 + 1 * 37^6 + 2 * 37^5 + 1 * 37^4 + 3 * 37^3 + 1 * 37^2 + 2 * 37^1 + 1 * 37^0) % 1000000009
    
    3. 开始匹配
    窗口 i 从 0 到 n - m = 29 （因为 38 - 9 = 29）
    
    i = 0
    -> 窗口: text[i, m - 1] = text[0, 8] = "TTTABABAC"
    -> 字符映射成数字:  
    ->  T  T  T A B A B A C
    -> 20 20 20 1 2 1 2 1 3
    -> 计算两个哈希值: hash = Σ text[i + j] * p^(m - 1 - j)
    -> (hash_t1 = 20 * 31^8 + 20 * 31^7 + 20 * 31^6 + 1 * 31^5 + 2 * 31^4 + 1 * 31^3 + 2 * 31^2 + 1 * 31^1 + 3 * 31^0) % 1000000007
    -> (hash_t2 = 20 * 37^8 + 20 * 37^7 + 20 * 37^6 + 1 * 37^5 + 2 * 37^4 + 1 * 37^3 + 2 * 37^2 + 1 * 37^1 + 3 * 37^0) % 1000000009
    -> 比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 不匹配, 滑动窗口右移, i += 1
    
    i = 2
    -> 窗口: text[i, m - 1] = text[2, 10] = "TABABACAB"
    ->  T A B A B A C A B
    -> 20 1 2 1 2 1 3 1 2
    -> hash 快速计算后比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 不匹配, 滑动窗口右移, i += 1
    
    i = 3
    -> 窗口: text[i, m - 1] = text[3, 11] = "ABABACABA"
    -> A B A B A C A B A
    -> 1 2 1 2 1 3 1 2 1
    -> hash 快速计算后比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 完全匹配(has2_t1 == hash_p1 && hash_t2 == hash_p2), 进行逐字符比对
    -> text[3..11] 是否等于 pattern
    -> 从左向右比较字符
    -> text[3] = A, pattern[0] = A ✅
    -> text[4] = B, pattern[1] = B ✅
    -> text[5] = A, pattern[2] = A ✅
    -> text[6] = B, pattern[3] = B ✅
    -> text[7] = A, pattern[4] = A ✅
    -> text[8] = C, pattern[5] = C ✅
    -> text[9] = A, pattern[6] = A ✅
    -> text[10] = B, pattern[7] = B ✅
    -> text[11] = A, pattern[8] = A ✅
    -> 全部匹配, 确认匹配成功, 记录位置 i = 3
    -> 滑动窗口右移, i += 1
    
    ....
    ```

11. 双哈希 or 多哈希
    - 双哈希
      - 选两个不同的 p 和 q，分别计算两个哈希值，只有两个都匹配才认为是匹配
      - 这样极大降低哈希碰撞概率，适用于
        - 模式串很长
        - 精度要求极高的场景(如抄袭检测)
    
12. 实际开发建议
    ```text
    场景                       推荐组合(p, q)                                     说明
    英文字符串                  p = 31, q = 1_000_000_007                         最常见组合
    多模式匹配/大文本            p = 131, q = 1_000_000_009                        减少冲突
    高安全性需求                p1 = 31, q1 = 10^9+7 与 p2 = 37, q2 = 10^9+9       双哈希
    中文/emoji/unicode         p = 233 or 257, q = 2^61 - 1                       更大字符集支持
    ```
    
13. 编程语言层面注意事项  
    ```text
    语言            默认整数类型          建议            
    C/C++          32/64-bit int       强烈建议使用 `long long` 或 `uint64_t`        
    Rust           u64/i64             推荐使用 `wrapping_mul`, `wrapping_add` 避免溢出
    Python         支持大整数            可直接使用大质数，不会溢出
    Java           int/long            使用 `long` 并手动 `% q` 取模    
    ```
    
14. 总结
    ```text
    选 `p=31`，`q=10^9+7` 是 `最安全的通用搭配`,
    若字符串长或精度要求高，考虑 `p=131 或双哈希`
    ```
    
15. 不推荐场景
    - 模式串特别短(1~2 字)
      - 滑窗 + 哈希反而不如遍历快
    - 模式串变化频繁
      - 每次都要重新计算哈希
    - 对字符位置非常敏感
      - 哈希失去了定位优势
    - 需要最坏时间复杂度保证
      - Rabin-Karp 最坏为 O(nm)，KMP 为 O(n+m)

16. DNA实例(使用二进制位移)
    ```text
    给定一个字符串 s，找出所有长度为 10 的子串中，重复出现的片段(子串)
    输入: AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT
    输出: ["AAAAACCCCC", "CCCCCAAAAA"]
    m = 10
    n = 31
    
    1. 整数编码 + 位运算(不需要 p 和 q)
       - 必须是二进制才可以位移
       - 字符集为 4(A/C/G/T), 可以用 2 位来表示一个字符
       - 长度为 10 的子串只需 2 * 10 = 20
       - 可以直接用一个 32 位整数作为哈希值(无碰撞)
       
    使用二进制映射字符编码
    A = 00 C = 01 G = 10 T = 11
    AAAAACCCCC:
    00 00 00 00 00 01 01 01 01 01 → 一个 20 位的整数(哈希值)
    用位运算维护滑动窗口:
    - bitmask = (1 << 20) - 1 // 只保留低 20 位
    - hash = ((hash << 2) | new_char_code) & bitmask
    
    hash << 2
    左移 2 位, 给新字符腾出位置
    假设当前 hash 表示 "AAAAACCCCC"，我们要滑动一个字符窗口，下一轮要加入下一个字符，比如是 "A"(编码 00)
    旧哈希 = [00 00 00 00 00 01 01 01 01 01]  ← 表示 AAAAA CCCCC
    左移两位变成：
            [00 00 00 00 00 01 01 01 01 01 00 __]
                                          ↑ 空出2位
    
    | new_char_code
    把新的字符放到右边空出的 2 位中
    例如新字符 "A" → 00，那么:
    [... ... 00 __] | 00  → 还是 [... ... 00 00]

    & bitmask(保留最低 20 位)
    bitmask = (1 << 20) - 1
    构造一个 `低 20 位全是 1` 的掩码(mask)，用于保留哈希的最后 10 个字符(每字符 2 bit)
    1 << 20(2^20 = 1048576):
    0000...0001(32位整数，最右边一位是1)
    向左移 20位:
    0b1_0000_0000_0000_0000_0000 ← 仅第 21 位是 1，其它全是 0(总共 1 后面跟 20 个 0)
    = 2^20 = 1048576
    
    -1 是啥作用?
    如果取 20 位全是 0，那么你和任何数相与(&)，结果都会变成 0 —— 什么都保不住
    x & 1 = x: 保留该位; x & 0 = 0: 清除该位
    
    0b1111_1111_1111_1111_1111  ← 前 20 位全是 1(恰好是 20 个 1)
    = 2^20 - 1 = 1048575
    =  1_0000_0000_0000_0000_0000
     - 0_0000_0000_0000_0000_0001
    = 0_1111_1111_1111_1111_1111
    ps: 任意 `2 的幂 2^n` 减去 `1`，结果一定是 `n 个 1 的二进制数`(n 个 1)
    
    现在问题来了：我们每次都左移 2 位，再加一个字符，hash 越来越长！
    如果不限制位数，就可能超过 32-bit 整数，导致混乱。
    所以我们限制只保留低 20 位:
    bitmask = (1 << 20) - 1
            = 0b1111_1111_1111_1111_1111
    = 1048575(十进制)
    
    转16进制(以 `0x` 开头的形式)
    十六进制每一位对应 `4 位二进制`，所以我们把 20 位二进制从右往左，分成每组 4 位
    0b 1111 1111 1111 1111 1111
        ↑    ↑    ↑    ↑    ↑
        F    F    F    F    F
    = 0xFFFFF(十六进制, 以 `0x` 开头的形式)
    
    hash & bitmask  → 把高于 20 位的全清 0
    原:      0b1100_1100_1100_1100_1100_1100 ← 24 位
    bitmask: 0b1111_1111_1111_1111_1111 ← 20 位全是 1
    
      1100_1100_1100_1100_1100_1100
    &    0b1111_1111_1111_1111_1111
    = 0000_1100_1100_1100_1100_1100
    这样就确保了只保留最近 10 个字符(2bit×10=20位)

    步骤:
    初始化: hash = 0, bitmask = (1 << 20) - 1, seen
    
    i = 0
    -> 窗口: text[i, m - 1] = text[0, 9] = "AAAAACCCCC", new_char_code[9] = C
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> 第 1 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 2 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 3 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 4 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 5 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 6 个字符 C : hash = ((0 << 2) | 01) & 1100_1100_1100_1100_1100 = 1
    -> 第 7 个字符 C : hash = ((1 << 2) | 01) & 1100_1100_1100_1100_1100 = 5
    -> 第 8 个字符 C : hash = ((5 << 2) | 01) & 1100_1100_1100_1100_1100 = 21
    -> 第 9 个字符 C : hash = ((21 << 2) | 01) & 1100_1100_1100_1100_1100 = 85
    -> 第 10 个字符 C : hash = ((85 << 2) | 01) & 1100_1100_1100_1100_1100 = 341
    -> 查找 seen 中是否存在 AAAAACCCCC
    -> 不存在, 则添加 [AAAAACCCCC, 341] 到 seen 中
    
    i = 1
    -> 窗口: text[i, m - 1] = text[1, 10] = "AAAACCCCCA", new_char_code[10] = A
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> 第 1 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 2 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 3 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 4 个字符 A : hash = ((0 << 2) | 00) & 1100_1100_1100_1100_1100 = 0
    -> 第 5 个字符 C : hash = ((0 << 2) | 01) & 1100_1100_1100_1100_1100 = 1
    -> 第 6 个字符 C : hash = ((1 << 2) | 01) & 1100_1100_1100_1100_1100 = 5
    -> 第 7 个字符 C : hash = ((5 << 2) | 01) & 1100_1100_1100_1100_1100 = 21
    -> 第 8 个字符 C : hash = ((21 << 2) | 01) & 1100_1100_1100_1100_1100 = 85
    -> 第 9 个字符 C : hash = ((85 << 2) | 01) & 1100_1100_1100_1100_1100 = 341
    -> 第 10 个字符 A : hash = ((341 << 2) | 01) & 1100_1100_1100_1100_1100 = 1364
    -> 根据上一个 hash 快速计算: ((hash << 2) | new_char_code) & bitmask = ((341 << 2) | 00) & 1100_1100_1100_1100_1100 = 1364
    -> 查找 seen 中是否存在 AAAACCCCCA
    -> 不存在, 则添加 [AAAACCCCCA, 1364] 到 seen 中
    
    i = 2
    -> 窗口: text[i, m - 1] = text[2, 11] = "AAACCCCCAA", new_char_code[11] = A
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((1364 << 2) | 00) & 1100_1100_1100_1100_1100 = 5456
    -> 查找 seen 中是否存在 AAACCCCCAA
    -> 不存在, 则添加 [AAACCCCCAA, 5456] 到 seen 中
    
    i = 3
    -> 窗口: text[i, m - 1] = text[3, 12] = "AACCCCCAAA", new_char_code[12] = A
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((5456 << 2) | 00) & 1100_1100_1100_1100_1100 = 21824
    -> 查找 seen 中是否存在 AACCCCCAAA
    -> 不存在, 则添加 [AACCCCCAAA, 21824] 到 seen 中
    
    i = 4
    -> 窗口: text[i, m - 1] = text[4, 13] = "ACCCCCAAAA", new_char_code[13] = A
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((21824 << 2) | 00) & 1100_1100_1100_1100_1100 = 87296
    -> 查找 seen 中是否存在 ACCCCCAAAA
    -> 不存在, 则添加 [ACCCCCAAAA, 87296] 到 seen 中
    
    i = 5
    -> 窗口: text[i, m - 1] = text[5, 14] = "CCCCCAAAAA", new_char_code[15] = A
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((87296 << 2) | 00) & 1100_1100_1100_1100_1100 = 349184
    -> 查找 seen 中是否存在 CCCCCAAAAA
    -> 不存在, 则添加 [CCCCCAAAAA, 349184] 到 seen 中
    
    i = 6
    -> 窗口: text[i, m - 1] = text[6, 15] = "CCCCAAAAAC", new_char_code[15] = C
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((349184 << 2) | 01) & 1100_1100_1100_1100_1100 = 348160
    -> 查找 seen 中是否存在 CCCCAAAAAC
    -> 不存在, 则添加 [CCCCAAAAAC, 348160] 到 seen 中
    
    i = 7
    -> 窗口: text[i, m - 1] = text[7, 16] = "CCAAAAACC", new_char_code[16] = C
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((348160 << 2) | 01) & 1100_1100_1100_1100_1100 = 344069
    -> 查找 seen 中是否存在 CCCCAAAAAA
    -> 不存在, 则添加 [CCAAAAACC, 344069] 到 seen 中
    
    i = 8
    -> 窗口: text[i, m - 1] = text[8, 17] = "CAAAAACCC", new_char_code[17] = C
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((344069 << 2) | 01) & 1100_1100_1100_1100_1100 = 327701
    -> 查找 seen 中是否存在 CCCCAAAAAA
    -> 不存在, 则添加 [CAAAAACCC, 327701] 到 seen 中
     
    i = 9
    -> 窗口: text[i, m - 1] = text[9, 18] = "AAAAACCCCC", new_char_code[18] = C
    -> 计算 hash = ((hash << 2) | new_char_code) & bitmask
    -> ((327701 << 2) | 01) & 1100_1100_1100_1100_1100 = 262229
    -> 查找 seen 中是否存在 AAAAACCCCC
    -> 存在, 记录些字符串 AAAAACCCCC
    
    ....
    
    2. 使用 Rabin-Karp
    2.1. 选定参数 
    p1 = 31 q1 = 10^9+7 = 1000000007
    p2 = 37 q2 = 10^9+9 = 1000000009
    映射数字: A = 1, C = 2, G = 3, T = 4
    
    2.2. 一个哈希函数 `h(s)` 映射字符串 `s` 为 `数字`
    哈希值:
    hash = Σ pattern[i] * p^(m - 1 - i)
    hash_p1 = (1 * 31^8 + 2 * 31^7 + 1 * 31^6 + 2 * 31^5 + 1 * 31^4 + 3 * 31^3 + 1 * 31^2 + 2 * 31^1 + 1 * 31^0) % 1000000007
    hash_p2 = (1 * 37^8 + 2 * 37^7 + 1 * 37^6 + 2 * 37^5 + 1 * 37^4 + 3 * 37^3 + 1 * 37^2 + 2 * 37^1 + 1 * 37^0) % 1000000009
    
    2.3. 开始匹配
    窗口 i 从 0 到 n - m = 29 （因为 31 - 10 = 21）
    
    i = 0
    -> 窗口: text[i, m - 1] = text[0, 9] = "AAAAACCCCC"
    -> 计算两个哈希值: hash = Σ text[i + j] * p^(m - 1 - j)
    -> hash_t1 = (1 * 31^9 + 1 * 31^8 + 1 * 31^7 + 1 * 31^6 + 1 * 31^5 + 2 * 31^4 + 2 * 31^3 + 2 * 31^2 + 2 * 31^1 + 2 * 31^0) % 1000000007
    -> hash_t2 = (1 * 37^9 + 1 * 37^8 + 1 * 37^7 + 1 * 37^6 + 1 * 37^5 + 2 * 37^4 + 2 * 37^3 + 2 * 37^2 + 2 * 37^1 + 2 * 37^0) % 1000000009
    -> 比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 不匹配, 滑动窗口右移, i += 1
    
    i = 1
    -> 窗口: text[i, m - 1] = text[1, 19] = "AAAACCCCCA"
    -> 计算两个哈希值: hash = Σ text[i + j] * p^(m - 1 - j)
    -> hash_t1 = (1 * 31^9 + 1 * 31^8 + 1 * 31^7 + 1 * 31^6 + 2 * 31^5 + 2 * 31^4 + 2 * 31^3 + 2 * 31^2 + 2 * 31^1 + 1 * 31^0) % 1000000007
    -> hash_t2 = (1 * 37^9 + 1 * 37^8 + 1 * 37^7 + 1 * 37^6 + 2 * 37^5 + 2 * 37^4 + 2 * 37^3 + 2 * 37^2 + 2 * 37^1 + 1 * 37^0) % 1000000009
    -> 比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 不匹配, 滑动窗口右移, i += 1
    
    
    ...
    
    i = 5
    -> 窗口: text[i, m - 1] = text[1, 19] = "CCCCCAAAAA"
    -> 计算两个哈希值: hash = Σ text[i + j] * p^(m - 1 - j)
    -> hash_t1 = (2 * 31^9 + 2 * 31^8 + 2 * 31^7 + 2 * 31^6 + 2 * 31^5 + 1 * 31^4 + 1 * 31^3 + 1 * 31^2 + 1 * 31^1 + 1 * 31^0) % 1000000007
    -> hash_t2 = (2 * 37^9 + 1 * 37^8 + 2 * 37^7 + 1 * 37^6 + 2 * 37^5 + 1 * 37^4 + 2 * 37^3 + 1 * 37^2 + 1 * 37^1 + 1 * 37^0) % 1000000009
    -> 比较 hash_t1 和 hash_p1 以及 hash_t2 和 hash_p2 是否都相同
    -> 匹配, 记录此位置, 滑动窗口右移, i += 1
    
    ...
    
    ```
    
17. 十六进制(以 `0x` 开头)
    十六进制（Hexadecimal）是以 `16` 为基数的数制, `每个十六进制 = 4位二进制` 用以下字符表示每一位:
    ```text
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

    十六进制                  十进制                 二进制
    0                        0                     0000
    1                        1                     0001
    2                        2                     0010
    3                        3                     0011
    4                        4                     0100
    5                        5                     0101
    6                        6                     0110
    7                        7                     0111
    8                        8                     1000
    9                        9                     1001  
    A                        10                    1010  
    B                        11                    1011  
    C                        12                    1100 
    D                        13                    1101
    E                        14                    1110
    F                        15                    1111
    ```

18. 八进制
    - 八进制是 `以 8 为底` 的进位计数系统
    - 用 `0 ~ 7` 八个数字: `0 1 2 3 4 5 6 7 8`
    - 每一位的权值是 `8 的幂`
      - 0753 = 7 * 8^2 + 5 * 8^1 + 3 * 8^0 = 491
    - 八进制在某些老系统(`比如 UNIX 文件权限`)中使用较多

19. 二进制、八进制、十六进制转换
    - `1 个八进制位 = 3 个二进制位(因为 2^3 = 8)`
    - `1 个十六进制 = 4 个二进制位(因为 2^4 = 16)`
    ```text
    二进制：   101  011  111
    八进制：    5    3    7   => 0o537（前缀 0o 表示八进制）

    二进制：  1111 1111
    十六进制：   F     F      => 0xFF (前缀 0x 表示十六进制）
    ```
    - 前缀标准
    ```text
    表示               示例                     说明
    二进制             0b1010                   b 是 binary 的意思
    八进制             0o755                    o 是 octal 的意思 
    十进制             123                      正常整数，不加前缀 
    十六进制           0xFF                     x 是 hexadecimal 的意思
    ```
    - 总结
    ```text
    进制        使用的数字         每位代表值(权值)    与二进制的关系
    二进制      0, 1              每位是 2 的幂      基础           
    八进制      0 ~ 7             每位是 8 的幂      1 位 = 3 位二进制 
    十六进制    0 ~ 9, A ~ F      每位是 16 的幂     1 位 = 4 位二进制
    ```

20. 十进制转成二进制、八进制、十六进制
    - 除基取余，逆序排列
      - 除基:
        - 二进制 → 除以 2
        - 八进制 → 除以 8
        - 十六进制 → 除以 16
    - 每次除以对应进制的 `基数`, 记录余数
    - 然后 `把余数倒过来排列` 就是最终答案
    ```text
    以 125 为例
    
    1. 十进制 → 二进制（除以 2）
    除以 2	    商	         余数
    125 ÷ 2     62           1
     62 ÷ 2     31           0
     31 ÷ 2     15           1
     15 ÷ 2      7           1
      7 ÷ 2      3           1
      3 ÷ 2      1           1
      1 ÷ 2      0           1
     
    -> 倒着写余数: 1111101 
    -> 0b1111101
    
    2. 十进制 → 八进制（除以 8）
    除以 2	    商	         余数
    125 ÷ 8     15           5
     15 ÷ 8      1           7
      1 ÷ 8      0           1
  
    -> 倒着写余数: 175
    -> 0o175
    
    3. 十进制 → 十六进制(除以 16)
    除以 2	    商	         余数
    125 ÷ 16    7            13
      7 ÷ 16    0            7
    
    -> ps: 余数 13 在十六进制里是 D
    -> 倒着写余数：7D
    -> 0x7D
    ```
    
21. 二进制转十进制、八进制、十六进制
    - 二进制 → 十进制
      - 按权展开法
      - 0b1101 = 1 * 2^3 + 1 * 2^2 + 0 * 1^1 + 1* 1^0 = 13
    - 二进制 → 八进制
      - 每3位一组，从右向左分组
      - 0b110_101 -> 每 3 位一组 -> 110 101
      - 分别换成八进制:
        - 110 = 6
        - 101 = 5
      - 0b110101 = 0o65
    - 二进制 → 十六进制
      - 每4位一组，从右向左分组
      - 0b1101_0111 -> 每 4 位一组 -> 1101 0111
      - 分别换成十六进制:
        - 1101 = D 
        - 0111 = 7
      - 0b11010111 = 0xD7

21. 八进制转二进制、十进制、十六进制
    - 八进制 → 二进制
      - 每位变成 3 位二进制
      - 0o753 → 拆开是 7 5 3
        - 7 = 111
        - 5 = 101
        - 3 = 011
      - 0o753 = 0b111101011
    - 八进制 → 十进制
      - 按权展开法
      - 0o753 = 7 * 8^2 + 5 * 8^1 + 3 * 8^0 = 491
    - 八进制 → 十六进制
      - 转成二进制 → 再每4位分组转成十六进制
      - 0o753 → 0b111101011 → 4位一组
        - 0001 1110 1011 → 对应十六进制：1E B
      - 0o753 = 0x1EB

22. 十六进制转二进制、八进制、十进制
    - 十六进制 → 二进制
      - 每1位 → 4位二进制
      - 0x7D = 7 D
        - 7 = 0111
        - D = 1101
      - 0x7D = 0b01111101
    - 十六进制 → 十进制
      - 按权展开法
      - 0x7D = 7 * 16^1 + 13 * 16^0 = 125
    - 十六进制 → 八进制
      - 十六进制 → 二进制 → 八进制
        - 0x7D → 二进制: 0111 1101
        - 合并为: 01111101 → 每3位分组：000 111 110 1 → 补0 → 000 111 110 001
        - 八进制：0 7 6 1
      - 0x7D = 0o175

23. 转换总结
    ```text
    起始进制 	→     二进制  	   →    十进制	    →     八进制	            →        十六进制
    二进制	          ——	            权展开	          每3位一组	                 每4位一组
    十进制	          除2取余逆序	        ——	              除8取余逆序	                 除16取余逆序
    八进制	          每位转3位二进制	    权展开             ——	                     八 → 二 → 每4位转16进制
    十六进制           每位转4位二进制      权展开            十六 → 二 → 每3位转八进制      ——
    ```
    
