# A* 算法
  A*(A-star) 是一种 `启发式最短路径搜索算法`, 它解决的问题是:
  > 在一个带权图中, 从起点走到终点, 找一条总代价最小的路径

  它是对 **Dijkstra 算法** 的改进

---

## A* 的核心思想
  A* 不是盲目地向四周扩散, 它会计算一个值:
  > **f(n) = g(n) + h(n)**
  >
  > g(n): 从起点走到当前节点的真实代价
  >
  > h(n): 从当前节点走到终点的“预估代价”(启发式函数)
  >
  > f(n): 综合代价(优先选择最小的)

  可以理解为:
  > g(n) = 我已经走了多远
  >
  > h(n) = 我离目标还有多远
  >
  > f(n) = 如果走这条路，总共可能多远

  每次选择 `f 最小` 的那条路

---

## 为什么它比 Dijkstra 快?
   - Dijkstra 只看 g(n)
   - A* 看 g(n) + h(n)
  
   因为加入了 “方向感”,
   所以 A* 会更倾向朝目标方向搜索

---

## 启发式函数 h(n)
### 什么是“曼哈顿距离”?
   适用于: 只能上下左右移动(四方向 → 像走十字格)

   曼哈顿距离(Manhattan Distance) 是:
   > 在只能上下左右移动的情况下, 从一个点走到另一个点最少要走多少步。
   >
   > 公式: **|x₁ - x₂| + |y₁ - y₂|**

   - 为什么叫“曼哈顿”?
   
   因为美国的 Manhattan(纽约曼哈顿)街区是规则网格状的。
  
   在这种城市里:
   - 不能斜着穿过大楼
   - 只能沿街区走
   - 只能横向 + 纵向

   所以:
   `从 A 到 B 的距离 = 横向走多少 + 纵向走多少`

---

### 欧几里得距离
   适用于: 允许斜着走(八方向 → 可以斜着走)

   欧几里得距离是:
   > 两个点之间的 “直线距离”。

   也就是你拿尺子量出来的那条最短线段长度。
    
   公式:
   > $d = \sqrt{(x₁-x₂)^2 + (y₁-y₂)^2}$
   
   它来自:
   > 👉 Euclid 的几何体系
   >
   > 👉 勾股定理

--- 

1. 几何直观理解
   假设有两个点:
   - A(0, 0)
   - B(4, 4)
   
   我们画一个直角三角形:
   - 横向差: 4
   - 纵向差: 4
   
   就变成:
   ```
        B(4,4)
          *
         /|
        / |
       /  | 4
      /   |
     *----*
   A(0,0)   4
   ```

   根据勾股定理:
   > 斜边² = 4² + 4²
   >
   > 斜边 = $\sqrt{16 + 16}$
   > 
   > = $\sqrt{32}$
   > ≈ 5.66

---

2. 为什么它是“最短距离”?
   因为在平面几何中:
   > 两点之间，直线最短

   这是几何基本公理。

   如果允许你“自由移动方向”, 那你一定会选择走直线。

---

### 欧几里得距离和曼哈顿距离对比?
   从 (0, 0) 到 (4, 4)

   | 距离类型 | 含义      | 结果   |
   | ---- | ------- | ---- |
   | 曼哈顿  | 只能横竖走   | 8    |
   | 欧几里得 | 可以任意方向走 | 5.66 |

   为什么曼哈顿更长？
   > 因为不能走斜线，只能走“折线”。

### 重要性质
    如果: h(n) 永远不高估真实距离, 那么 A* 一定找到最优路径, 这叫: 
    > 👉 **可采纳启发式（admissible heuristic）**

---

## 时间和空间复杂度
   时间复杂度: O(b^d)
   - b = 分支因子
   - d = 搜索深度

   空间复杂度: O(n²)
   - 这也是 A* 最大的问题: 👉 非常吃内存

---

## 举例(曼哈顿距离)
1. 我们用最简单的 5×5 格子图
   ```
   S . . . .
   . # # . .
   . . . . .
   . . # . .
   . . . . G
   ```

   说明:
   - S = 起点(0, 0)
   - G = 终点(4, 4)
   - # = 障碍物
   - 每走一格代价 = 1
   - 只允许上下左右移动

   规定:
   - 左上角: (0, 0)
   - 向右 x 增加
   - 向下 y 增加
   
   地图变成坐标形式
   ```
    (0,0) S   (1,0) .   (2,0) .   (3,0) .   (4,0) .
    (0,1) .   (1,1) #   (2,1) #   (3,1) .   (4,1) .
    (0,2) .   (1,2) .   (2,2) .   (3,2) .   (4,2) .
    (0,3) .   (1,3) .   (2,3) #   (3,3) .   (4,3) .
    (0,4) .   (1,4) .   (2,4) .   (3,4) .   (4,4) G
   ```

---

2. 起点
   ```
   g = 0
   h = 曼哈顿距离 = |4-0| + |4-0| = 8
   f = 0 + 8 = 8
   ```
   放入 open 集合
   - open = {(0, 0)}
   - closed = {}

---

3. 第 1 轮循环

   从 open 里选 f 最小的: (0, 0) f = 8

---

   **把 (0, 0) 移到 closed**
   - open = {}
   - closed = {(0, 0)[8,0]}

---

   **扩展邻居**

   可走方向:
   - 右 → (1,0)
   - 下 → (0,1)
   - (左、上越界)

---
   
   **节点(1, 0)**
   ```
   g = 1
   h = |4 - 1| + |4 - 0| = 7
   f = 1 + 7 = 8
   ```
  
   加入 open

---

   **节点(0, 1)**
   ```
   g = 1
   h = |4 - 0| + |4 - 1| = 7
   f = 1 + 7 = 8
   ```

   加入 open

---

   现在:
   open = { (1,0)[8,1], (0,1)[8,1] }

4. 第 2 轮循环
   两个 f 都是 8。

   我们选先加入的 (1,0)[8,1]。

---

   **移动到 closed**
   - open = { (0,1)[8,1] }
   - closed = { (0,0)[8,0], (1,0)[8, 1] }

---

   **扩展(1,0)[8,1]**

   可走方向:
   - 右 → (2,0)
   - 下 → (1,1)
   - 左 → (0,0)

---

   (0,0) 在 closed → 跳过
 
   (1,1) 是障碍物 → 跳过

---
   
   **节点(2, 0)**
   ```
   g = 1 + 1 = 2
   h = |4-2| + |4-0| = 2 + 4 = 6
   f = 2 + 6 = 8
   ```
  
   加入 open, 现在 `open = { (0,1)[8,1], (2,0)[8,2] }`

---

5. 第 3 轮循环
   选(0, 1)[8,1]

---

   **移动到closed**
   - open = { (2,0)[8] }
   - closed = {(0,0)[8,0], (1,0)[8, 1], (0,1)[8,1] }

---
  
   **扩展(0, 1)[8,1]**

   可走方向:
   - 右 → (0,2)
   - 下 → (1,1)
   - 左 → (0,0)

--- 
   (0,0) 在 closed → 跳过

   (1,1) 是障碍物 → 跳过

---

   **节点(0, 2)**
   ```
   g = 1 + 1 = 2
   h = |4-0| + |4-2| = 4 + 2 = 6
   f = 8
   ```

   加入 open, 现在 `open = { (2,0)[8,2], (0,2)[8,2] }`

--- 

6. 第 4 轮循环
   选先加入的 (2, 0)[8,2]

---

   **移动到closed**
   - open = { (0,2)[8,2] }
   - closed = { (0,0)[8,0], (1,0)[8, 1], (0,1)[8,1], (2,0)[8,2] }

---

   **扩展 (2,0)[8,2]**

   可走方向:
   - 右 → (3,0)
   - 下 → (2,1)
   - 左 → (1,0)

---

   (1,0) 在 closed → 跳过

   (2,1) 是障碍 → 跳过

---

   **节点(3, 0)**
   ```
   g = 3
   h = |4-3| + |4-0| = 1 + 4 = 5
   f = 8
   ```

   加入 open, 现在 `open = { 0,2)[8,2], (3,0)[8,3] }`

---

7. 第 5 轮循环
   选 (0,2)[8,2]

---

   **移动到closed**
   - open = { (3,0)[8,3] }
   - closed = { (0,0)[8,0], (1,0)[8, 1], (0,1)[8,1], (2,0)[8,2], (0,2)[8,2] }

---

   **扩展(0,2)[8,2]**
 
   可走方向:
   - 右 → (1,2)
   - 下 → (0,3)
   - 上 → (0,1)

---

   (0,1) 在 closed → 跳过

---

   **节点 (0,3)**
   ```
   g = 2 + 1 = 3
   h = |4-0| + |4-3| = 5
   f = 8
   ```

   加入 open, 现在 `open = { (3,0)[8,3], (0,3)[8,3] }`

---

   **节点(1,2)**
   ```
   g = 3
   h = |4-1| + |4-2| = 5
   f = 8
   ```

   加入 open, 现在 `open = { (3,0)[8,3], (0,3)[8,3], (1,2)[8,3] }`

---

8. 第 6 轮循环
   选 (3,0)[8,3]

--- 

   **移动到closed**
   - open = { (0,3)[8,3], (1,2)[8,3] }
   - closed = { (0,0)[8,0], (1,0)[8, 1], (0,1)[8,1], (2,0)[8,2], (0,2)[8,2], (3,0)[8,3] }

---

   **扩展(3,0)[8,3]**

   可选方向
   - 右 → (4,0)
   - 下 → (3,1)
   - 左 → (2,0)

---

   (2,0) 在 closed → 跳过

---

   **节点 (4,0)**
   ```
   g = 3 + 1 = 4
   h = |4-4| + |4-0| = 4
   f = 8
   ```

   加入 open, 现在 `open = { (0,3)[8,3], (1,2)[8,3], (4,0)[8,4] }`

---

   **节点 (3,1)**
   ```
   g = 4
   h = |4-3| + |4-1| = 4
   f = 8
   ```

   加入 open, 现在 `open = { (0,3)[8,3], (1,2)[8,3], (4,0)[8,4], (3,1)[8,4] }`

---

9. 第 7 轮循环
   选先加入的 (0,3)[8,3]

--- 

   **移动到closed**
   - open = { (1,2)[8,3], (4,0)[8,4], (3,1)[8,4] }
   - closed = { (0,0)[8,0], (1,0)[8, 1], (0,1)[8,1], (2,0)[8,2], (0,2)[8,2], (3,0)[8,3], (0,3)[8,3] }

---

   **扩展(0,3)[8,3]**

   可选方向
   - 右 → (1,2)
   - 下 → (0,4)
   - 上 → (0,2)

---

   (0,2) 在 closed → 跳过

---

   **节点(0,4)**
   ```
   g = 3 + 1 = 4
   h = |4-0| + |4-4| = 4
   f = 8
   ```

   加入 open, 现在 `open = { (1,2)[8,3], (4,0)[8,4], (3,1)[8,4], (0,4)[8,4] }` 

---

   **节点 (1,3)**
   ```
   g = 4
   h = |4-1| + |4-3| = 4
   f = 8
   ```

   加入 open, 现在 `open = { (1,2)[8,3], (4,0)[8,4], (3,1)[8,4], (0,4)[8,4], (1,3)[8,4] }`

---

10. 第 8 轮循环
    选(1,2)[8,3]

---

   **移动到closed**
   - open = { (4,0)[8,4], (3,1)[8,4], (0,4)[8,4], (1,3)[8,4] }
   - closed = { (0,0)[8,0], (1,0)[8, 1], (0,1)[8,1], (2,0)[8,2], (0,2)[8,2], (3,0)[8,3], (0,3)[8,3], (1,2)[8,3] }

---

   **扩展(1,2)[8,3]**

   (0,0) → (0,2) → (1,2), 所以 `g = 3`
   
   可选方向
   - 右 → (2,2)
   - 下 → (1,3)
   - 上 → (1,1)
   - 左 → (0,2)

---

   (1,1) 是障碍 → 跳过

   (0,2) 在 closed → 跳过

---

   **节点(2,2)**
   ```
   g = 3 + 1 = 4
   h = |4-2| + |4-2| = 4
   f = 8
   ```

   加入 open, 现在 `open = { (4,0)[8,4], (3,1)[8,4], (0,4)[8,4], (1,3)[8,4], (2,2)[8,4] }`

---

   **节点 (1,3)**
   
   已在 open 中, 查看是否需要更新 g
   ```
   当前 g = 3 + 1= 4
   新 g = 4
   旧 g = 4
   不更优 → 不更新
   ```

---

11. 终止
    当访问到 `(4,4)` 时不再扩展邻居, 终止循环

---

12. 取最短路径
    
    核心答案:
    > 靠 parent 指针回溯
   
---

   终点(4,4), g= 8
   ```
   终点开始，沿着 g 每次减 1 反推
   1. 从 closed 里找出与它相邻且 g = 7 的点
   2. 从 closed 里找出 1 中与它相邻且 g = 6 的点
   3. 从 closed 里找出 2 中与它相邻且 g = 5 的点
   4. 从 closed 里找出 3 中与它相邻且 g = 4 的点
   5. 从 closed 里找出 4 中与它相邻且 g = 3 的点
   6. 从 closed 里找出 5 中与它相邻且 g = 2 的点
   7. 从 closed 里找出 6 中与它相邻且 g = 1 的点
   8. 从 closed 里找出 7 中与它相邻且 g = 0 的点
   ```

13. 注意
   - 已经访问过的不再重复计算
   - 障碍物不能走

## 关键现象
   A* 会逐渐形成一个“朝目标方向的扇形搜索区域”, 而不是像 Dijkstra 那样一圈一圈扩散, 这就是启发式函数的作用。

---

## 为什么 A* 比 BFS 好?
| 算法       | 能否找最短路径 | 是否有方向感 | 效率 |
| -------- | ------- | ------ | -- |
| BFS      | 可以      | 没有     | 慢  |
| Dijkstra | 可以      | 没有     | 较慢 |
| A*       | 可以      | 有      | 快  |





  