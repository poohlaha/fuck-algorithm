# Sunday 算法
  一种 `字符串匹配算法`，由 Daniel M. Sunday 在 1990 年提出。它是 `Boyer-Moore` 算法的一个 `变种`，简洁高效、易于实现，尤其适合在实际工程中处理较长文本的精确字符串查找
  
1. 特性
   - 每次比较从 `模式串的最右字符开始`
   - 如果匹配失败，就看 `文本中当前窗口后一个字符`(也就是 `文本中当前位置` + `模式串长度` 的字符)
   - 根据 `这个字符在模式串中的最右位置` 决定跳过多少位
   - 和 `QS` 一模一样

2. 时间复杂度
   - 最好情况: O(n / m)
   - 最坏情况: O(n * m)
   - 平均情况: 接近 O(n)

3. 空间复杂度
   - O(σ)(其中 `σ` 是字符集大小(如 ASCII 为 256))

4. 使用场景
   - 查找文本中的固定模式串, 尤其是:
     - 模式串较短(10 ~ 100)
     - 文本较长(百万级日志, 网页等)
   - `工程实践中` 性能好于 `KMP` 和 `BM`, 常用于编辑器(如 Sublime Text)、搜索引擎底层文本扫描等
   - `内存空间足够` 可以快速构建 `shift` 表时

5. 实现步骤
   同 `OS`

6. 举例
   同 `OS`

7. Sunday VS Quick Search
   ```text
   比较维度             Sunday 算法                                    Quick Search(QS) 算法
   发明者/来源          Daniel M. Sunday (1990)                        同 Sunday 算法，是 Sunday 算法的工程化实现       
   匹配比较方向         从左到右比较                                     从左到右比较
   预处理              构建 shift 表：shift[c] = m - 最后一次出现位置     完全一样
   滑动跳跃依据         看窗口后一个字符 text[i + m] 的 shift 值           一样
   匹配失败时跳跃       按 shift 值滑动                                  一样
   匹配成功处理         若需多次匹配，仍用 text[i + m] 决定下一跳           一样
   时间复杂度           平均 O(n)，最坏 O(nm)                            一样
   空间复杂度           O(字符集大小 σ)                                  一样
   实现复杂度           简单，代码简洁                                    一样
   实际应用            经典字符串查找，文本搜索引擎等                       工程实现中最常用的“Sunday 算法”实现方式
   备注               Sunday 算法被认为是 QS 的理论基础                   QS 即 Sunday 的具体实现，名字不同但本质一致
   ```
   