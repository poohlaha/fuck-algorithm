# BM-Horspool 算法(Boyer-Moore-Horspool)
  一种改进版的字符串匹配算法, 是 Boyer-Moore 算法的一个简化变种, 在实际应用中非常高效，尤其适合于在大文本中查找一个短模式字符串的场景

1. 特性
   - 基于 `Boyer-Moore(BM)` 算法的思想:
     - 从 `右向左` 比较模式串与文本
     - 利用 `坏字符规则(bad character rule)` 来进行高效的跳跃
   - `只使用坏字符规则`, 并且是对它的一个简化: 只使用 `模式串中倒数第二个字符之前的部分` 来构造跳跃表

2. 时间复杂度
   - 最坏时间复杂度: `O(n * m)`(模式串每次只滑动一位，字符频繁不匹配)
   - 平均时间复杂度: `O(n)`(大多数情况下能快速跳跃，远小于 n*m)

3. 空间复杂度
   - `O(m + σ)`, 其中 `σ` 是字符集大小(如 ASCII 为 256)

4. 步骤
   - 只使用 `BM` 中的 `坏字符规则`, 其余均一样
   
5. 使用场景
   - 日志搜索
     - 在大量系统日志中查找某些关键词
   - 文件内容搜索
     - 文本编辑器中的查找功能
   - DNA/基因序列匹配
     - 基因片段快速定位
   - 信息安全
     - 入侵检测系统中匹配攻击模式
   - 文本数据挖掘
     - 快速从大规模数据中定位特定短语

6. `BM-Horspool` 和 `Boyer-Moore` 对比
    ```text
    特性                                  BM-Horspool                              Boyer-Moore(完整)
    启发策略                               仅用坏字符(简化版)                         坏字符 + 好后缀(双启发)
    实现复杂度                             简单, 容易实现                             复杂，尤其是好后缀规则
    平均匹配速度                           快(大多数文本下表现优)                       非常快(理论上最优)
    最坏情况性能                           O(n * m)(可能退化)                         O(n + m), 可避免最坏情况
    预处理时间与空间复杂度                   O(σ), 仅坏字符表                           O(σ + m), 包括好后缀表
    工程实用性                             工业界常用（例如日志分析、查毒引擎等）          更适合学术研究或极致性能要求
    ```
   
7. 如何选择
   - 希望实现快速、简单、高效的字符串匹配, 不追求最优跳跃, 使用 `BM-Horspool`
     - 适合场景
       - 快速关键词搜索(如编辑器查找)
       - 文本日志匹配(如 grep、IDS 系统)
       - 模式串较短(< 20 字符)
       - 可容忍偶尔的性能退化
   - 处理的是极端数据，有大量重复字符，且需要稳定性能, 使用 `Boyer-Moore`
     - 适合场景
       - 模式串和文本都很长，且有大量重复内容
       - 你需要避免最坏情况 O(n*m)(比如反复出现 `aaaaa` 这样的字符)
       - 对每一次匹配的跳跃效率都很敏感(如数据库全文索引)
   - 文本非常长，模式串很短, 使用 `BM-Horspool`
     - 模式串短，坏字符表就足够工作
     - 真实文本中字符分布稀疏，跳跃更频繁
     - 不需要额外空间维护好后缀表
   - 模式串较长，匹配规则较复杂, 使用 `Boyer-Moore`
     - 因为好后缀规则可以根据匹配段结构进行优化跳跃，是一种结构化的利用
   - 快速上线一个匹配算法功能, 直接选 `BM-Horspool`
     - 几行代码搞定跳跃表，效果足够好，部署迅速

- 以 `RustRover` 为例
  `RustRover` 有以下几个查找功能
  - 当前文件内查找(`Find in File`)
    - 模式串通常很短(比如用户输入 `Mutex`)
    - 文本范围较小(一个文件几十 KB，几千行以内)
    - 查找响应要 `非常快`
    - 极大可能使用 `BM-Horspool` 或 `Quick Search(QS)` 算法
      - 模式串短，`BM-Horspool` 跳得快，处理快
      - 文件小，不需要防御最坏情况
      - 实现简单，能快速定位多个匹配点
      - 实际上 `BM-Horspool`、`Quick Search`、甚至 `Rabin-Karp` 都是编辑器中查找的 `经典候选算法`
  - 全局查找(`Find in Project`)
    - 搜索范围非常大: 成千上万个文件
    - 模式串通常也很短(一个函数名或关键词)
    - 查找速度要求仍然高，但空间换时间可接受
    - 要支持边查边展示结果(流式)
    - 使用 `预索引 + BM-Horspool/BM/KMP` 等算法的组合
      - `RustRover` 背后是 `IntelliJ` 平台，它会对工程源码做 `预索引`(`类 inverted index`)
      - 但对于未被索引的部分(如新文件、临时 buffer)，仍然需要实时匹配
      - 在这些实时匹配中，`BM-Horspool` 是首选
        - 初始化快
        - 匹配快
        - 平均跳跃远
      - 少数边界情况，可能使用 `完整 Boyer-Moore` 来避免极端退化
  - 跳转符号 / 文件名(`Go to Symbol/File`)
  - 结构性搜索 / 正则搜索(`Structural Search / Regex`)
  - 公开信息
    - 默认查找使用的是 `BM-Horspool` 或 `类似 QuickSearch` 算法
    - `全局查找场` 景下，用了索引(`索引基于 Lucene`)进行加速
    - 对于正则查找或复杂模式，回退到 Java 标准库的正则引擎