# 原地算法(In-place Algorithm)

1. 定义
   原地算法是指在执行过程中 `几乎不需要额外的辅助空间`, 只使用常数级别(O(1)) 或极少的额外空间, 就能在输入数据结构本身上直接进行修改或操作
   - 原地算法 = `边改边用`
   - 不会再开一个大数组、链表或复杂的存储来存结果
   - 每次只做 `找最小 + 交换一次`，交换是在原数组上进行，最多只需要几个额外的变量

2. 时间/空间复杂度
   - 时间复杂度: O(n)(每个元素最多交换一次)
   - 空间复杂度: O(1)(只用了两个指针 left 和 right)

3. 举例
   ```text
   选择排序: 每轮选最小并与当前位置交换
   数组: [8, 3, 5, 2, 7, 4]
   索引:  0  1  2  3  4  5
   
   每一轮在未排序区间里找最小值，跟当前起始位置交换
   
   1. 未排序区间 [0, 5]: [8, 3, 5, 2, 7, 4]
      最小值: 2(下标 3), 与 8(下标 0) 交换
      得到: [2, 3, 5, 8, 7, 4]
   
   2. 未排序区间 [1, 5]: [3, 5, 8, 7, 4]
      最小值: 3(下标 1), 交换等于不动
      得到: [2, 3, 5, 8, 7, 4]
   
   3. 未排序区间 [2, 5]: [5, 8, 7, 4]
      最小值: 4(下标 5), 与 5(下标 2) 交换
      得到: [2, 3, 4, 8, 7, 5]
   
   4. 未排序区间 [3, 5]: [8, 7, 5]
      最小值: 5(下标 5), 与 8(下标 3) 交换
      得到: [2, 3, 4, 5, 7, 8]
   
   5. 未排序区间 [4， 5]: [7, 8]
      最小值: 7(下标 4), 交换等于不动
      得到: [2, 3, 4, 5, 7, 8]
   ```
   
   ```text
   插入排序: 把每个元素“插入”到已排好的一侧
   数组: [8, 3, 5, 2, 7, 4]
   索引:  0  1  2  3  4  5
   
   初始: 第 0 个元素(8) 当作已排好的左区间
   1. 插入 3 到 [8]
      3 < 8, 把 3 放到 8 前面位置
      得到 [3, 8, 5, 2, 7, 4]
   
   2. 插入 5 到 [3, 8]
      5 < 8, 放到 8 前面, 得到 [3, 5, 8]
      5 > 3, 停止
      得到: [3, 5, 8, 2, 7, 4]
   
   3. 插入 2 到 [3, 5, 8]
      2 < 8, 放到 8 前面, 得到 [3, 5, 2, 8]
      2 < 5, 放到 5 前面, 得到 [3, 2, 5, 8]
      2 < 3, 放到 2 前面, 得到 [2, 3, 5, 8]
   
   4. 插入 7 到 [2, 3, 5, 8]
      7 < 8, 放到 8 前面, 得到 [2, 3, 5, 7, 8]
      7 > 5, 停止
      得到: [2, 3, 5, 7, 8]
   
   5. 插入 4 到 [2, 3, 5, 7, 8]
      4 < 8, 放到 8 前面, 得到 [2, 3, 5, 7, 4, 8]
      4 < 7, 放到 7 前面, 得到 [2, 3, 5, 4, 7, 8]
      4 < 5, 放到 5 前面, 得到 [2, 3, 4, 5, 7, 8]
      4 > 3, 停止
      得到: [2, 3, 4, 5, 7, 8]
   ``` 
   
4. 去重
   ```text
   数组: [1, 1, 2, 2, 2, 3, 4, 4, 5]
   索引:  0  1  2  3  4  5  6  7  8
   
   初始: p1 = 0(第一个元素下标), p2 = 1(第二个元素下标)(快慢指针)
   
   第一轮:
   1. p2 = 1
      arr[p2] = arr[1] = 1
      arr[p1] = arr[1] = 1
      arr[p1] = arr[p2], 跳过
      p2 += 1 = 2
   
   2. p2 = 2
      arr[p2] = arr[2] = 2
      arr[p1] = arr[1] = 1
      arr[p1] != arr[p2], p1 += 1 = 1, 把 arr[p2] 写到 arr[p1] 位置
      arr[p1] = arr[p2] -> arr[1] = arr[2] = 2
      此时: [1, 2, 2, 2, 2, 3, 4, 4, 5]
      p1 = 1, p2 += 1 = 3
   
   3. p2 = 3
      arr[p2] = arr[3] = 2
      arr[p1] = arr[1] = 2
      arr[p1] = arr[p2], 跳过
      p2 += 1 = 4
   
   4. p2 = 4
      arr[p2] = arr[4] = 2
      arr[p1] = arr[1] = 2
      arr[p1] = arr[p2], 跳过
      p2 += 1 = 5
   
   5. p2 = 5
      arr[p2] = arr[5] = 3
      arr[p1] = arr[1] = 2
      arr[p1] != arr[p2], p1 += 1 = 2, 把 arr[p2] 写到 arr[p1] 位置
      arr[p1] = arr[p2] -> arr[2] = arr[5] = 3
      此时: [1, 2, 3, 2, 2, 3, 4, 4, 5]
      p1 = 2, p2 += 1 = 6
   
   6. p2 = 6
      arr[p2] = arr[6] = 4
      arr[p1] = arr[2] = 3
      arr[p1] != arr[p2], p1 += 1 = 3, 把 arr[p2] 写到 arr[p1] 位置
      arr[p1] = arr[p2] -> arr[3] = arr[6] = 4
      此时: [1, 2, 3, 4, 2, 3, 4, 4, 5]
      p1 = 3, p2 += 1 = 7
   
   7. p2 = 7
      arr[p2] = arr[7] = 4
      arr[p1] = arr[3] = 4
      arr[p1] = arr[p2], 跳过
      p2 += 1 = 8
   
   8. p2 = 8
      arr[p2] = arr[8] = 5
      arr[p1] = arr[3] = 4
      arr[p1] != arr[p2], p1 += 1 = 4, 把 arr[p2] 写到 arr[p1] 位置
      arr[p1] = arr[p2] -> arr[4] = arr[8] = 5
      此时: [1, 2, 3, 4, 5, 3, 4, 4, 5]
      p1 = 4, p2 += 1 = 9
   
   9. p2 = 9
      数组越界, 停止
   
   最终: 
       [1, 2, 3, 4, 5, 3, 4, 4, 5]
       p1 = 4
       取 [0..4] = [1, 2, 3, 4, 5]
   ```

# Lomuto 分区法(Lomuto partition scheme)
1. 定义
  `快速排序(Quicksort) 的一种分区方法`, 基准在最后，扫描时把 `小于等于 pivot` 的元素 `交换到左边`

2. 核心思想
   ```text
   1. 选择 `最后一个元素` 作为基准值(pivot)
   2. 用一个指针 `i`, 记录 `比 pivot 小的区域` 的边界, 初始时 `i = left - 1`
   3. 遍历数组的每个元素(除了 pivot 自身):
      - 如果当前元素 `<= pivot`, 则把它交换到 `i + 1` 位置, 然后 `i++`
      - 如果当前元素 `> pivot`, 则 `跳过`   
   4. 遍历完成后, 把 `pivot` 放到 `i + 1` 的位置
   5. 这样就完成了:
      - `pivot` 左边都是 `<= pivot`
      - `pivot` 右边都是 `>= pivot`
      - `pivot` 在最终正确的位置
   6. 整个过程只需要 `在原数组上交换` -> 原地算法
   ```
   
2. 时间复杂度
   - 最好情况: pivot 每次把数组均分(即每次正好在中间)
     - 分区要 `O(n)`, 递归深度 `O(log n)`
   - 最坏情况: 数组已经有序(或逆序), pivot 每次都选到最大/最小元素, 导致分区极度不平衡
     - 分区 `O(n) + O(n-1) + ... + O(1) = O(n^2)`
     - 总复杂度: `O(n^2)`
   - 平均情况: 随机输入或随机选 `pivot`, 期望时间复杂度: `O(n log n)`
   
3. 空间复杂度
   - 分区本身: 只用常数个变量(`i`、`pivot`、`临时交换变量`) -> O(1)
   - 递归调用栈:
     - 最好/平均情况: 递归深度 `O(log n)`, 所以空间复杂度: `O(log n)`
     - 最坏情况: 递归深夜 `O(n)`, 所有空间复杂度: `O(n)`
   
4. 使用场景
   - 教学/理解快速排序 
     - Lomuto 的逻辑更直观: 把“小于等于 pivot 的元素”放左边，然后 pivot 插入中间
     - 很适合作为入门讲解
   - 数组元素较少 / 实现简洁优先
     - 代码简单，适合写竞赛或笔试题
   - 配合 `三数取中` 随机化 pivot
     - Lomuto 的缺点是遇到大量重复元素时性能差，但如果随机选 pivot 或用三数取中法，就能减少最坏情况概率

5. 举例
   ```text
   数组: [8, 3, 5, 2, 7, 4]
   pivot = 4(最后一个元素)
   
   初始: i = -1, pivot = 4, j = 0
   
   从左到右扫描
   1. j = 0, arr[0] = 8
      8 > pivot(4), 不动
   
   2. j = 1, arr[1] = 3
      3 <= pivot(4), i += 1 -> i = 0
      交换 arr[i] 和 arr[j] -> 交换 arr[0] 与 arr[1]
      得到: [3, 8, 5, 2, 7, 4]
   
   3. j = 2, arr[2] = 5
      5 > pivot(4), 不动
   
   4. j = 3, arr[3] = 2
      2 <= pivot(4), i += 1 -> i = 1
      交换 arr[i] 和 arr[j] -> 交换 arr[1] 和 arr[3]
      得到: [3, 2, 5, 8, 7, 4]
   
   5. j = 4, arr[4] = 7
      7 > povit(4), 不动
   
   扫描结束:
     i = 1 -> 比 povit(4) 小的元素在 [0 .. 1](3, 2)
     最后一步: 把 pivot(4) 放到 i + 1 = 2 的位置
     交换 arr[2] = 5 和 arr[5] = 4
   
   最终: [3, 2, 4, 8, 7, 5]
   结果:
      pivot(4) 已经放到正确位置(下标 2)
      左边 [3, 2] <= 4, 右边 [8, 7, 5] >= 4
   ```
   
# Hoare 分区法(Hoare partition scheme)
1. 定义
   `快速排序的一种分区方法`, 由 C.A.R.Hoare(快速排序的进出者) 提出

2. 核心思想
   ```text
   1. 选择 `第一个元素` 作为 pivot(基准值)
   2. 设置两个指针:
      - i 从 `左往右扫描`, 直到遇到 `大于等于 pivot` 的元素
      - j 从 `右往左扫描`, 直到遇到 `小于 pivot` 的元素
   3. 如果 `i < j`, 交换 `arr[i]` 和 `arr[j]`, 继续移动
   4. 如果 `i >= j`, 停止, 返回 `j` 作为分区点
   
   特点:
      pivot 不一定会被放到最终位置(与 Lomuto 不同), 但能保证分区:
      - arr[left..j] <= pivot
      - arr[j+1..right] >= pivot
   ```
   
3. 时间复杂度
   - 分区过程: 每个元素最多比较一次 → `O(n)`
   - 递归:
     - 最好情况(pivot 总是接近中位数): `T(n) = 2T(n/2) + O(n) → O(n log n)`
     - 最坏情况(pivot 总是极端，数组已排好序)：`T(n) = T(n-1) + O(n) → O(n²)`
     - 平均情况: 期望 `O(n log n)`
     
4. 空间复杂度
   - 分区过程只用了常数额外变量(i, j, pivot) → `O(1)`
   - 递归栈
     - 平均/最好情况：递归深度 `O(log n)`
     - 最坏情况: 递归深度 `O(n)`
   
5. 使用场景
   - 性能要求较高
     - 因为交换次数少，常用于工业级快速排序实现（例如 C 标准库的 qsort 就采用类似 Hoare 的变种
   - 数组规模较大
     - Hoare 分区能减少不必要的写操作，提升大数据排序效率
   - 重复元素较多
     - Hoare 分区在遇到重复元素时不会退化太严重，比 Lomuto 更稳定
   
6. 举例
   ```text
   数组: [12, 7, 14, 9, 10, 11, 6, 2, 8, 15, 3]
   索引:   0  1   2  3   4   5  6  7  8   9  10
   
   初始: pivot = 12(第一个元素), i = 0, j = 10
   
   1. 第一轮
      i 向右走:
        i = 0, arr[0] = 12, 12 >= pivot(12), 停止
      
      j 向左走:
        j = 10, arr[10] = 3, 3 < pivot(12), 停止
      
      i < j (0 < 10) -> 交换 arr[0] 和 arr[10]
      得到: [3, 7, 14, 9, 10, 11, 6, 2, 8, 15, 12]  
      此时: i = 0, j = 10
   
   2. 第二轮
      i 向右走:
        i = 1, arr[1] = 7, 7 < pivot(12), 继续
        i = 2, arr[2] = 14, 14 > pivot(12), 停止
   
      j 向左走:
        j = 9, arr[9] = 15, 15 >= pivot(12), 继续
        j = 8, arr[8] = 8, 8 < pivot(12), 停止
   
      i < j (2 < 8) -> 交换 arr[2] 和 arr[8]
      得到: [3, 7, 8, 9, 10, 11, 6, 2, 14, 15, 12]  
      此时 i = 2, j = 8
   
   3. 第三轮
      i 向右走:
        i = 3, arr[3] = 9, 9 < pivot(12), 继续
        i = 4, arr[4] = 10, 10 < pivot(12), 继续
        i = 5, arr[5] = 11, 11 < pivot(12), 继续
        i = 6, arr[6] = 6, 6 < pivot(12), 继续
        i = 7, arr[7] = 2, 2 < pivot(12), 继续
        i = 8, arr[8] = 14, 14 > pivot(12), 停止
   
      j 向左走:
        j = 7, arr[7] = 2, 2 <= pivot(12), 停止
        
      i < j (8 < 7) -> 不成立, 停止
   
   最终: [3, 7, 8, 9, 10, 11, 6, 2, 14, 15, 12] 
         j = 7 作为区分点
         此时:
             左边: [3, 7, 8, 9, 10, 11, 6, 2] ≤ pivot (12)
             右边: [14, 15, 12] ≥ pivot (12)
   ```
   
   ```text
   数组: [3, 2, 2, 3, 4, 2], val = 2
   索引:  0  1  2  3  4  5
   
   初始: p1 = 0, p2 = 0
   
   1. p2 = 0
      arr[p2] = 3, 不相等, 写入
      arr[p1] = arr[p2]
      p1 += 1 = 1
      此时数组: [3, 2, 2, 3, 4, 2]
   
   2. p2 = 1
      arr[p2] = 2, 相等, 跳过
      此时数组: [3, 2, 2, 3, 4, 2]
   
   3. p2 = 2
      arr[p2] = 2, 相等, 跳过
      此时数组: [3, 2, 2, 3, 4, 2]
   
   4. p2 = 3
      arr[3] = 3, 不相等, 写入
      arr[p1] = arr[p2]
      p1 += 1 = 2
      此时数组: [3, 3, 2, 3, 4, 2]
   
   5. p2 = 4
      arr[p2] = 4, 不相等, 写入
      arr[p1] = arr[p2]
      p1 += 1 = 3
      此时数组: [3, 3, 4, 3, 4, 2]
   
   6. p2 = 5
      arr[p2] = 2, 相等, 跳过
   
   最终: 
       p1=3, 说明新数组长度是 3
       nums 的前 3 个元素就是结果 → [3, 3, 4]
   ```
   
7. 总结
   ```text
   Lomuto 分区: pivot 最后放在正确位置, 代码简单, 缺点是交换次数稍多
   Hoare 分区: pivot 不一定到位, 但分区效率更高, 通常交换次数更少
   共同点: 都在数组中就地交换, `没有额外数组`, 所在是 `原地算法`
   ```
   
8. 对比
   ```text
   特点                        Lomuto             Hoare
   pivot 选择                  最右元素            最左元素
   pivot 是否归位               一定会归位          不一定归位
   交换次数                     较多               较少(更高效)
   实际性能                     相对慢一些          一般比 Lomuto 更快
   实现复杂度                   简单(更直观)        稍微复杂(需注意边界条件)       
   ```

