# 贪心算法(Greedy Algorithm)
 贪心算法是一种在 `每一步都选择当前状态下最优解` 的算法策略。它期望通过一系列局部最优选择，最终得到问题的 `全局最优解`（或者 `接近最优解`）
 - 从问题的某个初始解出发
 - 通过 `贪心选择性质` 不断扩展当前解，做出每一步的最优选择
 - 最终得到问题的解
 - 贪心算法 `不一定总能得到最优解`，但在 `某些问题` 中，贪心策略 `可以得到最优解`。
 - 只在满足 `贪心选择性质` 和 `最优子结构` 的情况下，才可直接使用贪心

1. 时间复杂度
   - 预处理(排序/初始化)
   - 选择阶段(逐步做出贪心选择)
   
   - 1.1 很多贪心算法需要先对输入进行 `排序`
     - 活动选择问题: 按结束时间升序排序
     - 最小生成树 `Kruskal` 算法: 按边权升序排序
     - 哈夫曼编码: 使用堆，每次合并两个最小频率节点
     - 时间复杂度
       -  快速排序、归并排序: O(n log n)
       -  堆排序: O(n log n)

   - 1.2 贪心选择阶段
     - 排序完成后，通常只需要
       - 遍历一遍输入数据: O(n)
       - 或者在堆中做一些调整(例如哈夫曼编码，合并最小堆节点): O(log n)(如果是堆结构)
     - 活动选择：遍历活动，一次遍历：O(n) 
     - Kruskal 算法: 使用并查集的合并：O(α(n))（非常接近常数）
     - Dijkstra 算法(贪心+堆优化): O(E log V) （E: 边数, V: 点数）
   
   - 总结
     - `排序或堆操作`: 是贪心算法复杂度的 `主要来源`
     - `贪心选择过程`: 通常是 `线性 O(n)`
     - 因此, 贪心算法常见的`总时间复杂度是` `O(n log n)` 或 `O(E log V)` （如果用到图）
   ```markdown
    | 算法/问题       | 预处理阶段       | 贪心选择阶段          | 总体时间复杂度        |
    | 活动选择        | O(n log n)     | O(n)                 | **O(n log n)**     |
    | 哈夫曼编码       | O(n)（初始化堆） | O(n log n)（堆合并）  | **O(n log n)**     |
    | Kruskal 算法    | O(E log E)     | O(E α(n))           | **O(E log E)**      |
    | Dijkstra 算法   | O(E log V)     | -                   | **O(E log V)**      |
   ```
   
2. 举例
   - 2.1 以 `最小硬币找零` 为例, 假设有一些不同面额的硬币，目标是`凑成一个指定金额`，且使用的硬币数目 `尽可能少`
   ```text
    假如: 硬币面额集合 [1, 5, 10, 25]`, 要找零金额 `63`
    1. 贪心思路
    每次选择当前 `最大且不超过所需金额` 的面额, 直接凑成总金额
    核心策略:
      - 按面额从小到大考虑
      - 每次尽可能多用大面额的硬币
      - 继续用剩下的金额, 重复操作
   
    2. 步骤详解
       - 排序面额(大 -> 小): [25, 10, 5, 1]
       - 目标金额: 63
       - 从大面额往下凑
    
    3. 详细步骤
       - 使用硬币 `25` 
         - 65 / 25 = 2
         - 用了两个 `25` 硬币
         - 凑出: 2 * 25 = 50
         - 剩余金额: 65 - 50 = 13
         - 当前状态
           - 已用硬币: 2(面额 25)
           - 剩余金额: 13
   
       - 使用硬币 `10`
         - 13 / 10 = 1
         - 用了一个 `10` 元硬币
         - 凑出: 1 * 10 = 10
         - 剩余金额: 13 - 10 = 3
         - 当前状态
           - 已用硬币: 2(25元) + 1(10元) = 3
           - 剩余金额: 3
   
       - 使用硬币 `3`
         - 5 / 3 = 0
         - 无法使用 5 硬币
         - 跳过
   
       - 使用硬币 `1`
         - 3 / 1 = 3
         - 用了三个 `1` 元硬币
         - 凑出: 1 * 3 = 3
         - 剩余金额: 13 - 10 = 3: 3 - 3 = 0
         - 当前状态
           - 已用硬币: 2(25元) + 1(10元) + 3(1元) = 6
           - 剩余金额: 0
         - 结束
       - 最终
         - 总共使用 `6` 个硬币, 面值为 `25元 2 个`、`10元 1个`、`1元 3个`
         - 符合 `每次贪心选择最大面额` 原则
   ```
   - 2.2 以 `会议室预定(最多安排不冲突的会议)` 为例, 假设有一间会议室，有若干场不同的会议申请使用，每场会议有自己的开始时间和结束时间
     - 目标: 安排尽可能多的会议，且同一时间只能有一个会议进行(互不重叠)
   ```text
    假设有以下会议申请
    会议编号      开始时间      结束时间
    A            1             4 
    B            3             5 
    C            0             6 
    D            5             7 
    E            3             8 
    F            5             9 
    G            6             10 
    H            8             11 
    I            8             12 
    J            2             13
    K            12            14
   1. 贪心策略
   每次选择 `结束时间最早的会议`, 这样为后面的会议留出更多时间，局部最优解往往也导致全局最优
   
   2. 步骤详解
      - 按结束时间升序排列
   会议编号      开始时间      结束时间
    A            1             4 
    B            3             5 
    C            0             6 
    D            5             7 
    E            3             8 
    F            5             9 
    G            6             10 
    H            8             11 
    I            8             12 
    J            2             13
    K            12            14
   
   3. 详细步骤
     - 先选 `A`(1, 4) ✅ 
     - B start = 3 < 4, 冲突 -> 跳过  
     - C start = 0 < 4, 冲突 -> 跳过  
     - D start = 5 > 4, 不冲突 -> 满足, 此时会议结束时间为 `7` ✅ 
     - E start = 3 < 7, 冲突 -> 跳过 
     - F start = 5 < 7, 冲突 -> 跳过 
     - G start = 6 < 7, 冲突 -> 跳过 
     - H start = 8 < 7, 不冲突 -> 满足, 此时会议结束时间为 `11` ✅ 
     - I start = 8 < 11, 冲突 -> 跳过 
     - J start = 2 < 11, 冲突 -> 跳过 
     - K start = 12 > 11, 不冲突 -> 满足, 此时会议结束时间为 `14` ✅
     
     - 最终
       - 最多安排 `4 场会议`, 分别是 `A(1, 4)`、`D(5, 7)`、`H(8, 11)`、`K(12, 14)` 
   ```

3. 贪心策略是否最优？
   - 在 `美制面额体系（1, 5, 10, 25）` 下，贪心选择确实得到最优解
   - 但如果是 `不规则面额（例如 {1, 3, 4}）`，贪心选择未必得到最优解

4. 使用场景
   - 通常用于:
     - 每一步局部最优解 → 整体最优解
     - 可分解为一系列决策，且后续选择不会影响前面做的决策
   - 场景
     - 活动选择问题
       - 例子: 安排会议、安排课堂、广告投放
       - 目标: 在时间上互不重叠, 最多能安排多少个活动
       - 典型应用
         - 会议室预定（最多能安排多少个不冲突的会议）
         - 直播平台排档期（尽量多安排场次）
         - 影院安排排片（在相同厅里放映尽可能多的影片）
     - 最小硬币找零问题
       - 例子: 找零、换零钱
       - 目标: 用最少的硬币或纸币，凑出指定金额
       - 典型应用
         - ATM 机自动出钞
         - 出租车找零
         - 银行点钞机配钞
       - ⚠️ 仅当面额体系允许贪心最优！
     - 哈夫曼编码 
       - 例子: 文件压缩、数据传输
       - 目标: 为每个字符分配尽量短的编码，且不冲突，压缩总长度最小
       - 典型应用
         - ZIP、RAR 文件压缩
         - JPEG 图片压缩
         - MP3 音乐文件压缩     
     - Kruskal/Prim 算法（最小生成树） 
       - 例子: 铺设网络、电路、光缆等，成本最小化
       - 目标: 连接所有节点，且总成本最小
       - 典型应用
         - 电力网设计（最省钱的电缆布局）
         - 通信网络（最小光缆/光纤成本）
         - 公路/铁路网（最小花费）     
     - Dijkstra 算法（最短路径）
       - 例子: 地图导航、网络路由
       - 目标: 从起点到其他点的最短路径
       - 典型应用
         - 地图导航（百度地图、高德地图等）
         - 物流/配送路径规划（外卖、快递）
         - 网络 IP 路由算法     
     - 分数背包问题（Fractional Knapsack）
       - 例子: 装货物，允许分割
       - 目标: 物品可切割，装入背包的总价值最大
       - 典型应用
         - 食品打包（按克称重）
         - 资源分配（石油、液体）
         - 股票、基金组合（按比例分配资产）
     - 区间覆盖问题（Set Cover 特殊情况）
       - 例子: 覆盖范围最小的基站布设
       - 目标: 覆盖所有客户，使用尽量少的基站或天线     
     - 负载均衡调度（启发式）
       - 例子: 分配任务给多个服务器/机器
       - 目标: 尽量平衡每台服务器的工作量
       - 典型应用
           - CDN 边缘节点调度
           - 服务器集群动态分配请求
         