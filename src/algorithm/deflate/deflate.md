# Deflate 算法
  `Deflate` 是一种数据 `无损压缩算法`, 即解压后数据可以 `完全恢复`, 广泛用于诸如 `ZIP 文件`、`GZIP`、`HTTP/HTTPS` 传输中的压缩等场景
  - Deflate 算法结合了两种著名的压缩算法:
  - `LZ77(Lempel-Ziv 1977)`: 一种基于字典的重复匹配(滑动窗口)的压缩方法
  - `Huffman 编码`: 一种基于符号出现频率的前缀编码，适合对数据中的频繁出现的模式进行进一步压缩

1. 工作原理
   Deflate 的压缩过程主要分为两个阶段:
   - LZ77(滑动窗口匹配)
     - `滑动窗口`: 算法维护一个 32KB 的滑动窗口(`历史数据缓冲区`)
     - `匹配搜索`: 当前数据与窗口内的历史数据进行匹配，查找 `最长匹配`(`最长重复序列`)
     - `编码`: 
       - `匹配项`: 用(`距离`, `长度`)来表示
       - `不匹配项`: 直接输出 `原始字节`(称为 `字面值`，literal)
     - 示例:
       - 假设待压缩的字符串为：`abcabcabcabc`
       - 滑动窗口从空开始:
         - 读入 `a`，窗口里 `没有匹配` ，输出 `a` -> 窗口更新: [a]
         - 读入 `b`，窗口里 `没有匹配` ，输出 `b` -> 窗口更新: [a, b]
         - 读入 `c`，窗口里 `没有匹配` ，输出 `c` -> 窗口更新: [a, b, c]
         - 继续读入 `a`，在窗口中找到了第一个 `a`，`匹配距离=3(从窗口末尾往回数)`，`长度=1(只匹配一个字母)` -> 窗口更新: [a, b, c, a]
         - 继续读入 `b`，在窗口中找到了第一个 `b`，`匹配距离=3`，`长度=1` -> 窗口更新: [a, b, c, a, b]
         - 继续读入 `c`，在窗口中找到了第一个 `c`，`匹配距离=3`，`长度=1` -> 窗口更新: [[a, b, c, a, b, c]
         - 这时候我们注意到，其实从 `abc` 之后，整个 `abc` 序列都 `一模一样重复了`, 为了提高效率，`LZ77` 实现通常会尽量找 `最长匹配`(`不仅仅是单字节匹配`)
         - 步骤 `4-6 优化匹配`
           - 当前数据是 `abcabcabcabcabc`
           - 在滑动窗口 `[a, b, c]` 中找 `abc`
           - 发现从 `当前位置开始`，后面还有连续的 `abcabcabc`
           - 匹配距离=3
           - 匹配长度=12（因为 `abcabcabcabc 完全重复`）
           - 实际上可以输出一个更长的匹配: 匹配项: (`距离=3`, `长度=12`)
         - 最终会生成一些 `字面值` + (`距离, 长度`) 这样的匹配对
       - 匹配距离
         - 假设当前我们在压缩 `索引位置 12`（`从 0 开始算`），如果匹配串在窗口中的位置是 `索引位置 9`, 那么:
         ```text
            匹配距离 = 当前索引 12 - 匹配位置 9 = 3
            ps: 匹配距离是相对位置——告诉解压器 `往回走 3 个字节，从那开始复制`
         ```
       - 匹配长度
         - 匹配长度就是: `当前位置开始，连续和窗口中的匹配串一致的最大长度`
         ```text
            输入: abcabcabcabcabc
            索引:
                 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
                 a b c a b c a b c a b  c  a  b  c
            1. 当前位置
               - 当前扫描位置: 索引 3(字符 a)
               - 滑动窗口: 索引 0 ~ 2 (a, b , c)
            2. 匹配查找
              在窗口 `[a, b, c]` 里找出和当前位置开始匹配的最长串
              - 从 `索引 3· 开始是： a b c a b c a b c a b c a b c
              - 在窗口 `0~2` 找 `a` ➜ 找到了, `索引 0`
              - 继续匹配:
                - 索引窗口 `0: a`, 当前 `3: a`
                - 索引窗口 `1: b`, 当前 `4: b`
                - 索引窗口 `2: c`, 当前 `5: c`
                - 索引窗口 `0: a`, 当前 `6: a`
                - 索引窗口 `1: b`, 当前 `7: b`
                - 索引窗口 `2: c`, 当前 `8: c`
                - 索引窗口 `0: a`, 当前 `9: a`
                - 索引窗口 `1: b`, 当前 `10: b`
                - 索引窗口 `2: c`, 当前 `11: c`
                - 索引窗口 `0: a`, 当前 `12: a`
                - 索引窗口 `1: b`, 当前 `13: b`
                - 索引窗口 `2: c`, 当前 `14: c`
              - 每当匹配到窗口末尾(`索引 2`)，又循环回到窗口起点(`索引 0`)继续匹配
                - 当前要匹配的长度 = 15 - 3 = 12(`abcabcabcabc`)
         ```
       - 总结:
         - `匹配距离` = `复制从哪来的`
         - `匹配长度` = `要复制多少个节点`
   - Huffman 编码
     - 将 LZ77 的输出(字面值和匹配对)看作一个符号流
     - 统计每个符号出现的频率
     - 生成 Huffman 树，对频繁出现的符号使用更短的二进制编码
     - 这样进一步减少编码后的数据大小
   - 总结
     - 无损压缩: 数据可完全恢复
     - 结合 `LZ77` 和 `Huffman`，兼顾 `重复模式` 和 `符号频率`
     - 解压速度快: `Huffman` 编码解码只需要查表
     - 压缩比高: 适合有重复模式或符号分布集中的数据
     - 支持多种实现: 比如 `zlib`、`gzip`、`pkzip` 等

2. 时间复杂度
   - 压缩
     - `LZ77 查找匹配`: `最坏` 情况是 `O(N²)`，但通常用哈希表、二叉树等加速匹配，实际远低于平方级
     - `Huffman 编码`: `O(N + K log K)`, K 是不同符号的个数
     - `实际整体压缩复杂度`: 接近 `线性 O(N)`, 因为数据局部性强，哈希查找或树结构避免了完全平方复杂度
   - 解压
     - 主要是 `Huffman 解码` (`O(N)`)+ `复制匹配串`(`O(N)`)
     - 实际非常快，接近 `线性 O(N)`

3. 使用场景
   Deflate 因为其无损压缩能力和良好的性能，应用非常广泛:
   - 文件压缩: ZIP 文件、7z 文件（ZIP 模式）
   - 网络传输：HTTP/1.1、HTTP/2 中的内容编码（Content-Encoding: deflate）
   - GZIP 格式：gzip 流式压缩传输，HTTP 常用
   - PNG 图片：PNG 内部使用 Deflate 压缩像素数据
   - PDF 文件：PDF 也支持 Deflate 流(FlateDecode)