/*!
    希尔排序(Shell Sort)
    是 `插入排序` 的一种改进版。通过将数组分组，对分组内的元素进行插入排序，逐渐减少组内元素之间的间隔，直到最终所有元素在一个组中有序。
    1. 思想: 希尔排序通过不断缩小间隔（gap），使数组逐渐接近有序，再进行插入排序时效率会更高
    2. 时间复杂度:
      - 最坏情况: O(n 2)(依赖于间隔序列的选择)
      - 平均情况: O(n 1.3)(常用的间隔序列可以降低到这个范围)
      - 最好情况: O(n log n)(合理选择间隔序列时)
    3. 空间复杂度
      - O(1): 希尔排序是原地排序算法，不需要额外的空间
    4. 稳定性
      - 不稳定排序，因为相同值的元素可能因间隔的调整而交换位置
    5. 特点
      - 改进插入排序：通过分组减少移动元素的次数，加快排序速度。
      - 灵活性高：性能依赖于间隔序列的选择，常用的间隔序列有 Knuth 序列、Hibbard 序列等。
      - 适合中小规模数据：对于数据规模较大的情况下，性能逊于快速排序。

    步骤:
    1. 选择间隔序列:
       - 初始化一个较大的间隔值（gap），通常选择为 `数组长度的一半`
       - 在每一轮排序中，将 gap 减半，直到 gap = 1 为止
    2. 分组排序
       - 将数组按照间隔 gap 分为若干组，对每组中的元素使用插入排序
    3. 合并有序组
       - 每次 gap 减小时，组内有序的元素会逐渐变得全局有序
    4. 结束条件
       - 当 gap 缩小到 1 时，对整个数组进行最后一次插入排序，确保所有元素完全有序

    举例:
    假设数组：[12, 34, 54, 2, 3]
    1. 初始数组: [12, 34, 54, 2, 3]
    2. 选择间隔值(gap), 通常选择为 `数组长度的一半`:
       - gap = 5 / 2 = 2 (向下取整, 数组分为两组)
         - 对第 0、2、4 位置的数：[12, 54, 3] 进行插入排序，结果为 [3, 12, 54]
         - 对第 1、3 位置的数：[34, 2] 进行插入排序，结果为 [2, 34]
         - 排序结果为：[3, 2, 54, 12, 34]
       - gap = 2 / 2 = 1
         - 进行全数组插入排序：结果为 [2, 3, 12, 34, 54]
    3. 最终数组有序: [2, 3, 12, 34, 54]

    为什么举例和代码不一样？
    在理论上，我们提到希尔排序可以将数组分为若干组（如 gap = 2 时，分为 0-2-4 和 1-3 两组），
    对每组进行插入排序。然而，在代码中实际实现时，并不是直接将数组划分为这些显式的分组，而是利用 gap 间隔的索引动态地实现分组的插入排序。
    这意味着:
    - 代码中的分组是隐式的，通过 for i in gap..arr.len() 和 while j >= gap 来间接实现
    - 每次 for 循环遍历时，代码动态比较数组中「当前元素」和「gap 之前的元素」，进行插入排序。
    因此，理论中的分组（如 0-2-4 和 1-3）并不是实际代码中的操作顺序，而是逻辑上的描述。
    - 理论中的分组（0-2-4 和 1-3）
      - 是一种方便理解希尔排序原理的方式，即通过 gap 分割数组成独立的组
    - 实际代码中的隐式分组
      - 遍历整个数组的所有元素，通过 gap 控制插入排序的间隔，动态地模拟了分组效果
    这种实现方式不仅简单高效，而且避免了显式分组带来的复杂逻辑
*/

pub fn shell_sort<T: Ord + Clone>(arr: &mut [T]) {
    let n = arr.len();
    if n <= 1 {
        return;
    }

    // 2. 选择间隔值(gap), 通常选择为 `数组长度的一半`
    let mut gap = n / 2;
    while gap > 0 {
        for i in gap..arr.len() {
            let mut j = i;

            // 插入排序逻辑：比较当前元素与 gap 之前的元素
            while j >= gap && arr[j - gap] > arr[j] {
                arr.swap(j - gap, j); // 如果当前元素更小，则交换
                j -= gap;
            }
        }

        gap /= 2;
    }
}
