/*!
    冒泡改进算法(鸡尾酒排序)(双向冒泡排序)(Cocktail Shaker Sort)
    双向冒泡排序，是冒泡排序的改进版。传统的冒泡排序在每一轮只从头到尾进行比较和交换，而鸡尾酒排序则是先从左到右（正向）进行一轮，再从右到左（反向）进行一轮。通过这样的双向排序，可以更快地将未排序的元素移动到正确的位置，尤其对于接近有序的数组效果显著
    1. 思想:
        - 双向冒泡:
            - 第一轮从左到右比较相邻元素，将较大的元素逐步移动到右端
            - 接着从右到左比较相邻元素，将较小的元素逐步移动到左端
        - 范围逐渐缩小: 每次从左到右和从右到左的扫描过程中，边界元素会自动有序，下一轮的比较范围会逐渐缩小
        - 提前退出优化: 如果某一轮没有发生交换，则说明数组已经有序，可以提前退出，节省时间
    2. 时间复杂度:
       - 最优: O(n)(当数组已经有序时，只需一次正向和一次反向扫描)
       - 最差：O(n2)(当数组完全无序时，仍需多次遍历)
       - 平均: O(n2)(完全逆序的数组需要多次扫描和交换)
    3. 空间复杂度: O(1)(排序在原数组上进行，不需要额外的辅助空间)
    4. 特点:
       - 优点:
         - 比经典冒泡排序效率更高，尤其在部分有序的数组中
         - 通过双向冒泡，能够更快地将未排序的最大值和最小值移到正确位置
       - 缺点:
         - 对完全无序的数组，性能提升有限
         - 每轮需要双向扫描，增加了操作复杂度
     ps: 鸡尾酒排序通过双向扫描优化了经典冒泡排序的效率，在特定场景中能起到一定的提升作用，但整体复杂度仍与冒泡排序一致，适合于理解和教学场景，而非实际应用的大规模数据排序

     步骤:
        1. 初始化
           - 定义两个边界变量 start 和 end，分别表示未排序区域的起点和终点
           - 定义一个标志变量 swapped，用于判断当前轮是否发生了交换

        2. 正向冒泡
           - 从 start 开始到 end，依次比较相邻元素，如果前一个元素比后一个大，则交换它们
           - 记录最后一次交换的位置，更新 end 的值为该位置（意味着此后的部分已排序）
           - 如果一轮下来没有发生任何交换，说明数组已经有序，可以提前退出

        3. 反向冒泡
           - 从 end - 1 开始到 start，依次比较相邻元素，如果前一个元素比后一个大，则交换它们
           - 记录最后一次交换的位置，更新 start 的值为该位置
           - 如果一轮下来没有发生任何交换，说明数组已经有序，可以提前退出

        4. 重复上述过程
           - 直到 start >= end 时，排序完成

       举例:
        假设对数组 [3, 2, 4, 5, 1] 进行鸡尾酒排序
        1. 初始化: [3, 2, 4, 5, 1]
        2. 正向冒泡(start = 0, end = 4)
           - 比较 3 和 2，交换：[2, 3, 4, 5, 1]
           - 比较 3 和 4，不交换：[2, 3, 4, 5, 1]
           - 比较 4 和 5，不交换：[2, 3, 4, 5, 1]
           - 比较 5 和 1，交换：[2, 3, 4, 1, 5]
           - 更新 end = 3
        3. 反向冒泡（start = 0, end = 3）
           - 比较 1 和 4，交换：[2, 3, 1, 4, 5]
           - 比较 1 和 3，交换：[2, 1, 3, 4, 5]
           - 比较 1 和 2，交换：[1, 2, 3, 4, 5]
           - 更新 start = 1
        4. 正向冒泡 （start = 1, end = 3）
           - 比较 2 和 3，不交换：[1, 2, 3, 4, 5]
           - 比较 3 和 4，不交换：[1, 2, 3, 4, 5]
           - 无交换，排序完成
        最终结果：[1, 2, 3, 4, 5]
*/
pub fn cocktail_sort<T: Ord>(arr: &mut [T]) {
    let n = arr.len();
    if n <= 1 {
        return;
    }

    // 1. 初始化,
    let mut start = 0;
    let mut end = n - 1;
    let mut swapped = true;

    while swapped {
        // 2. 正向冒泡
        for i in start..end {
            if arr[i] > arr[i + 1] {
                arr.swap(i, i + 1);
                swapped = true
            }
        }

        // 没有交换则退出
        if !swapped {
            break;
        }

        end -= 1; // 更新终点
        swapped = false;

        // 3. 反向冒泡, (end, start)
        for i in (start..end).rev() {
            if arr[i] > arr[i + 1] {
                arr.swap(i, i + 1);
                swapped = true
            }
        }

        // 更新起点
        start += 1;
    }
}
