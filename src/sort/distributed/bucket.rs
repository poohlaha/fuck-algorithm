/*!
    桶排序(Bucket Sort)
    桶排序是一种基于分布的排序算法。其基本思想是将数据分到若干个桶里，每个桶内再进行排序，最后将所有桶中的数据按顺序合并起来。桶排序适合用于数据分布均匀的场景
    1. 思想: 将数据分到有限数量的桶中，每个桶内再分别排序
    2. 时间复杂度:
       - 最差：O(n2)(数据分布不均)
       - 平均: O(n + k)
    3. 空间复杂度: O(n + k)
    4. 特点: 适合分布均匀的数据

    步骤:
    1. 初始化桶:
       将待排序的元素划分到若干个桶中。每个桶内的元素会根据其值进行分配，通常桶的数量是根据数据的范围和分布来确定的。
    2. 数据分配到桶:
       将待排序元素放入不同的桶中。每个元素通过计算其值的范围（如最大值和最小值），决定它应该放入哪个桶中。
    3. 对每个桶内部进行排序:
       每个桶内的数据可以使用其他排序算法（如插入排序或快速排序）进行排序。通常情况下，桶内的元素比较少，所以使用简单排序算法效率较高。
    4. 合并结果:
       按照桶的顺序（从第一个桶到最后一个桶）将每个桶内的元素取出，最终得到排序后的数组。

    桶排序的时间复杂度:
     1. 平均时间复杂度:
        如果数据均匀分布，桶排序的时间复杂度为 O(n + k)，其中 n 是待排序元素的数量，k 是桶的数量。在桶内部排序时，假设使用插入排序，时间复杂度为 O(n/k)。因此，整体时间复杂度为 O(n + k)
     2. 最坏时间复杂度:
        如果数据分布极不均匀，导致所有元素都被放入一个桶中，桶内部的排序可能退化为比较排序（如快速排序或归并排序）。这种情况下，时间复杂度会退化到 O(n log n)。
     3. 空间复杂度:
        桶排序需要额外的空间来存储桶，因此空间复杂度为 O(n + k)，即需要 n 个元素的空间来存储数据，以及 k 个桶的空间。

    特点:
     - 适用场景
       桶排序适用于数据分布均匀的情况。当数据的最大值和最小值差距不大，并且数据的分布是近似均匀时，桶排序可以达到非常高的效率。
     - 稳定性
       如果桶内部的排序算法是稳定的（如插入排序），则桶排序也是稳定的。
     - 额外空间
       需要额外的空间来存储桶，因此桶排序需要较大的空间开销。
     - 时间复杂度取决于桶的数量
       如果桶的数量合适，时间复杂度可以接近线性。但如果桶的数量设置不合理，可能会导致性能下降。

     举例:
     假设有个数组: [29, 25, 3, 49, 9, 37, 21, 43]
     1. 确定最大值、最小值和桶的数量
        - 首先，我们需要计算出数组中的最小值和最大值，以便为元素分配桶。
        - min = 3
        - max = 49
      然后，我们选择桶的数量。通常情况下，桶的数量是根据数组大小和数据范围来决定的。这里我们选择使用 桶数 = sqrt(n) 的策略，其中 n 是数组的长度。
      数组长度 n = 8，所以桶数 桶数 = sqrt(8) ≈ 2，我们选择 2 个桶

    2. 根据数据范围来分配桶的范围
       我们需要计算每个桶的范围。
       - 数字的范围是从 `min = 3` 到 `max = 49`，所以范围是 `49 - 3 = 46`。
       - 每个桶的范围为 `桶范围 = (最大值 - 最小值) / 桶数 = 46 / 2 = 23`
         即每个桶的范围是 23
         这意味着:
         - 桶 1 存放区间是 [3, 26)（即 3 到 25）
         - 桶 2 存放区间是 [26, 49]（即 26 到 49）
    3. 将元素分配到桶中
       接下来，我们遍历数组中的每个元素，并将其根据桶的范围分配到相应的桶中。
       根据我们计算的桶范围:
         - 29 属于桶 2（因为 29 >= 26）
         - 25 属于桶 1（因为 25 < 26）
         - 3 属于桶 1（因为 3 < 26）
         - 49 属于桶 2（因为 49 >= 26）
         - 9 属于桶 1（因为 9 < 26）
         - 37 属于桶 2（因为 37 >= 26）
         - 21 属于桶 1（因为 21 < 26）
         - 43 属于桶 2（因为 43 >= 26）
       分配后的桶如下:
         - 桶 1：[25, 3, 9, 21]
         - 桶 2：[29, 49, 37, 43]
     4. 对每个桶内部进行排序
        接下来，我们对每个桶内部的元素进行排序
        - 对桶 1 内的 [25, 3, 9, 21] 进行排序，得到 [3, 9, 21, 25]
        - 对桶 2 内的 [29, 49, 37, 43] 进行排序，得到 [29, 37, 43, 49]
     5. 合并所有桶中的元素
        最后，我们按桶的顺序将每个桶内的元素合并起来，得到最终的排序结果:
        - 合并后：[3, 9, 21, 25, 29, 37, 43, 49]

     桶索引计算: ((值 - 最小值) / 桶范围).floor(), 向取整数, 2.5 -> 2
*/

pub fn bucket_sort<T>(arr: &mut [T]) -> Vec<T>
where
    T: Ord + Clone + Copy + Into<isize>,
{
    let n = arr.len();
    if n == 0 || n == 1 {
        return arr.to_vec();
    }

    // 1. 获取最大值和最小值
    let min = *arr.iter().min().unwrap();
    let max = *arr.iter().max().unwrap();

    let min: isize = min.into();
    let max: isize = max.into();

    // 2. 计算桶大小: sqrt(n)
    let count = (n as f32).sqrt() as usize;

    // 3. 计算桶范围: 桶范围 = (最大值 - 最小值) / 桶数
    let range = (max - min) / (count as isize);

    // 4. 创建桶
    let mut buckets: Vec<Vec<T>> = vec![Vec::new(); count];

    // 5. 将元素分配到桶
    for num in arr.iter() {
        let i_num: isize = (*num).into();
        // 计算桶索引: ((值 - 最小值) / 桶范围).floor(), 向取整数, 2.5 -> 2
        let bucket_index = (((i_num - min) / range) as f32).floor() as usize; // 向下取整 2.5 -> 2
        let bucket_index = bucket_index.min(count - 1); // 确保计算出来的桶索引不会超出桶的范围
        buckets[bucket_index].push(*num)
    }

    // 6. 对每个桶内部进行排序
    for bucket in &mut buckets {
        bucket.sort();
    }

    // 7. 合并所有桶中的元素
    let mut results = Vec::new();
    for bucket in buckets {
        results.extend(bucket);
    }

    results
}
