/*!
  堆排序(Heap Sort)
  1. 思想: 一种基于堆数据结构的比较排序算法，属于选择排序的一种。堆是一棵完全二叉树, 并且满足以下性质
     - 大顶堆：每个节点的值都大于或等于其子节点的值
     - 小顶堆：每个节点的值都小于或等于其子节点的值
    堆排序的核心思想是将数组视为一个完全二叉树，通过不断调整堆结构来获取最大值（或最小值），从而实现排序。
  2. 时间复杂度:
     - 最优: O(n log n)
     - 最差：O(n log n)
     - 平均: O(n log n)
     - 每次调整堆的复杂度为 O(n log n), 构建堆需要 O(n), 因此整体复杂度为 O(n log n)
  3. 空间复杂度: O(1), 为原地排序算法
  4. 特点: 不稳定排序，常用于需要高效排序的场景
     - 优点
       - 时间复杂度稳定：无论输入如何，始终保持  O(n log n)
       - 原地排序：不需要额外的辅助存储空间
       - 非递归实现：相比于快速排序，堆排序可以轻松实现为非递归版本
     - 缺点
       - 不稳定排序：两个相等的元素的顺序可能会在排序后改变。
       - 实现复杂：相较于快速排序，堆排序实现更复杂。

   步骤:
     1. 构建初始堆: 对数组元素进行调整，使其满足堆的性质（大顶堆或小顶堆）
     2. 交换堆顶与末尾元素: 将堆顶元素（最大值）与当前未排序区的最后一个元素交换
     3. 调整堆: 剩余元素重新调整为堆结构
     4. 重复步骤 2 和 3: 直到所有元素都排序完成

   创建堆从 heap_size / 2 开始, 叶子节点的索引范围为何从 heap_size / 2 到 heap_size - 1
   1. 二叉堆的数组表示方式
      二叉堆是一种 `完全二叉树`，它的一个重要特点是：可以用数组来表示。
     - 如果根节点的索引是 `i`
       - 左子节点的索引是 `2 * i + 1`
       - 右子节点的索引是 `2 * i + 2`
       - 父节点的索引是 `(i - 1) / 2`（如果 i > 0）

     举例:
      假设数组是 [4, 10, 3, 5, 1]，它在二叉堆中的表示为:
            4       <-- 索引 0
          /  \
        10   3      <-- 索引 1 和 2
       /  \
      5    1        <-- 索引 3 和 4(叶子节点)

   2. 什么是叶子节点
      - 在堆中，叶子节点是没有子节点的节点
      - 从数组的表示方式来看
        - 节点的索引为 `i`
        - 如果 `2 * i + 1 >= heap_size`, 则 `i` 是叶子节点，因为 `2 * i + 1` 是其左子节点的索引, 超出了数组范围

   - 叶子节点的索引范围
     - 假设堆的大小为 `heap_size`，数组索引从 `0` 到 `heap_size - 1`
     - 从哪个索引开始是叶子节点呢
       - 从 heap_size / 2 开始，因为对于任意索引 i >= heap_size / 2
       - `2 * i + 1`（左子节点）和 `2 * i + 2`（右子节点）都大于等于 `heap_size`，即它们已经超出范围
       - 所以，叶子节点的索引范围是 `[heap_size / 2, heap_size - 1]`

   - 为什么从 heap_size / 2 - 1 开始调整？
     - 调整堆的必要性:
       - 非叶子节点可能有子节点，因此需要进行堆调整（heapify）。
       - 叶子节点没有子节点，所以它们天然符合堆的性质，不需要调整。
     - 第一个非叶子节点的位置:
       - 从 heap_size / 2 - 1 开始，因为它是最后一个非叶子节点
       - 比如:
         - 数组长度为 5：最后一个非叶子节点是索引 `(5 / 2 - 1 = 1)`
         - 数组长度为 8：最后一个非叶子节点是索引 `(8 / 2 - 1 = 3)`
     - 从下到上调整的必要性:
       - 需要从最后一个非叶子节点开始，逐步向上调整堆
       - 因为堆调整是从子节点向父节点传播的: 如果先调整根节点，子节点可能还未调整好，导致整个堆无法正确构建

    举例: 数组 [4, 10, 3, 5, 1]
        - 初始状态(按数组构建的二叉树):
             4       <-- 索引 0
            /  \
          10   3      <-- 索引 1 和 2
         /  \
        5    1        <-- 索引 3 和 4(叶子节点)

        - 从最后一个非叶子节点（索引 1）开始：
          - 节点 10，子节点是 5 和 1。
          - 10 > 5, 10 > 1，不用调整。
        - 接着处理索引 0(根节点):
          - 节点 4，子节点是 10 和 3。
          - 10 最大，交换 4 和 10。
        - 调整后变为:
              10
            /   \
          4      3
         / \
        5   1

    1. 下沉(Sink)
      - 目的:
        - 将一个节点“下沉”到合适的位置，以恢复堆的性质。
        - 通常用于 `删除堆顶元素（或者交换堆顶元素与堆尾元素时）`，然后调整堆使其恢复有效的堆结构
      - 什么时候使用下沉？
        - 删除堆顶元素（通常是最大堆的最大值或者最小堆的最小值），然后将堆顶元素替换为最后一个元素，此时需要用下沉来恢复堆结构
        - 在交换堆顶元素与堆尾元素之后，下沉操作用于恢复堆的性质
      - 下沉的过程：
        - 假设我们从堆顶（根节点）开始，下沉操作会将当前节点与它的子节点进行比较。
        - 如果它的子节点比它大（对于大顶堆）或者比它小（对于小顶堆），则交换它与最大（或最小）子节点的位置。
        - 然后，继续对被交换的子节点进行下沉，直到整个堆恢复堆的性质。
      - 举例(大顶堆):
        - 假设我们有如下大顶堆：[10, 5, 3, 4, 1]，其中 10 是堆顶元素。
          - 我们将堆顶元素 10 删除，并用数组中的最后一个元素 1 替代堆顶，得到：[1, 5, 3, 4, 10]
          - 然后，1 需要“下沉”到合适的位置
          - 比较 1 与它的两个子节点 5 和 3，它的左子节点 5 更大，交换它们的位置：[5, 1, 3, 4, 10]
          - 接着，1 和它的新子节点 4 进行比较，4 比 1 大，交换它们的位置：[5, 4, 3, 1, 10]。
          - 这样，1 已经“下沉”到了合适的位置，堆的性质恢复。

      2. 上浮(Bubble Up)
        - 目的:
          - 将一个节点“上浮”到合适的位置，以恢复堆的性质。
          - 通常用于 `插入新元素` 到堆中时，通过上浮调整新插入的元素的位置。
        - 什么时候使用上浮？
          - 插入新元素时，通常会将新元素放置在堆的最后一个位置（数组末尾），然后通过上浮操作将该元素上移，直到堆满足堆的性质
          - 上浮通常用于保持堆的性质，确保新插入的元素不会破坏堆结构
        - 上浮的过程：
          - 假设我们将新元素放置在堆的末尾，并开始从该节点向上比较
          - 如果新插入的元素比它的父节点大（对于大顶堆）或者比它的父节点小（对于小顶堆），则交换它与父节点的位置
          - 然后继续对交换后的父节点进行上浮，直到堆的性质恢复
        - 举例(大顶堆):
          - 假设我们有如下大顶堆：[10, 5, 3, 4, 1]，现在我们要插入元素 6。
            - 初始堆：[10, 5, 3, 4, 1]，插入元素 6，堆变为：[10, 5, 3, 4, 1, 6]
            - 6 现在位于数组的末尾
            - 我们将 6 与它的父节点 3 比较，6 > 3，交换它们的位置，堆变为：[10, 5, 6, 4, 1, 3]
            - 然后，我们将 6 与它的新父节点 5 比较，6 > 5，交换它们的位置，堆变为：[10, 6, 5, 4, 1, 3]
            - 继续与 10 比较，6 < 10，上浮停止
        现在堆变为 [10, 6, 5, 4, 1, 3]，插入操作完成
        总结:
            - 下沉（Sink）
              - 用于删除堆顶元素或者交换堆顶元素与堆尾元素时
              - 调整堆的结构，使堆恢复堆的性质
              - 从根节点开始，逐步将节点下移，直到满足堆的性质。
            - 上浮（Bubble Up）
              - 用于插入新元素到堆中时
              - 将新元素从堆的末尾开始，逐步与父节点交换位置，直到堆满足堆的性质
       适用场景:
            - 下沉：删除堆顶元素，堆排序，交换堆顶与堆尾元素
            - 上浮：插入新元素，优先队列中元素的插入
*/

pub trait BinaryHeap<R> {
    /**
        在数组表示的完全二叉树中，每个父节点的左子节点总是在其索引的下一个位置。
        例如，父节点的索引为 i，则左子节点的索引为 i + 1。
        而在计算机编程中，数组的索引从 0 开始，
        因此左子节点的索引实际上是父节点索引乘以 2 加上 1，即 2 * i + 1。
    **/
    fn left(&self, i: usize) -> usize {
        2 * i + 1
    }

    /**
        与左子节点类似，每个父节点的右子节点总是在其索引的下两个位置。
        例如，父节点的索引为 i，则右子节点的索引为 i + 2。
        同样地，为了得到正确的索引，我们需要将父节点的索引乘以 2，然后再加上 2，即 2 * i + 2。
    **/
    fn right(&self, i: usize) -> usize {
        2 * i + 2
    }

    /**
        如果我们有一个子节点的索引 i，我们希望找到它的父节点的索引。
        观察一下，可以发现这样的关系：
            如果将子节点的索引除以 2（整数除法），然后向下取整，就可以得到父节点的索引。
            这是因为在完全二叉树中，每个父节点的左子节点和右子节点都是连续的，索引之间相差为 1 或 2，
            因此反推回去时需要除以 2。
    **/
    fn parent(&self, i: usize) -> usize {
        if i == 0 {
            return 0;
        }

        (i - 1) / 2
    }

    /// 插入
    fn push(&mut self, value: R);

    /// 删除, 如果删除的是最大堆，删除并返回的就是最大元素；如果删除的是最小堆，删除并返回的就是最小元素。
    fn delete(&mut self) -> Option<R>;

    /// 修改指定的值
    fn update(&mut self, index: usize, value: R);

    /// 排序
    fn sort(&mut self);

    /// 下沉, 删除用
    fn sink(&mut self, size: usize, index: usize);

    /// 上浮, 添加用
    fn swim(&mut self, index: usize) -> bool;
}

/// 定义最小堆
#[derive(Debug)]
pub struct Heap<T> {
    data: Vec<T>,
}

impl<T> Heap<T> {
    /// 创建一个新的空堆
    pub fn new() -> Self {
        Self { data: Vec::new() }
    }
}

impl<T: PartialOrd> BinaryHeap<T> for Heap<T> {
    /// 插入, 上浮
    fn push(&mut self, value: T) {
        self.data.push(value);
        self.swim(self.data.len() - 1);
    }

    /// 删除, 下沉, 删除堆顶元素并返回其值
    fn delete(&mut self) -> Option<T> {
        if self.data.is_empty() {
            return None;
        }

        let last_index = self.data.len() - 1;
        self.data.swap(0, last_index);

        // 删除交换后的第一个元素
        let result = self.data.pop();
        self.sink(self.data.len(), 0);
        result
    }

    /// 修改堆中指定位置的元素值
    fn update(&mut self, index: usize, value: T) {
        if index >= self.data.len() {
            return;
        }

        self.data[index] = value;
        if !self.swim(index) {
            self.sink(self.data.len(), index); // 如果上浮没用, 就下沉
        }
    }

    /// 排序
    fn sort(&mut self) {
        let mut size = self.data.iter().clone().len();

        // 构建初始堆, 将输入数组转换成一个大顶堆(每个父节点的值都大于等于其子节点的值), 只有当数组成为大顶堆后，我们才能通过堆顶的值（即根节点）获得当前未排序部分的最大值
        // 为什么从 heap_size / 2 开始?
        // 1. 因为二叉堆的叶子节点本身已经满足堆的性质（没有子节点需要比较）。
        // 2. 从最后一个非叶子节点（索引为 heap_size / 2 - 1）开始调整堆，确保整个堆满足大顶堆的性质。
        // 第一次调整后，数组整体会变成一个大顶堆, 此操作的复杂度是 O(n), 因为需要调整每个节点，但每次调整的深度是对数级递减的。
        // ps: 在数组表示的完全二叉堆中，叶子节点不需要进行下沉，因为它们已经满足堆的性质。非叶子节点（即从最后一个非叶子节点开始到根节点）才需要进行下沉操作
        // rev() 使得循环 从最后一个非叶子节点向上遍历，这样就能先调整子树，再调整父节点
        for i in (0..size / 2).rev() {
            // 或直接使用上浮, 不需要反转数组
            self.sink(size, i);
        }

        // 堆排序: 交换堆顶与末尾元素
        for i in (1..size).rev() {
            // 或直接使用上浮, 不需要反转数组
            self.data.swap(0, i);
            size -= 1;
            self.sink(size, 0)
        }
    }

    /// 上浮, 添加用
    fn swim(&mut self, mut index: usize) -> bool {
        let mut moved: bool = false;
        while index > 0 && index <= self.data.len() - 1 {
            let parent_index = self.parent(index);
            if self.data[index] <= self.data[parent_index] {
                break;
            }

            self.data.swap(index, parent_index);
            index = parent_index;
            moved = true;
        }

        moved
    }

    /// 下沉, 删除用
    fn sink(&mut self, size: usize, mut index: usize) {
        while index <= size - 1 {
            let left_child_index = self.left(index);
            let right_child_index = self.right(index);

            let mut max_index = index;
            if left_child_index < size && self.data[left_child_index] > self.data[max_index] {
                max_index = left_child_index
            }

            if right_child_index < size && self.data[right_child_index] > self.data[max_index] {
                max_index = right_child_index
            }

            if max_index == index {
                break;
            }

            self.data.swap(max_index, index);
            index = max_index;
        }
    }
}
