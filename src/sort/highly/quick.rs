/*!
  快速排序(Quick Sort): 分治算法的一种
   1. 思想: 选择一个基准元素，将数组分成小于基准和大于基准的两部分，递归排序
   2. 时间复杂度:
      - 最优: O(n log n)
      - 最差：O(n2)(基准选择不好时)
      - 平均: O(n log n)
   3. 空间复杂度: O(log n) (递归栈空间)
   4. 特点: 实现复杂，但一般是最快的排序算法

   步骤:
    1. 选取基准(Pivot)
       - 选择数组的第一个元素、最后一个元素、中间元素，或者随机选择一个元素作为基准
       - 将基准移到数组末尾
    2. 分区(Partition)
      - 定义边界指针, 表示 `当前小于基准的部分的右边界, 下一个小于基准的元素应该放置的位置`
      - 遍历数组中的每个元素(除最后的基准)，与基准比较
      - 基准回到正确位置
      此时分区完成:
       - 左边部分：所有小于基准的元素；
       - 右边部分：所有大于或等于基准的元素； 基准的位置最终被确定。
    3. 递归排序
       - 对基准两侧的子数组递归地进行快速排序，直到子数组长度为1或0
    4. 合并结果
       - 快速排序本身不需要显式的合并，因为分区已经使数组有序
*/

use rand::Rng;

/*
   如: [9, 3, 7, 5, 6, 4, 8, 2]
   1. 选取基准(Pivot)
      - 基准索引(随机选取): `3`, 基准值: `5`
      - 将基准移到数组末尾:
        - 把 `arr[3]` 和 `arr[7]` 交换
        - [9, 3, 7, 2, 6, 4, 8, 5]
   2. 分区(Partition)
      - 定义边界指针 `i = 0`, 表示 `当前小于基准的部分的右边界, 下一个小于基准的元素应该放置的位置`
      - 遍历数组中的每个元素(除最后的基准)，与基准比较
        - 索引 j = 0, 值: arr[j] = 9, arr[j]和基准比较: 9 < 5 -> false, 不交换, 最终数组为: [9, 3, 7, 2, 6, 4, 8, 5], i = 0
        - 索引 j = 1, 值: arr[j] = 3, arr[j]和基准比较: 3 < 5 -> true, 需要交换(交换 i = 0 和 j = 1 位置), 最终数组为: [3, 9, 7, 2, 6, 4, 8, 5], i = 1(加一位)
        - 索引 j = 2, 值: arr[j] = 7, arr[j]和基准比较: 7 < 5 -> false, 不交换, 最终数组为: [3, 9, 7, 2, 6, 4, 8, 5], i = 1
        - 索引 j = 3, 值: arr[j] = 2, arr[j]和基准比较: 2 < 5 -> true, 需要交换(交换 i = 1 和 j = 3 位置), 最终数组为: [3, 2, 7, 9, 6, 4, 8, 5], i = 2(加一位)
        - 索引 j = 4, 值: arr[j] = 6, arr[j]和基准比较: 6 < 5 -> false, 不交换, 最终数组为: [3, 2, 7, 9, 6, 4, 8, 5], i = 2
        - 索引 j = 5, 值: arr[j] = 4, arr[j]和基准比较: 4 < 5 -> true, 需要交换(交换 i = 2 和 j = 5 位置), 最终数组为: [3, 2, 4, 9, 6, 7, 8, 5], i = 3(加一位)
        - 索引 j = 6, 值: arr[j] = 8, arr[j]和基准比较: 8 < 5 -> false, 不交换, 最终数组为: [3, 2, 4, 9, 6, 7, 8, 5], i = 3
      - 基准回到正确位置
        - 最后将基准值 `5`(索引为 3) 与 arr[i] 交换
      此时，基准值 `5` 的位置是 `3`，分区完成，数组分为两部分:
        - 左侧部分(小于基准)：[3, 2, 4]
        - 基准位置：5
        - 右侧部分(大于基准)：[6, 7, 8, 9]
   3. 递归排序
      - 对左侧 [3, 2, 4] 排序
        - 选取基准
          - 基准索引(随机选取): `1`, 基准值: `2`
          - 将基准移到数组末尾:
            - 把 `arr[1]` 和 `arr[2]` 交换
            - [3, 4, 2]
        - 分区
          - 定义 `i` = 0
          - 遍历数组中的每个元素(除最后的基准)，与基准比较
            - 索引 j = 0, 值: arr[j] = 3, arr[j]和基准比较: 3 < 2 -> false, 不交换, 最终数组为: [3, 4, 2], i = 0
            - 索引 j = 1, 值: arr[j] = 4, arr[j]和基准比较: 4 < 2 -> false, 不交换, 最终数组为: [3, 4, 2], i = 0
          - 基准回到正确位置
            - 最后将基准值 `2`(索引为 1) 与 arr[i] 交换
            .....
        - 排序完成左侧部分：[2, 3, 4]
      - 对右侧 [6, 7, 8, 9] 调用 quick_sort
        ...
        - 排序完成右侧部分：[6, 7, 8, 9]
     4. 合并结果
        通过递归合并，最终排序完成: [2, 3, 4, 5, 6, 7, 8, 9]
*/
pub fn quick_sort<T: Ord>(arr: &mut [T]) {
    let n = arr.len();
    if n == 0 || n == 1 {
        return;
    }

    let index = partition(arr);
    quick_sort(&mut arr[..index]);
    quick_sort(&mut arr[(index + 1)..]);
}

/// 确定基准
fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let n = arr.len();
    let index = rand::thread_rng().gen_range(0..arr.len()); // n / 2

    // 将基准移到数组末尾
    arr.swap(index, n - 1);

    // 当前小于基准的部分的边界， 下一个小于基准的元素应该放置的位置
    let mut i = 0;

    for j in 0..n - 1 {
        if arr[j] < arr[n - 1] {
            arr.swap(i, j);
            i += 1;
        }
    }

    // 将基准移到正确的位置
    arr.swap(i, n - 1);
    i
}
