/*!
  快速排序(Quick Sort): 分治算法的一种
   1. 思想: 选择一个基准元素，将数组分成小于基准和大于基准的两部分，递归排序
   2. 时间复杂度:
      - 最优: O(n log n)
      - 最差：O(n2)(基准选择不好时)
      - 平均: O(n log n)
   3. 空间复杂度: O(log n) (递归栈空间)
   4. 特点: 实现复杂，但一般是最快的排序算法

   步骤:
    1. 选取基准(Pivot):
       通常可以选择数组的第一个元素、最后一个元素、中间元素，或者随机选择一个元素作为基准
    2. 分区(Partition):
      - 使用双指针法或单指针法重新排列数组，使得:
        - 左侧部分所有元素 < 基准
        - 右侧部分所有元素 ≥ 基准
      - 确定基准的最终位置
    3. 递归排序: 对基准两侧的子数组递归地进行快速排序，直到子数组长度为1或0
    4. 快速排序本身不需要显式的合并，因为分区已经使数组有序
*/

use rand::Rng;

/*
   如: [9, 3, 7, 5, 6, 4, 8, 2]
   1. 第一次调用 `partition`
      - 基准（随机选取）为 `5`
      - 分区后，数组变为 [3, 2, 4, 5, 6, 7, 8, 9]
        - 基准 `5` 在正确位置（索引 `3`）
        - 左侧子数组 [3, 2, 4]，右侧子数组 [6, 7, 8, 9] 仍然无序
   2. 递归处理子数组
      - 对左侧 [3, 2, 4] 调用 quick_sort
        - 基准为 `2`
        - 分区后，左侧子数组变为 [2, 3, 4]，基准位置确定为 `1`
        - 左侧 [2] 和右侧 [3, 4] 继续递归
      - 对右侧 [6, 7, 8, 9] 调用 quick_sort
        - 基准为 `8`
        - 分区后，右侧子数组变为 [6, 7, 8, 9]，基准位置确定为 `2`
        - 左侧 [6, 7] 和右侧 [9] 继续递归
*/
pub fn quick_sort<T: Ord>(arr: &mut [T]) {
    let n = arr.len();
    if n == 0 || n == 1 {
        return;
    }

    let index = partition(arr, n);
    quick_sort(&mut arr[0..index]);
    quick_sort(&mut arr[(index + 1)..]);
}

/// 确定基准
fn partition<T: Ord>(arr: &mut [T], n: usize) -> usize {
    let index = rand::thread_rng().gen_range(0..arr.len()); // n / 2

    // 将基准移到数组末尾
    arr.swap(index, n - 1);

    // 当前小于基准的部分的边界， 下一个小于基准的元素应该放置的位置
    let mut i = 0;

    for j in 0..n - 1 {
        if arr[j] < arr[n - 1] {
            arr.swap(i, j);
            i += 1;
        }
    }

    // 将基准移到正确的位置
    arr.swap(i, n - 1);
    i
}
