# 第二阶段 · 第 1 课
  **BFS/DFS 的第一个应用: 找路径 & 最短路(入门)**
  
  先**只做一件事**:
  > 👉 从一个点，走到另一个点

  ---

## DFS 和 BFS
1. DFS(深度优先搜索) —— “一条路走到黑，再回头”
  
   **核心思想**:
   > **先一路往深处走，走不动了再回退**

   像走迷宫: **先选一条路一直走到底**。

   👉 数据结构：递归/栈(Stack)
  
   **伪代码**:
   ```
    dfs(cur):
    visited.add(cur)
    访问 cur
        for 每个 cur 的邻居 next:
            if next 没访问过:
                dfs(next)
   ```
---

   **经典用途**:
   - 判断是否有环
   - 连通分量
   - 拓扑排序
   - 回溯 / 搜索所有方案

---

   **举例**:
   
   假设: **邻居访问顺序是从左到右**

   用 `邻接表` 表示图
   ```
    0: [1, 2]
    1: [0, 3, 4]
    2: [0, 5]
    3: [1]
    4: [1]
    5: [2]
   ```

   画成图:
   ```
     3
     |
     1 —— 4
    /
   0 —— 2 —— 5
   ```

   **dfs(0)**
   ```
   访问 0
   → 走向 1
   ```

   **dfs(1)**
   ```
   访问 1
   0 已访问
   → 走向 3
   ```

   **dfs(3)**
   ```
   访问 3
   没有新邻居
   ← 回到 1
   ```

   **回到 dfs(1)**
   ```
   → 走向 4
   ```

   **dfs(4)**
   ```
   访问 4
   没有新邻居
   ← 回到 1
   ← 回到 0
   ```

   **回到 dfs(0)**
   ```
   → 走向 2
   ```

   **dfs(2)**
   ```
   访问 2
   0 已访问
   → 走向 5
   ```

   **dfs(5)**
   ```
   访问 5
   结束
   ```

---
  
   **DFS 访问顺序**
   ```
   0 → 1 → 3 → 4 → 2 → 5
   ```

   ⚠️ DFS 顺序不是唯一的，和邻接表顺序有关

---

2. BFS(广度优先搜索) —— “一圈一圈向外扩散”

   **核心思想**:
   > **(先访问离起点最近的点，再访问更远的点**

   就像往水里丢一块石头，**波纹一圈一圈扩散**。

   👉 数据结构: **队列(Queue)**

   **伪代码**:
   ```
   queue = []
   visited = set()
    
   queue.push(起点)
   visited.add(起点)
    
   while queue 不为空:
        cur = queue.pop_front()
        访问 cur

        for 每个 cur 的邻居 next:
            if next 没访问过:
                visited.add(next)
                queue.push(next)
   ```
   
---

   **典型用途**:
   - 最短路径(无权图)
   - 按层遍历
   - 判断连通性
   - 拓扑层级

---
   
   **举例**:
   
   用 `邻接表` 表示图
   ```
    0: [1, 2]
    1: [0, 3, 4]
    2: [0, 5]
    3: [1]
    4: [1]
    5: [2]
   ```
   
   画成图:
   ```
     3
     |
     1 —— 4
    /
   0 —— 2 —— 5
   ```

    - 初始化
       queue = [0]
       visited = {0}

    - 步骤
      - 弹出 0
      ```markdown
       访问：0
       0 的邻居: 1, 2
      
       queue = [1, 2]
       visited = {0, 1, 2}
      ```
      
      - 弹出 1
      ```markdown
      访问: 1
      1 的邻居: 0, 3, 4
      0 已访问, 跳过
      
      queue = [2, 3, 4]
      visited = {0, 1, 2, 3, 4}
      ```
      
      - 弹出 2
      ```markdown
      访问: 2
      2 的邻居: 0, 5
      0 已访问
      
      queue = [3, 4, 5]
      visited = {0, 1, 2, 3, 4, 5}
      ```
      
      - 后续
        - 访问 3 → 无新点
        - 访问 4 → 无新点
        - 访问 5 → 无新点

   - BFS 访问顺序
   ```
   0 → 1 → 2 → 3 → 4 → 5
   ```

---

3. BFS vs DFS 直观对比

   | 对比点    | BFS    | DFS    |
   | ------ | ------ | ------ |
   | 搜索方式   | 一层一层   | 一条路到底  |
   | 数据结构   | 队列     | 栈 / 递归 |
   | 是否最短路  | ✅（无权图） | ❌      |
   | 是否容易爆栈 | ❌      | ⚠️ 深度大 |
   | 常见应用   | 最短路径   | 回溯、找环  |

---

6. **不管 BFS 还是 DFS，一定要有 visited**

---
  
## 什么叫「找路径」?
   一句话:
   > **是否存在一条路, 从起点 s  走到 终点 t**
   
   举例:
   ```
   0 —— 1 —— 3
   |
   2
   ```
   问题:
   - 从 `0` 能不到到 `3`?
   - 从 `2` 能不能到 `3`?

   --- 

## 用 DFS 找路径
   **核心思想**
   > DFS 本身就在 “尝所有可能的路”
   
   所以:
   - DFS 到 `t` → 有路径
   - DFS 到不了 `t` → 没路径

   ---

   **思考过程**:
   1. 从 `s` 出发 DFS
   2. 过程中:
      - 一旦遇到 `t` → 成功
   3. DFS 结束还没遇到 `t` → 不存在路径
   📌 visited 仍然必须有
  
   ---

## DFS 能找到路径, 但有问题
   DFS 的问题是:
   > ❗找到的路径不一定最短

   ---

   **例子**:
   ```
   0 —— 1 —— 2 —— 3
   \___________/
   ```
   - DFS 可能先走长路
   - 明明 `0 → 3` 一步就到

   👉 所以:
   - **DFS = 能不能到**
   - **不是 = 最短**

   ---

## BFS: 天然的最短路算法(无权图)
   一个**非常重要的结论**:
   > 🔥 在无权图中，BFS 找到的一定是最短路径

   ---

   为什么?

   BFS 是:
   - 先走 1 步能到的
   - 再走 2 步能到的
   - 再走 3 步能到的

   所以: 
   > 第一次到过终点为时, 用的步数一定最少

   ---

## 一步步跑 BFS
   图:
   ```
   0 —— 1 —— 3
   |
   2
   ```
   起点: `0`
   终点: `3`

   ---

   **BFS 过程**:

   **第 0 层**:
   - 队列: `[0]`
   - 距离: `dist[0] = 0`

   **第 1 层**:
   - 访问 0:
   - 入队: 1, 2
   - `dist[1] = 1`
   - `dist[2] = 1`

   **第 2 层**:
   - 访问 1:
   - 入队: 3
   - `dist[3] = 2` ← 第一次到达终点
   📌 最短路径长度 = 2
   
   ---

## 想知道「路径本身」怎么办?
   除了 `dist`, 多记一个东西:
   >**prev(前驱节点)**
   
   ---

   **含义**:
   ```
   prev[v] = 是从哪个点走到 v 的
   ```

   **BFS时做的一件小事**:
   - 当从 `u` 走到 `v`:
   ```
   prev[v] = u
   ```

   ---

   **到终点后，倒着还原路径**:
   ```
   3 ← 1 ← 0
   ```

   反过来就是:
   ```
   0 → 1 → 3
   ```

   ---

## 牢牢记住的 4 条结论
   这是**图算法的地基**:
   1. DFS
      - 能不能到
      - 找一条路
      - 不保证最短
   2. BFS
      - 无权图最短
      - 层序扩展
      - 第一次到达即最优
   3. **visited 必须有**
   4. **最短路 = BFS + dist + prev**

# 第二阶段 · 第 2 课
  **多源 BFS & 网格图(迷宫 / 岛屿模型)**
  
  发现:
  > 🔥 80% 的 BFS 题，本质都是这一课

  ---

## 先统一一个「图的视角」
   在算法题里, 图不一长这样:
   ```
   0 —— 1 —— 2
   ```

   它可能长这样(二维网格):
   ```
   1 0 1
   0 0 1
   1 0 0
   ```
   📌 网格 = 图

---

## 如何把「网格」看成「图」?
   **核心规则**
   - **每个格子 = 一个点**
   - **上下左右 = 边**
   - 不能走的格子 = 没有点 / 没有边

---

   **举例(上下左右)**

   对格子(i, j):
   - (i - 1, j)
   - (i + 1, j)
   - (i, j - 1)
   - (i, j + 1)

---

## 什么是 「多源 BFS」?
  > **一个起点 → BFS**
 
  升级为:
  > **多个起点 → 同时 BFS**

---

  **核心思想一句话:**
  > **把所有起点一次性丢进队列**

---

  **为什么要这么做?**

  因为:
    - BFS 是按“层”扩散的
    - 多个起点一起扩散
    - 谁先到，谁就是最近的

---

## 经典例子 1: 最近 0(距离问题)
   网格:
   ```
   0 0 0
   0 1 0
   1 1 1
   
   (0,0) (0,1) (0,2)
   (1,0) (1,1) (1,2)
   (2,0) (2,1) (2,2)
   ```

   值为 `0` 的位置:
   ```
   (0,0) (0,1) (0,2)
   (1,0)       (1,2)
   ```
  
   问题:
   > 对每个 `1`，求到最近 `0` 的距离

---
   
   **多源 BFS**
   - 把 **所有 0**加入队列
   - 它们的距离 = 0
   - 一起 BFS 扩散
   - 第一次到达某个 1 → 最近距离

---

   **步骤**

   初始队列:
   ```
   (0, 0), (0, 1), (0, 2), (1, 0), (1, 2)
   ```
   它们全是 `0`

---

   **第一层扩散**
   
   **第一层扩散 = 从“初始队列里的所有点”, 各走一步**

   走一步的规则是:
   ```
   只能向 上 / 下 / 左 / 右
   不能越界
   不能访问已经访问过的格子
   ```
 
   ```markdown
   1. 从 (0,0) 出发
   相邻位置:
   - 上: (-1, 0) ❌越界
   - 下: (1, 0) ✅但它本来就在初始队列（已访问）
   - 左: (0,-1) ❌越界
   - 右: (0,1) ✅但已访问
   ➡️ 没有新点
  
   2. 从 (0,1) 出发
   相邻位置:
   - 上: (-1,1) ❌越界
   - 下: (1,1) ✅ 这是 1，且没访问过
   - 左: (0,0) ✅ 已访问
   - 右: (0,2) ✅ 已访问
   ➡️ 新增: (1,1)

   3. 从 (0,2) 出发
   相邻位置:
   - 上: (-1,2) ❌越界
   - 下: (1,2) ✅ 已访问
   - 左: (0,1) ✅ 已访问
   - 右: (0,3) ❌越界
   ➡️ 没有新点

   4. 从 (1,0) 出发
   相邻位置:
   - 上: (0,0) ✅ 已访问
   - 下: (2,0) ✅ 新点
   - 左: (1,-1) ❌越界
   - 右: (1,1) ✅ 但刚刚已经加入了
   ➡️ 新增: (2,0)

   5. 从 (1,2) 出发
   相邻位置:
   - 上: (0,2) ✅ 已访问
   - 下: (2,2) ✅ 新点
   - 左: (1,1) ✅ 已加入
   - 右: (1,3) ❌越界
   ➡️ 新增: (2,2)
   ```

---

   最终:
   - 到 `(1,1)`、`(2,0)`、`(2,1)`、`(2,2)`
   - 这些 `1` 第一次被访问
   - 距离 = 1

---

   📌 一次 BFS，解决所有点的最短距离

---

## 经典例子 2: 岛屿数量(连通性)
   ```
   1 1 0 0
   1 1 0 1
   0 0 1 1
   
   (0,0) (0,1) (0,2) (0,3)
   (1,0) (1,1) (1,2) (1,3)
   (2,0) (2,1) (2,2) (2,3)
   ```

   规则:
   - `1` = 陆地
   - `0` = 水
   - **上下左右连通**

---

   问题:
   > 有多少个岛?

---

   **思路**
   > **每次遇到一个没访问过的 1，岛屿数量 +1**
   > **然后用 DFS/BFS 把与它连通的所有 1 全部标记掉**

---

   **步骤**

   **看到一个没访问过的 1，就发现一个新岛**

   第一次遇到陆地: `(0,0)`
   ```
   (0,0) = 1，且没访问过
   → 发现第 1 个岛
   ```

   从 `(0,0)` 开始, 用 DFS/BFS 把**整个连通块**找出来

   **连通扩展**:
   - (0,0) 连到 (0,1)
   - (0,0) 连到 (1,0)
   - (0,1) 连到 (1,1)

   一整块:
   ```
   (0,0) (0,1)
   (1,0) (1,1)
   ```

   ➡️ 这是一个完整的岛

---

   **继续扫描**
   - (0,1) 已访问 → 跳过
   - (0,2) = 0 → 水
   - (0,3) = 0 → 水
   - (1,0) 已访问
   - (1,1) 已访问
   - (1,2) = 0 → 水
   
   **遇到 (1,3) = 1**
   ```
   (1,3) = 1，没访问过
   → 发现第 2 个岛
   ```

   从 `(1,3)` 扩展:
   - 下: (2,3) = 1
   - 左: (1,2) = 0
   - 上: (0,3) = 0

   再从 `(2, 3)`:
   - 左: (2,2) = 1

   形成连通块:
   ```
   (1,3)
   (2,2) (2,3)
   ```

   ➡️ 这是第二个岛

---

   **剩余位置**
   - (2,0) = 0
   - (2,1) = 0
   - (2,2) 已访问
   - (2,3) 已访问

---

   最终:
   🏝️ 岛屿数量 = 2 个



