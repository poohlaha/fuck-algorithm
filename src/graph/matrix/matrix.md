# 矩阵(Matrix)
  矩阵(Matrix) 是一个 `按照长方形排列的`、由`数字(或符号)`组成的 `二维数组`

1. 特性
  - 矩阵的大小用 `行 × 列` 表示, 称为矩阵的 `维度`
  ```text
   A =  | 1  2  3 |
        | 4  5  6 |
   
   表示 `A` 是一个 `2 × 3` 的矩阵
   用 A[i][j] 表示矩阵中第 i 行第 j 列的元素(下标从 1 或 0 开始, 看语言环境)
   ```

  - 概念
    - 行(Row): 横向的一排元素
    - 列(Column): 纵向的一列元素
    - 维度: 行 * 列
    - 方阵: 行数 = 列数的矩阵(如 3 × 3、4 × 4)
    - 零矩阵: 所有元素都 `0` 的矩阵
    - 单位矩阵: 对角线是 `1`, 其余是 `0` 的方阵
    - 转置矩阵: 把矩阵的行变成列(即 `A[i][j]` -> `A[j][i]`)

2. 时间复杂度
   - 加减法
     - O(m×n)
     - 逐元素操作，每个元素操作一次
   - 乘法
     - O(m×n×p)（常见情况）
     - A(m×n) × B(n×p)，三层循环
   - 特别算法
     - O(n^2.81) ~ O(n^2)
     - 使用 Strassen 等高级算法能加快乘法
   - 逆矩阵
     - O(n³)
     - 需要高斯消元等操作

3. 使用场景
   - 图论
     - 邻接矩阵表示图结构(判断是否有边)
   - 线性代数
     - 解线性方程组，计算特征值，向量空间等
   - 计算机图形学
     - 用矩阵表示图形变换，如旋转、缩放、平移
   - 机器学习/AI
     - 神经网络中的输入、权重、激活都是矩阵
   - 物理/工程建模
     - 用矩阵描述状态变化、系统方程，如电路、力学系统
   - 图像处理
     - 图像本质上是像素矩阵，处理如滤波、变换时都是矩阵操作

4. 举例
   - 加法
     - 两矩阵维度相同
     - 对应位置的元素 `逐一相加`
   ```text
   前提: 矩阵 A 和 B 维度必须相同，如都是 2×3
   A = | 1 2 3 |      B = | 7 8 9 |
       | 4 5 6 |          | 1 2 3 |

   A + B = | 1+7  2+8  3+9 | = | 8 10 12 |
           | 4+1  5+2  6+3 |   | 5  7  9 |
   ```
   
   - 减法
     - 两矩阵维度相同
     - 对应位置的元素 `逐一相减`
   ```text
   前提: 矩阵 A 和 B 维度必须相同，如都是 2×3
   A = | 1 2 3 |      B = | 7 8 9 |
       | 4 5 6 |          | 1 2 3 |

   A - B = | 1-7  2-8  3-9 | = | -6 -6 -6 |
           | 4-1  5-2  6-3 |   | 3  3  3 |
   ```
   
   - 乘法
     - `A` 的 `列数` == `B` 的 `行数`
     - `A` 第 `i` 行 与 `B` 第 `j` 列的 `点积`
     - 乘法 = 行向量 × 列向量
   ```text
   前提: `A` 的 `列数` == `B` 的 `行数`
   A = 2x3        B = 3x2        A × B = 2x2

   A = | 1 2 3 |     B = | 7  8 |
       | 4 5 6 |         | 9 10 |
                         |11 12 |
   第 [i][j] 个元素，表示 `A` 第 `i` 行 与 `B` 第 `j` 列的 `点积`(内积):
   A × B = | (1 * 7 + 2 * 9 + 3 * 11) (1* 8 + 2 * 10 + 3 * 12)   |
           | (4 * 7 + 5 * 9 + 6 * 11) (4 * 8 + 5 * 10 + 6 * 12)  |
         = |  58    64 |
           |  139  154 |
   这个操作是最常见的，也是神经网络中最核心的运算之一
   ```

    - 转置
      - 将行列互换
    
    ```text
      A = | 1 2 |
          | 3 4 |
          | 5 6 |
   
      Aᵀ = | 1 3 5 |
           | 2 4 6 | 
    ```
   
- 逆矩阵(Inverse Matrix)
  其本质: 相当于 `矩阵除法`
  ```text
  如果有一个矩阵 `A`, 存在另一个矩阵 `B(也可以是同一个矩阵 `A`)`, 使得:
  A × B = B × A = I
  
  那么, 称 `B` 是 `A` 的逆矩阵, 记作:
  A⁻¹
  
  A⁻¹ * A = I
  
  `I` 是 `单位矩阵(对角线是 1，其余是 0 的方阵)`
  ```
  
  - 满足条件
    - `A` 是 `方阵`
    - `A` 的行或列不能线性相关(即 `秩 = n`)
    - 行列式 `det(A) ≠ 0`(`det(A) = 0` 叫 `奇异矩阵`)
  ```text
   A = | a b |
       | c d |
  
  满足行列式 `det(A) ≠ 0`: det(A) = a * d - b * c ≠ 0
  那么逆矩阵:
  A⁻¹ = (1 / (ad - bc)) × |  d -b |
                          | -c  a |  
  
  口诀: `对角换位, 副对角变负, 除以行列式`
  
  如何记:
   1. 主对角线(a 和 d)交换，副对角线(b 和 c)反号
   | a b |  (主对角线交换)-> | d b |  (副对角线反号)-> | d -b |
   | c d |                 | c a |                 | -c a |
  
   2. 求 det(A) = a * d - b * c
   
   3. 最后: 除以 `行列式`
   | d -b |  ÷ det(A)
   | -c a |   
   -> (1 / (ad - bc)) × |  d -b |
                        | -c  a |  
  ```
  
  - 高斯约旦消元
    - `行变换`，把左边的 `A` 变成单位矩阵 `I`
    - 让右边的 `I` 被变换成 `A⁻¹`
      - [ I | A⁻¹ ]
  
  - 举例(2 × 2)
  ```text
   A = | 2 1 |
       | 5 3 |
  
   I = | 1 0 |
       | 0 1 |
  
   A 的行列式: 2 * 3 - 1 * 5 = 1
  
   A × A⁻¹ = I
   推导过程(使用高斯约旦消元法):
   1. 构建增广矩阵 | A | I |
   [ 2 1 | 1 0 ]
   [ 5 3 | 0 1 ]
  
  2. 消元
    使用 `第1行第1列` 消去 `第2行第1列`
    - 第1行第1列元素: 2(非 1)
    - 归一: R1 <- 1/2 R1
    - 第1行: [ 1 0.5 | 0.5 0 ]
  
  2.1 消除 `第2行第1列`
    R2 <- R2 - (a21 / a11 = 5) * R1
       -> [ 5 3 | 0 1 ] - 5 * [ 1 0.5 | 0.5 0 ]
       -> [ 5 3 | 0 1 ] - [ 5 2.5 | 2.5 0]
       -> [ 0 0.5 | -2.5 1 ]
  
  2.2 使用 `第2行第2列` 消除 `第1行第2列`
      R1 <- R1 - (a12 / a22 = 1) * R2
         -> [ 1 0.5 | 0.5 0 ] - 1 * [ 0 0.5 | -2.5 1 ]
         -> [ 1 0.5 | 0.5 0 ] - [ 0 0.5 | -2.5 1 ]
         -> [ 1 0 | 3 -1 ]
  
  得到矩阵:
   [ 1   0 |    3 -1 ]
   [ 0 0.5 | -2.5  1 ] <- 未归一
  
  归一后得到矩阵:
   [ 1 0 |  3 -1 ]
   [ 0 1 | -5  2 ]
  
  所以得到 A⁻¹ = |  3  -1 |
                | -5   2 |
  
  使用公式:
   A⁻¹ = (1 / ( 2 * 3 - 1 * 5)) * |  3 -1 |
                                  | -5  2 |
       = |  3  -1 |
         | -5   2 |
  ```
  
  - 举例(3 × 3)
  ```text
   A⁻¹ = (1 / det(A) × adj(A)
   - det(A): A 的行列式
   - adj(A): A 的伴随矩阵(adjugate matrix)
  
  步骤:
  1. 求行列式 `det(A)`
  2. 求伴随矩阵 `adj(A)`
  3. A⁻¹ = (1 / det(A)) × adj(A)

  伴随矩阵 `adj(A)`:
   伴随矩阵 = 所有元素的 `代数余子式矩阵` 的 `转置`
   代数余子式(可以参考行列式里的计算): 
    - 去掉第 i 行和第 j 列后，剩下 2×2 矩阵的行列式
    - 加上符号: (–1)^(i+j)
    - 符号排列
      | +  -  + |
      | -  +  - |
      | +  -  + |

  例:
  A = | 1 2 3 |
      | 0 1 4 |
      | 5 6 0 |
  
  1. 求 det(A):
     det(A) = 1 * (1 * 0 - 4 * 6) - 2 * (0 * 0 - 4 * 5) + 3 * (0 * 6 - 1 * 5)
            = 1 * (0 - 24) - 2 * (0 - 20) + 3 * (0 - 5)
            = -24 - 2 * (-20) + 3 * (-5)
            = -24 + 40 - 15
            = 1
  
  2. 求伴随矩阵 `adj(A)`
  2.1 代数余子式矩阵: 
     | +(1 * 0 - 4 * 6) -(0 * 0 - 4 * 5) +(0 * 6 - 1 * 5) |
     | -(2 * 0 - 3 * 6) +(1 * 0 - 3 * 5) -(1 * 6 - 2 * 5) |
     | +(2 * 4 - 3 * 1) -(1 * 4 - 3 * 0) +(1 * 1 - 2 * 0) |
  
  -> |  (0 - 24) -(0 - 20) (0 -  5) |
     | -(0 - 18) (0 - 15) -(6 - 10) |
     |  (8 -  3) -(4 -  0) (1 -  0) |
  
  -> | -24  20 -5 |
     |  18 -15  4 |
     |   5  -4  1 |
  
  2.2 转置(将行列互换)
     | -24   18   5 |
     |  20  -15  -4 |
     |  -5   4    1 |
  
  2.3 adj(A)
     adj(A) = | -24   18   5 |
              |  20  -15  -4 |
              |  -5   4    1 |
     
  3.  A⁻¹ = (1 / det(A)) × adj(A)
   A⁻¹ = | -24   18   5 |
         |  20  -15  -4 |
         |  -5    4   1 |
  
  推导(使用高斯约旦消元):
  A = | 1 2 3 |
      | 0 1 4 |
      | 5 6 0 |
  
  I: 单位矩阵, 主对角线是 1，其余全是 0
  I = | 1 0 0 |
      | 0 1 0 |
      | 0 0 1 |
  
  1. 增广矩阵
    [ 1 2 3 | 1 0 0 ]
    [ 0 1 4 | 0 1 0 ]
    [ 5 6 0 | 0 0 1 ]
  
  1. 用 `第1行第1列`, 消除 `第2行第1列`、`第3行第1列`
  1.1 消除 `第2行第1列`
      `第2行第1列` 元素为 `0`: 无需消元
         
  1.2 消除 `第3行第1列`
      R3 <- R3 - (a31 / a11 = 5) * R1
         -> [ 5 6 0 | 0 0 1 ] - 5 * [ 1 2 3 | 1 0 0 ]
         -> [ 5 6 0 | 0 0 1 ] - [ 5 10 15 | 5 0 0 ]
         -> [ 0 -4 -15 | -5 0 1 ]
  
  现在矩阵:
  [  1  2   3 |  1 0 0 ]
  [  0  1   4 |  0 1 0 ]
  [  0 -4 -15 | -5 0 1 ]  
  
  2. 用 `第2行第2列`, 消除`第3行第2列`、`第1行第2列`
  
  2.1 消除`第3行第2列`
      R3 <- R3 - (a32 / a22 = -4) * R2
         -> [ 0 -4 -15 | -5 0 1 ] + 4 * [ 0 1 4 | 0 1 0 ]
         -> [ 0 -4 -15 | -5 0 1 ] + [ 0 4 -16 | 0 4 0 ]
         -> [ 0 0 1 | -5 4 1 ]
  
  2.2 消除`第1行第2列`
      R1 <- R1 - (a12 / a22 = 2) * R2
         -> [ 1 2 3 | 1 0 0 ] - 2 * [ 0 1 4 | 0 1 0 ]
         -> [ 1 2 3 | 1 0 0 ] - [ 0 2 8 | 0 2 0 ]
         -> [ 1 0 -5 | 1 -2 0 ]
  
  现在矩阵:
  [ 1 0 -5 |  1 -2 0 ]
  [ 0 1  4 |  0  1 0 ]
  [ 0 0  1 | -5  4 1 ]
  
  3. 接着消元
     使用 `第3行第3列`, 消除 `第1行第3列`、`第2行第3列`
     - 第3行第3列: 1
  3.1 消除 `第1行第3列`
     R1 <- R1 - (a13 / a33 = -5) * R3
        -> [ 1 0 -5 | 1 -2 0 ] + 5 * [ 0 0 1 | -5 4 1 ]
        -> [ 1 0 -5 | 1 -2 0 ] + [ 0 0 5 | -25 20 5 ]
        -> [ 1 0 0 | -24 18 5 ]
  
  3.2 消除 `第2行第3列`
      R2 <- R2 - (a23 / a33 = 4) * R3
         -> [ 0 1 4 | 0 1 0 ] - 4 * [ 0 0 1 | -5 4 1 ]
         -> [ 0 1 4 | 0 1 0 ] - [ 0 0 4 | -20 16 4 ]
         -> [ 0 1 0 | 20 -15 -4 ]
  
  矩阵: 
  [ 1 0 0 | -24  18  5 ]
  [ 0 1 0 |  20 -15 -4 ]
  [ 0 0 1 |  -5   4  1 ]
  
  A⁻¹ =  | -24   18   5 |
         |  20  -15  -4 |
         |  -5    4   1 |
  ```
  
  - 举例(线性方程组)
  ```text
    1x + 2y + 3z = 14
    0x +  y + 4z = 13
    5x + 6y + 0z = 17
  
  A = | 1 2 3 |  x = | x |   b = | 14 |
      | 0 1 4 |      | y |       | 13 |
      | 5 6 0 |      | z |       | 17 |
  
  求 A * x = b
    - A: 已知矩阵
    - b: 任意已知向量
    - x: 未知向量
  
    -> A * x = b
    -> A⁻¹ * A * x = A⁻¹ * b -- 必须左乘A⁻¹, 以保证乘法的顺序合法(矩阵乘法不满足交换律)
    -> (A⁻¹ * A) * x = A⁻¹ * b
    -> I * x = A⁻¹ * b  -- A⁻¹ * A = I
    -> x = A⁻¹ * b -- 单位矩阵乘任何向量不变
  
  1. 判断 A  是否是满足逆矩阵:
     det(A) = 1 * (1 * 0 - 4 * 6) - 2 * (0 * 0 - 4 * 5) + 3 * (0 * 6 - 1 * 5)
            = (0 - 24) - 2 * (0 - 20) + 3 * (0 - 5)
            = -24 + 40 - 15
            = 1
  
  2. 求伴随矩阵 `adj(A)`
  2.1 代数余子式矩阵: 
     | +(1 * 0 - 4 * 6) -(0 * 0 - 4 * 5) +(0 * 6 - 1 * 5) |
     | -(2 * 0 - 3 * 6) +(1 * 0 - 3 * 5) -(1 * 6 - 2 * 5) |
     | +(2 * 4 - 3 * 1) -(1 * 4 - 3 * 0) +(1 * 1 - 2 * 0) |
  
  -> | -24  20 -5 |
     |  18 -15  4 |
     |   5  -4  1 |
  
  -> |  (0 - 24) -(0 - 20) (0 -  5) |
     | -(0 - 18) (0 - 15) -(6 - 10) |
     |  (8 -  3) -(4 -  0) (1 -  0) |
  
  -> |  (0 - 24) -(0 - 20)  (0 -  5) |
     | -(0 - 18)  (0 - 15) -(6 - 10) |
     |  (8 -  3) -(4 -  0)  (1 -  0) | 
  
  -> | -24  20 -5 |
     |  18 -15  4 |
     |   5  -4  1 | 
  
  
  2.2 转置(将行列互换)
     | -24   18   5 |
     |  20  -15  -4 |
     |  -5    4   1 |
  
  adj(A) = | -24   18  5 |
           |  20  -15 -4 |
           |  -5    4  1 |
  
  3. 求 A 逆矩阵
     A⁻¹ = (1 / det(A)) * adj(A)
         = | -24   18  5 |
           |  20  -15 -4 |
           |  -5    4  1 |
  
   4. x = A⁻¹ * b
        = | -24  18  5 | * | 14 |
          |  20 -15 -4 |   | 13 |
          |  -5   4  1 |   | 17 |
        = | -24 * 14  18 * 13  5 * 17 |
          |  20 * 14 -15 * 13 -4 * 17 |
          |  -5 * 14   4 * 13  1 * 17 | 
        = | -336 +   234  +    85  |
          |  280 + (-195) +  (-68) |
          |  -70 +    52  +    17  |
        = | -17 |
          |  17 |
          |  -1 |
   最终: x = -17, y = 17, z = -1
  ``` 
  
  - 使用场景
    - 解线性方程组(Ax = b)
      - 解线性方程组用 `高斯-约旦消元法` 是更直接、更高效的办法
    - 图像处理(几何变换)
      - 图像旋转、缩放、镜像等都可以用矩阵表示
      - 反过来还原图像
    - 物理仿真/机器人学
      - 坐标系之间的变换(如机械臂末端 → 基座)
      - 将空间变换 `反向回来`
    - 计算偏导 `Jacobian` 的逆(深度学习 / 优化)
      - 训练神经网络时涉及到雅可比矩阵
      - 有些优化算法中用到了其逆或伪逆
    - 控制系统/状态空间建模