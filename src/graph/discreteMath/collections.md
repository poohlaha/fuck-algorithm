# 集合
  集合是 `一些不重复元素组成的整体`, 可以把它想象成一个 `袋子` 或 `容器`, 里面放一些具体的对象, 比如数字、字母、图形等等。

## 三个特点
   - 元素无序: 集合 {a, b} 和 {b, a} 是一样的
   - 元素唯一: 集合中不会重复, 例如: {a, a, b} 其实就等于 {a, b}
   - 用花括号表示
   ```text
   A = {1, 2, 3} 
   表示集合 A 包括 1, 2, 3
   ```

1. 试试看
   ```text
   集合 S = {a, b, c}
   1. {a, c, b} 和 S 是不是同一个集合?  ✅
   2. {a, b, b, c} 和 S 是不是同一个集合? ✅
   3. a ∈ S 是什么意思? a 属于 S
   ```
   
2. 元素与集合的关系: 符号 `∈`
   用符号 `∈` 表示 `属于`, 也就是 `某个元素是否在集合中`
   ```text
   举例:
   a ∈ {a, b, c}: a 属于这个集合
   d ∉ {a, b, c}: d 不在这个集合里
   这个就是集合的基本语法之一
   
   快速练习:
   集合 T = {2, 4, 6, 8}
   判断下面每一项是 `∈`(属于) 还是 `∉`(不属于)这个集合:
   1. 4 ? T  -> ✅
   2. 5 ? T  -> ❌
   3. 2 + 6 ? T  -> ✅
   ```
   
## 集合之间的关系与运算
1. 子集(subset)
   集合 A 是集合 B 的子集, 意思是: `A 中的每个元素都在 B 中`, 记作: `A ⊆ B`
   注意: `集合自己也是自己的子集(A ⊆ A)`

   ```text
   举例:
    A = {1, 2}, B = {1, 2, 3} ⇒ A ⊆ B
   因为 A 中的 1 和 2 都在 B 里
   ```

2. 真子集(proper subset)
   如果 `A ⊆ B`, 而且 `A ≠ B`, 那我们说 A 是 B 的 `真子集`, 记作: `A ⊂ B`
   
   ```text
   现在有三个集合:
   X = {a, b}
   Y = {a, b, c}
   Z = {a, b}
   
   判断:
   1. X ⊆ Y ? ✅
   2. X ⊂ Y ? ✅
   3. X ⊆ Z ? ✅
   4. X ⊂ Z ? ❌
   ```
   
## 集合的三种基本运算
1. 并集 `A ∪ B`
   `属于 A` 或 `属于 B` 或 `都属于` 的所有元素
   {1, 2} ∪ {2, 3} = {1, 2, 3}

2. 交集 `A ∩ B`
   同时 `属于 A 和 B` 的元素
   {1, 2} ∩ {2, 3} = {2}

3. 差集 `A - B`
   `在 A 中但不在 B 中` 的元素
   {1, 2} - {2, 3} = {1}

4. 练习
```text
   设有:
   A = {1, 2, 3}
   B = {2, 3, 4}
   
   请写出以下结果:
   1. A ∪ B = ? -> {1, 2, 3, 4}
   2. A ∩ B = ? -> {2, 3}
   3. A − B = ? -> {1}
```

## 集合的补集
1. 概念
   如果有一个全集 `𝑈`, 某个集合 `A ⊆ U`, 那么集合 `A` 的 `补集` 记作: `Aᶜ = U - A = {x ∈ U | x ∉ A}`

2. 举例
   ```text
   设:
   全集 U = {1, 2, 3, 4, 5}
   集合 A = {2, 4}
   那么:
   补集: Aᶜ = {1, 3, 5}
   ```
   
3. 常见记号
   ```text
   表示方式                  含义
   Aᶜ/A'                    A 的补集
   Ā                        也是 A 的补集
   U - A                    从全集中 `减去 A`
   ```

4. 小贴士
   可以把全集 U 想成 `整个宇宙`, 补集就是 `不属于某集合 A 的那一部分宇宙`

5. 相对补集 VS 绝对补集
   ```text
   类型          名称                     记法                概念
   绝对补集       complement              Aᶜ/A'/Ā            相对于全集 U 来说, 补掉 A
   相对补集       relative complement     B - A 或 B \ A     相对于集合 B 而言, 去掉 A 中有的元素
   ```

6. 小练习
   ```text
   设:
   全集 U = {a, b, c, d, e}
   B = {b, d}
   请写出 
   Bᶜ = ? -> {a, c, e}
   
   设:
   U = {1, 2, 3, 4, 5}
   A = {2, 3}
   B = {2, 3, 4}
   
   绝对补集: Aᶜ = U - A = {1, 4, 5}
   相对补集: B - A = {4}
   ```
 
7. 两者区别
   ```text
   问法                     对应操作
   不在 A 里的人是哪些        → 要有全集，做 `绝对补集`
   B 里有哪些不在 A 中？      → B - A，是 `相对补集`
   ```
   
## 补集和差集的区别
   - `差集 A - B`: 只在 A 中, 不在 B 中
   - `补集 Aᶜ`: 在全集中但不在 A 中
   - 换句话说:
     - `补集 = 全集 - A`
     - 如果 `把 A 当作全集`，那 `A - B` 相当于 `B 的补集`

## 总结
```text
概念                 例子                      记号
集合定义              {1, 2, 3}                用 `花括号`
元素属于集合           2 ∈ {1, 2, 3}           `∈` 表示 `属于`
子集/真子集           {1, 2} ⊆ {1, 2, 3}       所有元素都包含
并集                 A ∪ B                    所有出在 A 或 B 的元素
交集                 A ∩ B                    同时在 A 和 B 中的元素
差集                 A - B                    只在 A, 不在 B 的元素  
补集                 Aᶜ/A'/Ā                  在全集中但不在 A 中的元素
```

## 幂集(Power Set)
1. 概念
   一个集合的 `幂集`, 就是它的 `所有子集` 组成的集合
   如果 `A = {a, b}`, 那么它的幂集 `P(A)` 是: `P(A) = {∅, {a}, {b}, {a, b}}`

2. 特点
   - 总是 `包含空集` `∅`
   - `包含自身`
   - 如果原集合有 `n` 个元素, 那个幂集有 `2^n` 个子集
   ```text
   集合 {x}: 幂集有 2^1 = 2 个子集: {∅, {x}}
   集合 {a, b}: 幂集有 2^2 = 4 个子集: {∅, {a}, {b}, {a, b}}
   集合 {1, 2, 3}: 幂集有 2^3 = 8 个子集: {∅, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
   ```
   
3. 试试看
   ```text
   现在有集合： S = {x, y, z}
   请列出它的幂集(总共有 2^3 = 8 个子集), 可以按从空集到全体的顺序写:
   (空集 -> 单无素 -> 两个元素 -> 全部)
   
   {∅, {x}, {y}, {z}, {x, y}, {x, z}, {y, z}, {x, y, z}}
   ```
   
## 摩根定律(De Morgan's Laws)  
1. 概念
   摩根定律是在集合运算中非常重要的一组恒等式, 它反映了 `补集` 和 `交并运算` 之间的关系。

2. 基本形式
   - `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`
   - `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`
   - `交变并, 补集分` 或 `分开取补, 交换交并`

3. 推导 `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`
   ```text
   设全集 U = {1, 2, 3, 4, 5}
   A = {1, 2, 3}
   B = {3, 4}
   
   先算左边:
   1. A ∪ B = {1, 2, 3, 4}
   2. (A ∪ B)ᶜ = U - {1, 2, 3, 4} = {5}
   
   再算右边:
   1. Aᶜ = {4, 5}, Bᶜ = {1, 2, 5}
   2. Aᶜ ∩ Bᶜ = {5}
   
   两边都等于 {5}, 所以: (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ
   ```
   
4. 推导 `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`
   ```text
   全集 U = {1, 2, 3, 4, 5}, 设:
   A = {2, 3}
   B = {3, 5}
   
   先算左边:
   1. A ∩ B = {3}
   2. (A ∩ B)ᶜ = U - {3} = {1, 2, 4, 5}
   
   再算右边:
   1. Aᶜ = {1, 4, 5}, Bᶜ = {1, 2, 4}
   2. Aᶜ ∪ Bᶜ = {1, 2, 4, 5}
   
   两边都等于 {1, 2, 4, 5}, 所以: (A ∩ B)ᶜ = Aᶜ ∪ Bᶜ
   ```

## 笛卡尔积(Cartesian Product)
1. 概念
   笛卡尔积是 `两个集合之间所有可能的有序对组合`。
   设有两个集合:
              A = {a, b}, B = {1, 2}
   那么它们的笛卡尔积 A × B 是:
             A × B = {(a, 1), (a, 2), (b, 1) (b, 2)}
   
2. 特点
   - 元素是 `有序对`, 形式是 `(x, y)`
   - `顺序是不能颠倒`, `(a, 1) ≠ (1, a)`
   - 元素`个数` 是 `|A| × |B|`
   
3. 应用
   - `边的集合` 就来自 `顶点集合的笛卡尔积的子集`
     - 如: 所有可能的有向边来自 `V × V`
   - 如果图是 `完全图`, 那边集就是 `{(u, v) | u, v ∈ V, u ≠ v}`
   
4. 练习
   ```text
   设:
   A = {x, y}
   B = {1, 2, 3}
   
   请写出 
   A × B = {(x, 1), (x, 2), (x, 3), (y, 1), (y, 2), (y, 3)}
   B × A = {(1, x), (1, y), (2, x), (2, y), (3, x), (3, y)}
   ```
   
5. 结论
   如果集合 `A` 有 `m` 个元素, 集合 `B` 有 `n` 个元素:
   那第 `A × B` 有 `m × n` 个元素

## 集合上的关系(relation on a set)
1. 关系(Relation)的定义
   在集合 `A` 上的一个关系, 就是从 `A × A 的子集` 中选出一些 `有意义` 的 `有序对`

2. 举例
   ```text
   设 A = {1, 2, 3}
   则:
     A × A = {(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)}
   
   定义一个关系 R: 
                a 与 b 的关系是 a ≤ b
   那么 `R ⊆ A × A` 中包含的对就是:
                R = {(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)}
   
   定义一个关系 R:
                a 与 b 的关系是 a 是 b 的倍数
   那么包含的对就是:
                R = {(1, 1), (2, 2), (3, 3)}  
   ```
   
3. 恒等关系
   `R = {(a, a) | a ∈ A}`, 只有 `自己` 和 `自己` 有关系, 其他的都没有关系
   ```text
   设 A = {1, 2, 3}
   定义一个关系 R:
                a 与 b 的关系是 a 是 b 的倍数
   那么包含的对就是:
                R = {(1, 1), (2, 2), (3, 3)}  
   
   定义一个关系 R:
                a 和 b 都是奇数
   那么包含的对就是:
                R = {(1, 1), (1, 3), (3, 1), (3, 3)} 
   
    定义一个关系 R:
                a + b 是偶数
   那么包含的对就是:
               R = {(1, 1), (1, 3), (2, 2), (3, 1), (3, 3)}
   ```

4. 关系的 `传递性`
   集合 A 上的一个关系 R 是 `传递的`, 当它满足:
   只要 `(a, b) ∈ R 且 (b, c) ∈ R`， 那就必须有 `(a, c) ∈ R`
   ```text
   想象 
   𝑎 喜欢 𝑏，而 𝑏 又喜欢 𝑐。
   如果这份“喜欢”的关系是 `传递的`，那就说明: 𝑎 也必须喜欢 𝑐。
   ```
   
   ```text
   举例:
   设:
      A = {1, 2, 3} 上有一个关系 R:
      R = {(1, 2), (2, 3), (1, 3)}
   问: 这个关系传递吗?
   
   检查是否满足:
      (1, 2) 和 (2, 3) 都在关系里 ✅
      所以是否有 (1, 3) 呢？✅ 有！
   ✔️ 所以这个关系是传递的。
   
   R={(1, 1), (1, 3), (3, 3)}
   在 R 中捞出所有满足 (a, b) 和 (b, c) 的组合, 然后看 (a, c) 是不是也在 R
   -> (1, 3) 和 (3, 1), 满足条件: (a, b) = (1, 3), (b, c) = (3, 3), 根据传递要求: (1, 3) & (3, 3) ⇒ (1, 3) ∈ R ✅
   -> (1, 1) 和 (1, 3), 满足条件: (a, b) = (1, 1), (b, c) = (3, 3), 根据传递要求: (1, 1) & (1, 3) ⇒ (1, 3) ∈ R ✅
   -> R 是传递的
   ```

5. 关系的三大重要性质
   - 自反: 关系中包含所有 `对角线` 元素 (a, a)
   - 对称: 关系“互惠”，例如朋友关系
   - 传递: 关系“延续”，例如“喜欢”的传递性不一定成立，但“等于”关系就成立
   
   ```text
   性质                     定义                                            直观理解                   例子(集合 A = {1, 2, 3})
   自反性(Reflexive)        对所有 a ∈ A, 都有 (a, a) ∈ R                    每个元素都和自己相关联        R = {(1, 1), (2, 2), (3, 3), ...}
   对称性(Symmetric)        若 (a, b) ∈ R, 则 (b, a) ∈ R                    关系是 `双向的`             如果 (1, 2) 在, (2, 1) 也必须在
   传递性(Transitive)       若 (a, b) ∈ R 且 (b, c) ∈ R 则 (a, c) ∈ R       链式关系成立                 有 (1, 2) 和 (2, 3)，必须有 (1, 3)
   ```

## 等价关系(Equivalence Relation)
1. 概念
   一个关系 R 是 `等价关系`, 当它同时满足:
   - 自反性: (a, a) ∈ R
   - 对称性: (a, b) ∈ R ⇒ (b, a) ∈ R
   - 传递性: (a, b), (b, c) ∈ R ⇒ (a, c) ∈ R
   
2. 举例
   ```text
   设集合 A = {1, 2, 3}, 定义关系: R = {(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)}
   - 自反性: 所有 (a, a) 都在
   - 对称性: 有(1, 2), 也有 (2, 1)
   - 传递性: (1, 2), (2, 1) ⇒ (1, 1)
   所以: 这是一个等价关系
   ```

## 等价关系 ↔ 划分(Partition)
1. 概念
   `等价关系会把集合 A 划分成若干个不重叠的子集`，叫做 `等价类(equivalence classes)`
   直观理解: 把所有 `互相有等价关系` 的元素圈成一组, 这些组会刚好覆盖整个集合，互不重叠, 这就是划分

2. 举例
   ```text
   集合 A = {1, 2, 3, 4, 5, 6}
   定义: a 和 b 同余 mod 3(即 a ≡ b mod 3)
   这关系满足三性 → 是等价关系！
   那么它会把 A 划分成 3 个等价类:
   - [0] = {3, 6}
   - [1] = {1, 4}
   - [2] = {2, 5}
   这些子集构成了一个划分！
   
   集合 A = {a, b, c, d}
   设关系 R = {(a, a), (b, b), (c, c), (d, d), (a, b), (b, a)}
   -> [a]: (a, a), (a, b), (b, a) ⇒ [a] = {a, b}
   -> [b]: (b, b), (a, b) ⇒ [b] = {a, b}
   -> a 和 b 互相等价，它们属于同一个类
   -> [c]: (c, c) ⇒ [c] = {c}
   -> [d]: (d, d) ⇒ [d] = {d}
   
   最终把 A 分成以下三个等价类: {{a, b}, {c}, {d}}
   
   集合: A = {1, 2, 3, 4, 5, 6}
   定义关系 R 如下:
        R = {(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (1, 4), (4, 1), (2, 5), (5, 2), (3, 6), (6, 3)}   
   -> [1]: (1, 1), (1, 4), (4, 1) ⇒ [1] = {1, 4}
   -> [2]: (2, 2), (2, 5), (5, 2) ⇒ [2] = {2, 5}
   -> [3]: (3, 3), (3, 6), (6, 3) ⇒ [3] = {3, 6}
   -> [4]: (4, 4) ⇒ [4] = {4}
   -> [5]: (5, 5) ⇒ [5] = {5}
   -> [6]: (6, 6) ⇒ [6] = {6}
   
   最终把 A 分成以下三个等价类: {{1, 4}, {2, 5}, {3, 6}}
   ```
   
3. 总结
   - 等价类是指: 与某个元素 `等价` 的所有元素
   - 等价关系一定会把集成分成 `不重叠且覆盖全集` 的等价类
   - 等价类组成的这些集合叫做 `划分(partition)`

## 偏序关系
   `偏序关系` 是集合上某种特殊的 `比较` 关系。
   
1. 什么是 `关系`?
   给定一个集合 A, 在集合中的元素之间, 我们可以定义 `某种关系`
   ```text
   集合 A = {1, 2, 3}
   定义一个关系 R: R = {(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)}
   意思是:
         - 1 与 1 有关系(记作: 1 ~ 1)
         - 1 与 2 有关系(记作: 1 ~ 2)
         - 2 与 2 有关系(记作: 2 ~ 2)
         ...
   这个“关系”就是一组有序对，表示集合中哪些元素之间“有关系”。
   ```
   
2. 什么是 `偏序`?
   现在我们要引入一个特殊的关系 —— 它要满足三条规则。
   - 自反性(Reflexive)
     - 每个元素都跟自己有关系
     - 对于所有 a ∈ A, 必须有 (a, a) ∈ R
   - 反对称性(Antisymmetric)
     - 如果 a 和 b 有关系, b 又和 a 有关系, 那么它们必须是同一个元素
     - 如果 (a, b) ∈ R, 且 (b, a) ∈ R, 那么一定有 a = b
     - 例
       - 如果 (1, 2) ∈ R, 且(2, 1) ∈ R, 那就违反了反对称性, 因为 1 ≠ 2
     - 只允许一个方向存在, 或者 a = b
   - 传递性(Transitive)
     - 如果 a 和 b 有关系, b 和 c 有关系, 那么 a 和 c 也必须有关系
     - 如果(a, b) ∈ R 且 (b, c)  ∈ R, 那么必须有 (a, c) ∈ R

3. 总结
   一个关系 R 是偏序关系，必须满足:
   - 所有元素自己和自己有关系(自反性)
   - 不允许 a ~ b 且 b ~ a, 除非 a = b (反对称性)
   - 如果 a ~ b, b ~ c, 那么 a ~ c(传递性)

4. 举例
   ```text
   集合之间的包含关系(⊆)
   设 A = {{1}, {1, 2}, {1, 2, 3}}
   我们定义集合之间的关系是“包含关系”：例如 {1} ⊆ {1, 2}
   
   检查三个性质:
   1. 自反性
      ✅ 每个集合都包含自己, 如: {1, 2} ⊆ {1, 2}
   2. 反对称性
      ✅ 只有两个集体完全相等, 才会互相包含:
      如果 A ⊆ B 且 B ⊆ A, 那么 A = B
   3. 传递性
      ✅ A ⊆ B 且 B ⊆ C, 则 A ⊆ C
   所以“集合的包含关系”是偏序关系
   
   集合 A = {1, 2, 3}, 关系 R = {(1, 1), (2, 2), (3, 3), (1, 2)}
   检查三个性质:
   1. 自反性
      ✅(1, 1), (2, 2), (3, 3)
   2. 反对称性
      ✅(1, 2) 没有出现 (2, 1)
   3. 传递性
      ✅ {(1, 1), (1, 2)}, {(1, 2), (2, 2)}
   ```
   
5. 总结
   ```text
   性质                 重点检查
   自反性               每个 a ∈ A, 都有 (a, a) ∈ R
   反对称性             看有没有 (a, b) 和 (b, a), 若有则必须 a = b 
   传递性               所有 (a, b), (b, c) ∈ R ⇒ (a, c) ∈ R
   ```