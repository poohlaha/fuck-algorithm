# 集合
  集合是 `一些不重复元素组成的整体`, 可以把它想象成一个 `袋子` 或 `容器`, 里面放一些具体的对象, 比如数字、字母、图形等等。

## 三个特点
   - 元素无序: 集合 {a, b} 和 {b, a} 是一样的
   - 元素唯一: 集合中不会重复, 例如: {a, a, b} 其实就等于 {a, b}
   - 用花括号表示
   ```text
   A = {1, 2, 3} 
   表示集合 A 包括 1, 2, 3
   ```

1. 试试看
   ```text
   集合 S = {a, b, c}
   1. {a, c, b} 和 S 是不是同一个集合?  ✅
   2. {a, b, b, c} 和 S 是不是同一个集合? ✅
   3. a ∈ S 是什么意思? a 属于 S
   ```
   
2. 元素与集合的关系: 符号 `∈`
   用符号 `∈` 表示 `属于`, 也就是 `某个元素是否在集合中`
   ```text
   举例:
   a ∈ {a, b, c}: a 属于这个集合
   d ∉ {a, b, c}: d 不在这个集合里
   这个就是集合的基本语法之一
   
   快速练习:
   集合 T = {2, 4, 6, 8}
   判断下面每一项是 `∈`(属于) 还是 `∉`(不属于)这个集合:
   1. 4 ? T  -> ✅
   2. 5 ? T  -> ❌
   3. 2 + 6 ? T  -> ✅
   ```
   
## 集合之间的关系与运算
1. 子集(subset)
   集合 A 是集合 B 的子集, 意思是: `A 中的每个元素都在 B 中`, 记作: `A ⊆ B`
   注意: `集合自己也是自己的子集(A ⊆ A)`

   ```text
   举例:
    A = {1, 2}, B = {1, 2, 3} ⇒ A ⊆ B
   因为 A 中的 1 和 2 都在 B 里
   ```

2. 真子集(proper subset)
   如果 `A ⊆ B`, 而且 `A ≠ B`, 那我们说 A 是 B 的 `真子集`, 记作: `A ⊂ B`
   
   ```text
   现在有三个集合:
   X = {a, b}
   Y = {a, b, c}
   Z = {a, b}
   
   判断:
   1. X ⊆ Y ? ✅
   2. X ⊂ Y ? ✅
   3. X ⊆ Z ? ✅
   4. X ⊂ Z ? ❌
   ```
   
## 集合的三种基本运算
1. 并集 `A ∪ B`
   `属于 A` 或 `属于 B` 或 `都属于` 的所有元素
   {1, 2} ∪ {2, 3} = {1, 2, 3}

2. 交集 `A ∩ B`
   同时 `属于 A 和 B` 的元素
   {1, 2} ∩ {2, 3} = {2}

3. 差集 `A - B`
   `在 A 中但不在 B 中` 的元素
   {1, 2} - {2, 3} = {1}

4. 练习
```text
   设有:
   A = {1, 2, 3}
   B = {2, 3, 4}
   
   请写出以下结果:
   1. A ∪ B = ? -> {1, 2, 3, 4}
   2. A ∩ B = ? -> {2, 3}
   3. A − B = ? -> {1}
```

## 集合的补集
1. 概念
   如果有一个全集 `𝑈`, 某个集合 `A ⊆ U`, 那么集合 `A` 的 `补集` 记作: `Aᶜ = U - A = {x ∈ U | x ∉ A}`

2. 举例
   ```text
   设:
   全集 U = {1, 2, 3, 4, 5}
   集合 A = {2, 4}
   那么:
   补集: Aᶜ = {1, 3, 5}
   ```
   
3. 常见记号
   ```text
   表示方式                  含义
   Aᶜ/A'                    A 的补集
   Ā                        也是 A 的补集
   U - A                    从全集中 `减去 A`
   ```

4. 小贴士
   可以把全集 U 想成 `整个宇宙`, 补集就是 `不属于某集合 A 的那一部分宇宙`

5. 相对补集 VS 绝对补集
   ```text
   类型          名称                     记法                概念
   绝对补集       complement              Aᶜ/A'/Ā            相对于全集 U 来说, 补掉 A
   相对补集       relative complement     B - A 或 B \ A     相对于集合 B 而言, 去掉 A 中有的元素
   ```

6. 小练习
   ```text
   设:
   全集 U = {a, b, c, d, e}
   B = {b, d}
   请写出 
   Bᶜ = ? -> {a, c, e}
   
   设:
   U = {1, 2, 3, 4, 5}
   A = {2, 3}
   B = {2, 3, 4}
   
   绝对补集: Aᶜ = U - A = {1, 4, 5}
   相对补集: B - A = {4}
   ```
 
7. 两者区别
   ```text
   问法                     对应操作
   不在 A 里的人是哪些        → 要有全集，做 `绝对补集`
   B 里有哪些不在 A 中？      → B - A，是 `相对补集`
   ```
   
## 补集和差集的区别
   - `差集 A - B`: 只在 A 中, 不在 B 中
   - `补集 Aᶜ`: 在全集中但不在 A 中
   - 换句话说:
     - `补集 = 全集 - A`
     - 如果 `把 A 当作全集`，那 `A - B` 相当于 `B 的补集`

## 总结
```text
概念                 例子                      记号
集合定义              {1, 2, 3}                用 `花括号`
元素属于集合           2 ∈ {1, 2, 3}           `∈` 表示 `属于`
子集/真子集           {1, 2} ⊆ {1, 2, 3}       所有元素都包含
并集                 A ∪ B                    所有出在 A 或 B 的元素
交集                 A ∩ B                    同时在 A 和 B 中的元素
差集                 A - B                    只在 A, 不在 B 的元素  
补集                 Aᶜ/A'/Ā                  在全集中但不在 A 中的元素
```

## 幂集(Power Set)
1. 概念
   一个集合的 `幂集`, 就是它的 `所有子集` 组成的集合
   如果 `A = {a, b}`, 那么它的幂集 `P(A)` 是: `P(A) = {∅, {a}, {b}, {a, b}}`

2. 特点
   - 总是 `包含空集` `∅`
   - `包含自身`
   - 如果原集合有 `n` 个元素, 那个幂集有 `2^n` 个子集
   ```text
   集合 {x}: 幂集有 2^1 = 2 个子集: {∅, {x}}
   集合 {a, b}: 幂集有 2^2 = 4 个子集: {∅, {a}, {b}, {a, b}}
   集合 {1, 2, 3}: 幂集有 2^3 = 8 个子集: {∅, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}
   ```
   
3. 试试看
   ```text
   现在有集合： S = {x, y, z}
   请列出它的幂集(总共有 2^3 = 8 个子集), 可以按从空集到全体的顺序写:
   (空集 -> 单无素 -> 两个元素 -> 全部)
   
   {∅, {x}, {y}, {z}, {x, y}, {x, z}, {y, z}, {x, y, z}}
   ```
   
## 摩根定律(De Morgan's Laws)  
1. 概念
   摩根定律是在集合运算中非常重要的一组恒等式, 它反映了 `补集` 和 `交并运算` 之间的关系。

2. 基本形式
   - `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`
   - `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`
   - `交变并, 补集分` 或 `分开取补, 交换交并`

3. 推导 `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`
   ```text
   设全集 U = {1, 2, 3, 4, 5}
   A = {1, 2, 3}
   B = {3, 4}
   
   先算左边:
   1. A ∪ B = {1, 2, 3, 4}
   2. (A ∪ B)ᶜ = U - {1, 2, 3, 4} = {5}
   
   再算右边:
   1. Aᶜ = {4, 5}, Bᶜ = {1, 2, 5}
   2. Aᶜ ∩ Bᶜ = {5}
   
   两边都等于 {5}, 所以: (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ
   ```
   
4. 推导 `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`
   ```text
   全集 U = {1, 2, 3, 4, 5}, 设:
   A = {2, 3}
   B = {3, 5}
   
   先算左边:
   1. A ∩ B = {3}
   2. (A ∩ B)ᶜ = U - {3} = {1, 2, 4, 5}
   
   再算右边:
   1. Aᶜ = {1, 4, 5}, Bᶜ = {1, 2, 4}
   2. Aᶜ ∪ Bᶜ = {1, 2, 4, 5}
   
   两边都等于 {1, 2, 4, 5}, 所以: (A ∩ B)ᶜ = Aᶜ ∪ Bᶜ
   ```

## 笛卡尔积(Cartesian Product)
1. 概念
   笛卡尔积是 `两个集合之间所有可能的有序对组合`。
   设有两个集合:
              A = {a, b}, B = {1, 2}
   那么它们的笛卡尔积 A × B 是:
             A × B = {(a, 1), (a, 2), (b, 1) (b, 2)}
   
2. 特点
   - 元素是 `有序对`, 形式是 `(x, y)`
   - `顺序是不能颠倒`, `(a, 1) ≠ (1, a)`
   - 元素`个数` 是 `|A| × |B|`
   
3. 应用
   - `边的集合` 就来自 `顶点集合的笛卡尔积的子集`
     - 如: 所有可能的有向边来自 `V × V`
   - 如果图是 `完全图`, 那边集就是 `{(u, v) | u, v ∈ V, u ≠ v}`
   
4. 练习
   ```text
   设:
   A = {x, y}
   B = {1, 2, 3}
   
   请写出 
   A × B = {(x, 1), (x, 2), (x, 3), (y, 1), (y, 2), (y, 3)}
   B × A = {(1, x), (1, y), (2, x), (2, y), (3, x), (3, y)}
   ```
   
5. 结论
   如果集合 `A` 有 `m` 个元素, 集合 `B` 有 `n` 个元素:
   那第 `A × B` 有 `m × n` 个元素

## 集合上的关系(relation on a set)
1. 关系(Relation)的定义
   在集合 `A` 上的一个关系, 就是从 `A × A 的子集` 中选出一些 `有意义` 的 `有序对`

2. 举例
   ```text
   设 A = {1, 2, 3}
   则:
     A × A = {(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)}
   
   定义一个关系 R: 
                a 与 b 的关系是 a ≤ b
   那么 `R ⊆ A × A` 中包含的对就是:
                R = {(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)}
   
   定义一个关系 R:
                a 与 b 的关系是 a 是 b 的倍数
   那么包含的对就是:
                R = {(1, 1), (2, 2), (3, 3)}  
   ```
   
3. 恒等关系
   `R = {(a, a) | a ∈ A}`, 只有 `自己` 和 `自己` 有关系, 其他的都没有关系
   ```text
   设 A = {1, 2, 3}
   定义一个关系 R:
                a 与 b 的关系是 a 是 b 的倍数
   那么包含的对就是:
                R = {(1, 1), (2, 2), (3, 3)}  
   
   定义一个关系 R:
                a 和 b 都是奇数
   那么包含的对就是:
                R = {(1, 1), (1, 3), (3, 1), (3, 3)} 
   
    定义一个关系 R:
                a + b 是偶数
   那么包含的对就是:
               R = {(1, 1), (1, 3), (2, 2), (3, 1), (3, 3)}
   ```

4. 关系的 `传递性`
   集合 A 上的一个关系 R 是 `传递的`, 当它满足:
   只要 `(a, b) ∈ R 且 (b, c) ∈ R`， 那就必须有 `(a, c) ∈ R`
   ```text
   想象 
   𝑎 喜欢 𝑏，而 𝑏 又喜欢 𝑐。
   如果这份“喜欢”的关系是 `传递的`，那就说明: 𝑎 也必须喜欢 𝑐。
   ```
   
   ```text
   举例:
   设:
      A = {1, 2, 3} 上有一个关系 R:
      R = {(1, 2), (2, 3), (1, 3)}
   问: 这个关系传递吗?
   
   检查是否满足:
      (1, 2) 和 (2, 3) 都在关系里 ✅
      所以是否有 (1, 3) 呢？✅ 有！
   ✔️ 所以这个关系是传递的。
   
   R={(1, 1), (1, 3), (3, 3)}
   在 R 中捞出所有满足 (a, b) 和 (b, c) 的组合, 然后看 (a, c) 是不是也在 R
   -> (1, 3) 和 (3, 1), 满足条件: (a, b) = (1, 3), (b, c) = (3, 3), 根据传递要求: (1, 3) & (3, 3) ⇒ (1, 3) ∈ R ✅
   -> (1, 1) 和 (1, 3), 满足条件: (a, b) = (1, 1), (b, c) = (3, 3), 根据传递要求: (1, 1) & (1, 3) ⇒ (1, 3) ∈ R ✅
   -> R 是传递的
   ```

5. 关系的三大重要性质
   - 自反: 关系中包含所有 `对角线` 元素 (a, a)
   - 对称: 关系 `互惠`, 例如朋友关系
   - 传递: 关系 `延续`, 例如“喜欢”的传递性不一定成立，但“等于”关系就成立
   
   ```text
   性质                     定义                                            直观理解                   例子(集合 A = {1, 2, 3})
   自反性(Reflexive)        对所有 a ∈ A, 都有 (a, a) ∈ R                    每个元素都和自己相关联        R = {(1, 1), (2, 2), (3, 3), ...}
   对称性(Symmetric)        若 (a, b) ∈ R, 则 (b, a) ∈ R                    关系是 `双向的`             如果 (1, 2) 在, (2, 1) 也必须在
   传递性(Transitive)       若 (a, b) ∈ R 且 (b, c) ∈ R 则 (a, c) ∈ R       链式关系成立                 有 (1, 2) 和 (2, 3)，必须有 (1, 3)
   ```

## 等价关系(Equivalence Relation)
1. 概念
   一个关系 R 是 `等价关系`, 当它同时满足:
   - 自反性: (a, a) ∈ R
   - 对称性: (a, b) ∈ R ⇒ (b, a) ∈ R
   - 传递性: (a, b), (b, c) ∈ R ⇒ (a, c) ∈ R
   
2. 举例
   ```text
   设集合 A = {1, 2, 3}, 定义关系: R = {(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)}
   - 自反性: 所有 (a, a) 都在
   - 对称性: 有(1, 2), 也有 (2, 1)
   - 传递性: (1, 2), (2, 1) ⇒ (1, 1)
   所以: 这是一个等价关系
   ```

## 等价关系 ↔ 划分(Partition)
1. 概念
   `等价关系会把集合 A 划分成若干个不重叠的子集`，叫做 `等价类(equivalence classes)`
   直观理解: 把所有 `互相有等价关系` 的元素圈成一组, 这些组会刚好覆盖整个集合，互不重叠, 这就是划分

2. 举例
   ```text
   集合 A = {1, 2, 3, 4, 5, 6}
   定义: a 和 b 同余 mod 3(即 a ≡ b mod 3)
   这关系满足三性 → 是等价关系！
   那么它会把 A 划分成 3 个等价类:
   - [0] = {3, 6}
   - [1] = {1, 4}
   - [2] = {2, 5}
   这些子集构成了一个划分！
   
   集合 A = {a, b, c, d}
   设关系 R = {(a, a), (b, b), (c, c), (d, d), (a, b), (b, a)}
   -> [a]: (a, a), (a, b), (b, a) ⇒ [a] = {a, b}
   -> [b]: (b, b), (a, b) ⇒ [b] = {a, b}
   -> a 和 b 互相等价，它们属于同一个类
   -> [c]: (c, c) ⇒ [c] = {c}
   -> [d]: (d, d) ⇒ [d] = {d}
   
   最终把 A 分成以下三个等价类: {{a, b}, {c}, {d}}
   
   集合: A = {1, 2, 3, 4, 5, 6}
   定义关系 R 如下:
        R = {(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (1, 4), (4, 1), (2, 5), (5, 2), (3, 6), (6, 3)}   
   -> [1]: (1, 1), (1, 4), (4, 1) ⇒ [1] = {1, 4}
   -> [2]: (2, 2), (2, 5), (5, 2) ⇒ [2] = {2, 5}
   -> [3]: (3, 3), (3, 6), (6, 3) ⇒ [3] = {3, 6}
   -> [4]: (4, 4) ⇒ [4] = {4}
   -> [5]: (5, 5) ⇒ [5] = {5}
   -> [6]: (6, 6) ⇒ [6] = {6}
   
   最终把 A 分成以下三个等价类: {{1, 4}, {2, 5}, {3, 6}}
   ```
   
3. 总结
   - 等价类是指: 与某个元素 `等价` 的所有元素
   - 等价关系一定会把集成分成 `不重叠且覆盖全集` 的等价类
   - 等价类组成的这些集合叫做 `划分(partition)`

##  关系的性质与类型
### 偏序关系
   `偏序关系` 是集合上某种特殊的 `比较` 关系。
   
1. 什么是 `关系`?
   给定一个集合 A, 在集合中的元素之间, 我们可以定义 `某种关系`
   ```text
   集合 A = {1, 2, 3}
   定义一个关系 R: R = {(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)}
   意思是:
         - 1 与 1 有关系(记作: 1 ~ 1)
         - 1 与 2 有关系(记作: 1 ~ 2)
         - 2 与 2 有关系(记作: 2 ~ 2)
         ...
   这个“关系”就是一组有序对，表示集合中哪些元素之间“有关系”。
   ```
   
2. 什么是 `偏序`?
   现在我们要引入一个特殊的关系 —— 它要满足三条规则。
   - 自反性(Reflexive)
     - 每个元素都跟自己有关系
     - 对于所有 a ∈ A, 必须有 (a, a) ∈ R
   - 反对称性(Antisymmetric)
     - 如果 a 和 b 有关系, b 又和 a 有关系, 那么它们必须是同一个元素
     - 如果 (a, b) ∈ R, 且 (b, a) ∈ R, 那么一定有 a = b
     - 例
       - 如果 (1, 2) ∈ R, 且(2, 1) ∈ R, 那就违反了反对称性, 因为 1 ≠ 2
     - 只允许一个方向存在, 或者 a = b
   - 传递性(Transitive)
     - 如果 a 和 b 有关系, b 和 c 有关系, 那么 a 和 c 也必须有关系
     - 如果(a, b) ∈ R 且 (b, c)  ∈ R, 那么必须有 (a, c) ∈ R

3. 总结
   一个关系 R 是偏序关系，必须满足:
   - 所有元素自己和自己有关系(自反性)
   - 不允许 a ~ b 且 b ~ a, 除非 a = b (反对称性)
   - 如果 a ~ b, b ~ c, 那么 a ~ c(传递性)

4. 举例
   ```text
   集合之间的包含关系(⊆)
   设 A = {{1}, {1, 2}, {1, 2, 3}}
   我们定义集合之间的关系是“包含关系”：例如 {1} ⊆ {1, 2}
   
   检查三个性质:
   1. 自反性
      ✅ 每个集合都包含自己, 如: {1, 2} ⊆ {1, 2}
   2. 反对称性
      ✅ 只有两个集体完全相等, 才会互相包含:
      如果 A ⊆ B 且 B ⊆ A, 那么 A = B
   3. 传递性
      ✅ A ⊆ B 且 B ⊆ C, 则 A ⊆ C
   所以“集合的包含关系”是偏序关系
   
   集合 A = {1, 2, 3}, 关系 R = {(1, 1), (2, 2), (3, 3), (1, 2)}
   检查三个性质:
   1. 自反性
      ✅(1, 1), (2, 2), (3, 3)
   2. 反对称性
      ✅(1, 2) 没有出现 (2, 1)
   3. 传递性
      ✅ {(1, 1), (1, 2)}, {(1, 2), (2, 2)}
   ```
   
5. 总结
   ```text
   性质                 重点检查
   自反性               每个 a ∈ A, 都有 (a, a) ∈ R
   反对称性             看有没有 (a, b) 和 (b, a), 若有则必须 a = b 
   传递性               所有 (a, b), (b, c) ∈ R ⇒ (a, c) ∈ R
   ```
   
### 全序关系(Total Order)
1. 概念
   全序关系是在偏序关系基础上, 再加上 `任意两个元素都可以比较` 这个条件。
   - 全序关系 = 偏序关系 + 可比性
     - 偏序关系: 满足自反性、反对称性、传递性
     - 可比性: 任意两个元素都可以比较大小(至少一个方向有关系)
   ```text
   对于集合 A 中的任意两个元素 a, b, 必须至少满足下面之一: aRb 或 bRa
   ```
   
2. 为什么叫全序?
   `全` 就是指 `完全`, 意思是所有元素都能排出顺序, 没有 `打架` - 即不存在无法比较的元素。

3. 对比
   ```text
   关系类型                例子                  解释
   偏序关系                集合的包含关系 ⊆        有的集合互不包含, 不可比较, 比如 {1} 和 {2}
   全序关系                数字上的 `<=`          任意两个数字 a, b, 必须有 `a <= b` 或 `b <= a`
   ```
   
6. 用图形理解
   ```text
   假设集合 A = {a, b, c}
   偏序关系: 可能是这样 aRb, bRc, 但 a 和 c 可能没关系, 没有顺序
   全序关系: 必须是链式的 aRb, bRc, aRc, 并且wtuuj两个元素都能比较
   ```
   
7. 实例
   ```text
   集合 A = {1, 2, 3}
   关系 R = {(1, 1), (2, 2), (3, 3), (1, 2), (2, 3), (1, 3)}
   
   检查所有元素对:
   - 1 和 2: 有 (1, 2) ∈ R, 满足可比
   - 2 和 3: 有 (2, 3) ∈ R, 满足可比
   - 1 和 3: 有 (1, 3) ∈ R, 满足可比
   没遗漏, 所有元素都能比出顺序, 所有这是一个全序关系
   ```
   
### 关系的表示方式
   假设有一个集合 A, 比如: A = {1, 2, 3}, 以及定义在 A 上的关系 R, 比如: R = {(1, 1), (1, 2), (2, 3), (3, 1)}

1. 列举法(集合表示法)
   直接用 `有序对` 的形式列出所有关系对: R = {(1, 1), (1, 2), (2, 3), (3, 1)}
   优点: 最直接, 适合小集合
   缺点: 大集合时, 关系对很多, 不方便
   ```text
   集合: A = {a, b, c}
   关系: R = {(a, a), (a, b), (b, c), (c, c)}
   ```

2. 矩阵表示法(关系矩阵)
   用一个方阵表示关系
   - 行列分别表示集合中的元素(顺序固定, 比如 1, 2, 3)
   - 如果 (a, b) ⊆ R, 则矩阵中第 a 行、第 b 列的元素是 1(或 True), 否则是 0(或 False)
   ```text
                 1             2              3
   1             1             1              0
   2             0             0              1
   3             1             0              0
   解释:
   1. 第 1 行第 1 列是 1, 表示 (1, 1) ∈ R
   2. 第 1 行第 2 列是 1, 表示 (1, 2) ∈ R
   3. 第 2 行第 3 列是 1, 表示 (2, 3) ∈ R
   4. 第 3 行第 1 列是 1, 表示 (3, 1) ∈ R
   ```
   
3. 图形表示法(关系图)
   把集合中的元素看成图上的点(顶点), 每个关系 (a, b) 就是从点 a 指向点 b 的一条有向边。
   比如: 
   点: 1、2、3
   边: 1 -> 1(自环)、 1 -> 2、 2 -> 3、 3 -> 1
   这叫有向图(digraph), 用来形象展示关系

4. 关系的性质用表示法
   - 自反性: 对角线上全部是 1(矩阵法); 图中每个点有自环
   - 对称性: 矩阵是对称矩阵; 图中每条边都有反向边
   - 反对称性: 如果 (a, b) 和 (b, a) 都在关系里, 且 a ≠ b, 就不满足反对称;矩阵里对应位置不会对称为 1(除对角线)
   - 传递性: 可以通过矩阵的乘法(布尔乘法) 检测; 图中路径连通性反映传递性
   
5. 总结
   ```text
   表示方法                   适用情况                     直观特点
   列举法                     小集合, 关系列表少            直接明了
   矩阵法                     中小集合, 计算方便            适合计算机处理
   图形法                     理解结构, 复杂关系            直观形象
   ```

### 闭包(Closure)
1. 概念
   关系上的 `闭包`, 指的是对一个给定关系, 通过添加 `必要的元素` 使它满足某种性质(比如自反、对称、传递), 直到 `关系满足该性质为止`。
   换句话说, 闭包是 `补齐缺失的关系对`, 让关系 `变得完整` 且满足你想要的性质

2. 常见的闭包类型
   - 自反闭包(Reflexive Closure)
     - 对所有缺失的 (a, a) 加进关系, 保证自反性
   - 对称闭包(Symmetric Closure)
     - 对每个 (a, b), 如果 (b, a) 不在关系中, 就加上它
   - 传递闭包(Transitive Closure)
     - 对每对 (a, b), (b, c), 如果 (a, c) 不在关系中, 就加上它, 重复直到不需要再加
     
3. 举例
   ```text
   集合 A = {1, 2}
   关系 R = {(1, 2)}
   
   1. 自反闭包
      原来没有 (1, 1), (2, 2) 加上它们, 变成 R' = {(1, 2), (1, 1), (2, 2)}
   
   2. 对称闭包
      原来有 (1, 2), 但没有 (2, 1), 加上它, 变成 R'' = {(1, 2), (2, 1)}
   
   3. 传递闭包
      原来只有 (1, 2), 没有两个关系能连起来产生新关系, 传递闭包和原关系一样
   ```
   
4. 为什么闭包重要?
   闭包能帮我们把一个 `部分满足某性质` 的关系 `补齐`, 满足要求, 方便后续分析。

## 函数(Function)作为特殊关系
1. 概念
   简单来说, `函数是一种特殊的关系`, 它把每一个集合的每个元素, `对应(映射)到另一个集合中唯一的一个元素`。

2. 作为关系的函数
   假设有两个集合
   - 定义域 A (输入集合)
   - 值域 B (输出集合)
   函数 f 是集合 A 和 B 上的一个关系: f ⊆ A × B

3. 函数的两个关键条件
   - 定义性(Existence)
     - 对每个 a ∈ A, 必须至少有一个对应的 b ∈ B, 即关系中至少存在一个(a, b)
   - 唯一性(Uniqueness)
     - 对每个 a ∈ A, 对应的 b ∈ B 是唯一的, 不会有两个不同的 b1, b2 同时和 a 关联
   - 换句话说: 每个输入 a 只能对应一个输出 b  

4. 举例
   ```text
   集合 A = {1, 2, 3}, B = {x, y}
   关系(候选函数): f = {(1, x), (2, y), (3, x)}
   ```
   
## 映射
1. 一一映射(Injective, 或单射)
   如果函数 f: A -> B 满足 --- 不同的输入对应不同的输出, 即: 对任意 a1 ≠ a2 ∈ A, f(a1) ≠ f(a2)
   通俗理解: 没有 `不同的人穿同一双鞋`, 每个输出最多被一个输入对应

2. 满射(Surjective 或 onto)
   如果函数 f: A -> B 满足 --- 所有的输出都被至少一个输入映射到, 即: 函数的值域(输出集合)等于目标集合 B, 对任意 b ∈ B, ∃a ∈ A, 使得 f(a) = b
   通俗理解: 目标集合 B 的 `每个位置都有鞋子穿上`, 函数 `覆盖了整个输出集合`
   `B 中每个元素至少有一个 A 元素对应到它`

3. 双射(Bijective)
   函数同时满足 `一一映射` 和 `满射`, 即:
   - 不同输入对应不同输出(单射)
   - 输出集合完全被覆盖(满射)
   通俗理解: 每个人穿一双不同的鞋, 所有鞋都被穿着 --- 一一对应, 没多也没少

4. 单射(Injective, one-to-one)
   `不同的输入，不能得到相同的输出`, 若存在 a1 ≠ a2, 一宝有 f(a1) ≠ f(a2), `不同的 A 元素 → 不同的 B 元素`
  

5. 举例
   ```text
   设: A = {1, 2, 3}, B = {x, y, z}, 共有 3^3 = 27 个函数
   1. 一一映射
      f = {(1, x), (2, y), (3, z)}
      
   2. 满射: B 中每个元素至少有一个 A 元素对应到它
      g = {(1, x), (2, y), (3, z)}
   
   3. 双射: 同时是单射 + 满射
      {(1, x), (2, y), (3, z)}
      
   4. 单射: 不同的 A 元素 → 不同的 B 元素
      i = {(1, x), (2, y), (3, z)}
   ```
   
### 逆函数的存在性(Inverse Function)与函数的可逆性(Invertibility)
1. 逆函数
   如果有一个函数 `f: A -> B`, 把每个 `a ∈ A` 映射到一个唯一的 `b ∈ B`, 记为 `f(a) = b`
   反过来, 定义一个函数 `f⁻¹: B -> A`, 使得 `f⁻¹(b) = a 当且仅当 f(a) = b`, 这就是 `逆函数`。

2. 函数可逆性的条件
   - 不是所有的函数都是逆函数
   - 逆函数存在需要两个条件, 只有当函数既 `满是单射又是满射(即双射, bijection)` 时, 逆函数才存在
     - 单射(Injective): 不同的输入有不同的输出
     ```text
     如果 f(a1) = f(a2), 那么我们没法 `反推回去` 知道输入是哪个
     如:
        f: {1, 2, 3} -> {x, y, z}, f = {(1, x), (2, x), (3, y)}
        这里 1, 2 都映射到 x, 所以 f⁻¹(x) 不知道是 1 还是 2, 逆函数不存在
     ```
     - 满射(Surjective): 值域 `B` 的每个元素都有前驱, 否则 B 中有 `孤岛`, 逆函数没法定义
     ```text
     如:
       f: {1, 2, 3} -> {x, y, z}, f = {(1, x), (2, y), (3, y)}
       这里 z 没有对应元素, 所以 f⁻¹(x) 无法定义
     ```
     
3. 举例
   ```text
   设: A = {1, 2, 3}, B = {x, y, z}
   函数: f = {(1, x), (2, y), (3, z)}
       - 单射 (1,2,3 的结果都不同) ✅
       - 满射(x,y,z 全覆盖) ✅
       - 可逆, 逆函数: f⁻¹ = {(x, 1), {y, 2}, (z, 3}}
   
   函数 g = {(1, x), (2, y), (3, z)}
       - 单射 (1,2 都到 x) ❌
       - 满射(z 没被覆盖) ❌
       - 不可逆
   ```
   
4. 总结
   - 单射: 保证逆函数不会“分叉”
   - 满射: 保证逆函数不会“断裂”
   - 双射 ⇔ 可逆函数

### 合成函数(Composition)
1. 概念
   假设有两个函数:
   - f: A -> B, f 把集合 A 中的元素映射到集合 B
   - g: B -> C, g 再把集合 B 中的元素映射到集合 C
   - `先用 f, 再用 g`, 得到一个新的函数: g ∘ f: A -> C, 定义: (g ∘ f)(a) = g(f(a)), ∀a ∈ A
   
2. 理解方式
   - 可以把它想象成 `流水线`
     - 输入 a -> 先进入 f, 得到 f(a) -> 再送进 g, 输出 g(f(a))
   - 注意: 合成时顺序是 `右边的函数先作用`, 左边的函数后作用, 所以 g ∘ f 读作 `g after f`
   
3. 举例
   ```text
   设: 
   f: {1, 2, 3} -> {a, b}, 定义 f(1) = a, f(2) = b, f(3) = a
   g: {a, b} -> {x, y}, 定义 g(a) = x, g(b) = y
   
   那么:
   (g ∘ f)(1) = g(f(1)) = g(a) = x
   (g ∘ f)(2) = g(f(2)) = g(b) = y
   (g ∘ f)(3) = g(f(3)) = g(a) = x
   
   合成函数: g ∘ f = {(1, x), (2, y), (3, x)}
   ```
   
4. 性质
   - 合成函数本身还是一个函数
   - 结合律: (h ∘ g) ∘ f = h ∘ (g ∘ f)
   - 单位元: 恒等函数 id 与任何函数合成都不改变它

### 恒等函数、常值函数
1. 恒等函数(Identity function)
   在一个集合 A 上, 恒等函数记作: idᴀ: A -> A, idᴀ(x) = x, ∀x ∈ A, 意思是: `输入是什么, 输出就是什么`
   - 如果输入是 3, 输出就是 3
   - 如果输入是 apple, 输出就是 apple
   - 什么都不做的操作
   - f ∘ idᴀ = f, idʙ ∘ f = f, 就像乘法里的 1, 加法里的 0
   
2. 常值函数(Constant function)
   给定集合 A 和集合 B, 如果函数 c: A -> B 满足: c(x) = b₀, ∀x ∈ A, 其中 b₀ ∈ B 是某个固定元素, 那么 c 就叫常值函数
   意思是: 无论输入是什么, 输出总是同一个固定的值
   - c(x) = 5(所有输入都变成 5)
   - c(x) - 'hello', 所有输入都输出 'hello'

3. 对比
   - 恒等函数: 输入啥 -> 输出同样的东西
   - 常值函数: 输入啥 -> 输出同一个固定的东西
   ```text
   在集合 {1, 2, 3} 上, 恒等函数就是: 1 -> 1, 2 -> 2, 3 -> 3
   在同一个集合上, 常值函数(值为 7)就是: 1 -> 7, 2 -> 7, 3 -> 7
   ```

### 函数的限制与扩展(视角理解关系的子集)


## 集合论中的构造方


### 构造新的集合的方式

### 康托尔对角线法及不可数性证明

### 基数(cardinality): 有限集合、可数集合、不可数集合

## 集合运算的代数性质

### 运算的结合律、交换律、分配律

### 对偶性原理（特别在布尔代数和逻辑中也常用）

### 特殊集合（空集、全集、单位集合）的运算规则

## 集合与逻辑的结合（非常重要）

### 用谓词逻辑描述集合（∃, ∀ 等）

### 结合命题逻辑与集合论（如：集合运算和逻辑运算之间的对应关系）