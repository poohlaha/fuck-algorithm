# 单调队列(Monotonic Queue)
  在 `队列的基础上维护单调性`(递增或递减) 的数据结构
  - 在插入新元素时, 会移除队尾破坏单调性的元素, 使得
    - 队列从头到尾 `保持单调递增`(常用于求区间最大值)
    - 队列从头到尾 `保持单调递减`(常用于求区间最大值)
    
1. 特性
   - 单调性
     - `队列内部` 始终保持严格 `递增或递减`
   - 头元素即区间最优值
     - 因为队列维护了区间内可能成为最值的候选，`队头元素` 即当前窗口内 `最大或最小值`
   - `先进先出(FIFO)` + 严格剔除破坏单调性的元素
     - 插入时判断队尾，滑动窗口右移时判断队头是否过期
   
2. 时间复杂度
   - O(N)
     - 每个元素最多 `只进队一次`、`出队一次`(因为若被移除则不再回来)
     - 因此对于长度为 N 的数组或数据流处理，时间复杂度是 `O(N)`

3. 空间复杂度
   - O(K)
     - `K` 为窗口大小(滑动窗口问题中)，队列最多存储 `K` 个元素
     - 若 `不涉及窗口`，`仅维护单调性`，则空间为 `O(N)` 最坏
     
4. 具体使用场景
   - 滑动窗口最大值/最小值
     - 在长度为 N 的数组中, 求每个长度为 K 的滑动窗口中的最大值/最小值
       - 如果用暴力解法，每个窗口需要 `O(K)`，总时间 `O(N * K)`
       - 使用单调队列，可在 O(N) 时间内完成
         - 每滑动一次，若队头元素不在当前窗口则移除
         - 插入新元素时移除破坏单调性的队尾元素
         - `队头` 即当前窗口 `最大/最小值`
       - 真实场景
         - 实时计算过去 5 分钟( k = 300 秒)内的交易最高/最低价格
         - 温度传感器连续 24 小时记录，每分钟输出过去 10 分钟的最高温度
     - 单调栈的在线等价
       - `单调栈` 一般用于 `离线处理下一个更大元素` 等问题，而单调队列用于 `在线流式滑动窗口问题`
       - 如:
         - 判断某连续区间内是否满足 `最大值 - 最小值 <= X`
         - 在每次窗口右移时快速判断是否满足条件
     - 优化 `DP` 的转移
       - 在具有以下形式的 `DP` 中
       - 真实场景:
         - 路径规划问题中，移动窗口内最小代价路径求解
         - 某些带限制的背包 DP 优化
     - 实时流式数据流极值检测
       - 例如在高频交易、监控系统、IoT 数据流中，需要
         - 实时统计过去 T 秒内 CPU 使用率峰值
         - 实时计算网络带宽使用峰值
       - 单调队列能够 `无额外维护数组` 即可 `O(1)` 获取极值

5. 步骤
   - 初始化
     - 创建 `left`、`right` 指针, `left = 0`, `right = k - 1`(k 为窗口大小)
     - 创建 `deque` 空队列, 用于 `递减或递增` 存放 `元素下标`
   - 循环
     - 如果队列 `为空`, `直接插入`
     - 如果队列 `不为空`, `判断队头`
       - `队头下标(deque[0]) >= left`, 没有过期, `继续保留队头`
       - `队头下标(deque[0]) < left`, 过期, 需要 `弹出队头`
     - `检查` 新进入右端点元素(`nums[right]`), 因为 `deque` 是 `递增或递减的`, 需要从 `deque` 队尾弹出所有不满足条件的元素(递增: > 右端点元素, 递减: < 右端点元素)
     - `插入` 右端点元素下标
     - 更新 `left`, `right`(分别 `+ 1`)
   - 总结: `检查队头是否过期，插入右端点保持单调，取队头即极值，滑动窗口更新`

6. 步骤2
   - 初始化
     - 创建 `deque` 空队列, 用于 `递减或递增` 存放 `元素下标`
   - 遍历(`0 ~ nums.len()`)
     - 检查队头是否过期
       - 过期, 弹出队头
       - 不过期, 继续保留队头
     - 从队尾弹出所有小于 `nums[i]` 的值
     - `插入 nums[i]` 的元素下标
     - `i >= k - 1` 时, 记录结果

6. 举例
   ```text
   nums = [1, 3, -1, -3, 5, 3, 6, 7]
   窗口大小: k = 3
   目标: 在每个长度为 3 的滑动窗口中，找到 当前窗口的最大值
   
   1. 初始化
   left = 0
   right = k - 1 = 2
   let max = 0
   单调队列(递减) vec = [] (只存下标)
   window = []
   
   2. 循环
   nums[0, 2]
   -> [1, 3, -1]
   -> i = 0 -> nums[0] = 1 -> vec 为空, 插入 1, vec = [0], window = [1]
   -> i = 1 -> nums[1] = 3 -> vec 是递减, 3 > 1 -> 弹出 1, 插入 3, vec = [1], window = [3]
   -> i = 2 -> nums[2] = -1 -> vec 是递减, -1 < 3 -> 插入 -1, vec = [1, 2], window = [3, -1]
   -> 滑动窗口, left += 1 = 1, right += 1 = 3, max = max(0, 3) = 3
   
   nums[1, 3]
   -> [3, -1, -3]
   -> 需要检查队头是否过期: 1(队头下标) == 1(left), 没有过期, 继续保留队头
   -> vec = [1, 2], window = [3, -1]
   -> 检查新进入的右端点元素 i = 3 -> nums[3] = -3, 下标为 3, vec 是递减, -3 < -1 -> 插入 -3, vec = [1, 2, 3], window = [3, -1, -3]
   -> 滑动窗口, left += 1 = 2, right += 1 = 4, max = max(3, -3) = 3
   
   nums[2, 4]
   -> [-1, -3, 5]
   -> 需要检查队头是否过期: 1(队头下标) < 2(left), 过期, 需要弹出队头
   -> vec[2, 3], window = [-1, -3]
   -> 检查新进入的右端点元素 i = 4 -> nums[4] = 5, 下标为 4, vec 是递减的, 5 > -1, 弹出 -1, 5 > -3, 弹出 -3, 插入 5, vec = [4], window = [5]
   -> 滑动窗口, left += 1 = 3, right += 1 = 5, max = max(5) = 5
   
   -> nums[3, 5]
   -> [-3, 5, 3]
   -> 需要检查队头是否过期: 4(队头下标) > 3(left), 没有过期, 继续保留队头
   -> vec[4], window = [5]
   -> 检查新进入的右端点元素 i = 5 -> nums[5] = 3, vec 是递减, 3 < 5 -> 插入 3, vec = [4, 5], window = [5, 3]
   -> 滑动窗口, left += 1 = 4, right += 1 = 5, max = max(5, 3) = 5
   
   -> nums[4, 6]
   -> [5, 3, 6]
   -> 需要检查队头是否过期: 4(队头下标) == 4(left), 没有过期, 继续保留队头
   -> 检查新进入的右端点元素 i = 6 -> nums[6] = 6, vec 是递减, 6 > 5, 弹出 5, 6 > 3, 弹出 3, 插入 6, vec[6], window = [6]
   -> 滑动窗口, left += 1 = 5, right += 1 = 7, max = max(6) = 6
   
   -> nums[5, 7]
   -> [3, 6, 7] 
   -> 需要检查队头是否过期: 6(队头下标) > 5(left), 没有过期, 继续保留队头
   -> 检查新进入的右端点元素 i = 7 -> nums[7] = 7, vec 是递减, 7 > 6, 弹出 6, 插入 7, vec[7], window = [7]
   -> 滑动窗口, left += 1 = 6, right += 1 = 8, max = max(7) = 7
   
   -> nums[6, 8]
   -> 越界, 结束
   
   通过以上逐步维护单调递减队列，得出窗口最大值依次为: [3, 3, 5, 5, 6, 7]
   ```
   
7. 普通队列 VS 双端队列 VS 单调队列
   - 普通队列
     - FIFO(先进先出)结构
       - 从队尾插入(enqueue)
       - 从队头弹出(dequeue)
     - `不保证元素值有序`
     - 保证元素进入的先后顺序
     - 不支持从队尾弹出或从队头插入
   - 双端队列
     - 从队头插入或弹出
     - 从队尾插入或弹出
     - 支持在两端进行插入和删除
     - `不保证元素值有序`
   - 单调队列
     - 是一种使用 `双端队列(deque)` 实现的特殊结构
     - 保证队列内元素值 `保持单调性(递增或递减)`
     - 在滑动窗口或需要维护区间最大/最小值时使用
     - 递减单调队列: `从队头到队尾，元素值依次递减(用于窗口最大值)`
     - 递增单调队列: `从队头到队尾，元素值依次递增(用于窗口最小值)`
     - `单调队列 = 双端队列 + 保持递增或递减单调性`