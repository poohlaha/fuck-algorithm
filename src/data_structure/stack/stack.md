# 栈(Stack)
  栈是一种受限的线性数据结构, 遵循 `后进先出(LIFO, Last In First Out)` 的原则
  - 后进先出:
    - 最后被压入栈的元素，最先被弹出
    - 只能在 `一端（栈顶）进行插入和删除` 操作
  - 类似于:
    - 📚 书堆最上面的书先被拿走
    - 🥞 煎饼堆最上面的煎饼先被吃走
    - 🧩 undo/redo 操作先撤销最后一步
    
1. 特性
   - 核心操作
     - push: 压入元素到栈顶
     - pop: 弹出栈顶元素
     - top(或 peek): 查看栈顶元素但不弹出
     - isEmpty: 判断栈是否为空
   - 访问限制
     - 不支持随机访问(无法直接访问底部或中间的元素，只能通过 pop 弹到栈顶元素)
     - 栈的操作都在 `常量时间` 完成
   - 先进后出(LIFO)
     - 先放进去的在下面，后放进去的在上面，需要先拿走上面的才能拿到下面的

2. 时间复杂度
   假设使用 `数组或链表`实现(大多数语言标准库栈基于 `动态数组` 实现)
   ```text
   操作          时间复杂度            说明
   push         O(1)                 插入到栈顶
   pop          O(1)                 弹出栈顶元素
   top          O(1)                 查看栈顶元素
   isEmpty      O(1)                 判断是否为空
   ```

3. 空间复杂度
   - O(N), 其中 n 为栈中元素个数(元素越多占用空间越大)

4. 使用场景
   - 括号匹配
     - 用途
       - 检查表达式中括号是否匹配(如 `()` `[]` `{}` 是否有效)
     - 思路
       - 遍历字符串
         - 遇到左括号 `(` `[` `{` -> 入栈
         - 遇到右括号 `(` `]` `}` -> 检查栈顶是否匹配，匹配则弹出，否则报错
       - 最终栈为空, 则匹配有效
   - 函数调用栈(递归)
     - 用途
       - 编程语言执行递归或函数调用时，使用栈来管理上下文和返回地址
     - 思路
       - 每次函数调用时，将返回地址和局部变量等压入栈
       - 函数返回时，从栈中弹出信息恢复调用现场
   - 撤销(Undo)功能
     - 用途
       - 编辑器、IDE、Photoshop 等撤销操作
     - 思路
       - 每次执行操作时，将当前状态压入栈
       - 撤销时从栈中弹出恢复上一次状态
       - redo 功能通常使用另一个栈存储撤销的操作
   - 深度优先搜索(DFS)
     - 用途
       - 图遍历或树遍历的非递归实现
     - 思路
       - 将当前节点压入栈
       - 弹出栈顶节点访问
       - 将其相邻/子节点继续压入栈，重复直到栈为空
   - 逆序输出
     - 用途
       - 在不破坏原有数据的情况下，逆序输出数据
     - 思路
       - 将元素逐个压入栈
       - 再依次弹出，即可实现逆序输出
   - 单调栈(用于区间内最大最小值查询)
     - 接雨水问题
     - 每日温度问题(求下一个更大元素)
     - 利用栈记录递增或递减元素索引，实现 O(n) 时间快速求解
   
5. 举例
   ```text
   括号匹配检查 ({[]}), 想验证括号是否配对完整
   1. 先明确规则
   左括号 `(` `{` `[` 需要匹配对应的右括号 `)` `}` `]`
   必须 `成对且顺序正确`(即内层先关闭)
   用栈来实现, 因为后出现的左括号必须先被关闭, 符合后进先出
   
   2. 准备栈
   想象成一个空的纸盒(栈)，最上面是 `栈顶`
   
   3. 从左到右遍历字符串 `({[]})`
   当前字符：(
   -> 是左括号，放进栈中, 现在栈里是：`(`
   
   当前字符：{
   -> 是左括号，放进栈中, 现在栈里是：`( {`
   
   当前字符：[
   -> 是左括号，放进栈中, 现在栈里是：`( { [`
   
   当前字符：]
   -> 是右括号，需要检查
   -> 栈顶是 [, 匹配, 弹出栈顶, 现在栈里是：`( {`
   
   当前字符：}
   -> 是右括号，需要检查
   -> 栈顶是 {，匹配，弹出栈顶, 现在栈里是：`(`
   
   当前字符：)
   -> 是右括号，需要检查
   -> 栈顶是 (，匹配，弹出栈顶, 现在栈里为空
   
   4. 遍历结束后检查栈
   栈为空 → 表示所有括号完全配对匹配，字符串合法
   ```
   
6. 后进先出、先进先出、先进后出
   - 后进先出(LIFO, Last In First Out)
     - 定义
       - 最后放进去的元素，最先被取出
       - 对应数据结构: 栈(Stack)
     - 形象理解
       - 📚 书堆最上面的书先拿走
       - 🥞 煎饼最上面的先吃
       - 🧩 undo（撤销）操作撤销最后一步
   - 先进先出(FIFO, First In First Out)
     - 定义
       - 最先放进去的元素，最先被取出
       - 对应数据结构: 队列(Queue)
     - 形象理解
       - 🚌 排队上车，先排队的人先上车
       - 🍔 食堂打饭，先排队的人先打饭
       - 打印任务排队打印，先提交的先打印
   - 先进后出(First In Last Out)
     - 这是 `LIFO` 的另一种说法，本质上就是 `后进先出`
   - 双端队列
     - 同时支持 `FIFO` 和 `LIFO`
     
7. 单调栈
   单调栈是栈的一种特殊应用，维护栈内元素在弹出前始终 `保持单调(递增或递减)`
   - 单调递增栈(栈底到栈顶元素递增)
     - 栈内从下到上元素越来越大
     - 用于求 `左/右边第一个比当前元素大的元素`
   - 单调递滅栈(栈底到栈顶元素递减)
     - 栈内从下到上元素越来越小
     - 用于求 `左/右边第一个比当前元素小的元素`
   - 适用场景
     - 下一个更大元素
       - 右侧第一个更大的元素
       - 右侧第一个更小的元素(只需切换栈递增/递减)
     - 接雨水
       - 用单调递减栈找到两侧边界计算积水体积
     - 柱状图最大矩形
       - 使用单调栈快速求解每个柱子左右第一个小于当前高度的位置，以 `O(n)` 求出最大面积
     - 每日温度
       - 求未来几天内第一次比当前温度高的天数
   
8. 举例
   ```text
   mums = [2, 1, 5, 6, 2, 3], 求右侧第一个比当前元素大的元素
   
   1. 初始化空栈, 存索引
   i = 0
   -> nums[0] = 2
   -> 栈为空, 入栈
   -> 栈: [0]
   
   i = 1
   -> nums[1] = 1
   -> 1 < 2, 入栈
   -> 栈: [0, 1]
   
   i = 2
   -> nums[2] = 5
   -> 5 > 1, 弹出 1, 记录 answer[1] = 5
   -> 5 > 2, 弹出 2, 记录 answer[0] = 5
   -> 栈为空, 入栈
   -> 栈: [2]
   
   i = 3
   -> nums[3] = 6
   -> 6 > 5, 弹出 5， 记录 answer[2] = 6
   -> 栈为空, 入栈
   -> 栈: [3]
   
   i = 4
   -> nums[4] = 2
   -> 2 < 6, 入栈
   -> 栈: [3, 4]
   
   i = 5
   -> nums[5] = 3
   -> 3 > 2, 弹出 2, 记录 answer[4] = 3
   -> 3 < 6, 入栈
   -> 栈: [3, 5]
   
   最终: [5, 5, 6, -1, 3, -1]
   
   
   
   ```