/*!
  二叉树
  每个节点最多有两子节点, 被称为 `左子节点` 和 `右子节点`
  - 定义
    - 节点(Node): 树中的基本单元，包含数据部分和指向左右子节点的指针
    - 根节点(Root): 树的起始节点，没有父节点
    - 叶子节点(Leaf): 没有子节点的节点
    - 父节点(Parent): 指向子节点的节点
    - 子节点(Child): 被父节点指向的节点
    - 深度(Depth): 节点到根节点的路径长度
    - 高度(Height): 从节点到最远叶子节点的路径长度
  - 类型
    - 满二叉树(Full Binary Tree): 每个节点要么没有子节点，要么有两个子节点
    - 完全二叉树(Complete Binary Tree): 除了最底层外，其他层的节点都被 `填满`，并且最底层的节点都集中在 `左侧`
      - 完全二叉树的左右子树也是完全二叉树, 完全二叉树的左右子树中，至少有一棵是满二叉树
      - 由于它的节点紧凑排列，如果从左到右从上到下对它的每个节点编号，那么父子节点的索引存在明显的规律
      - 父子节点索引的规律
        假设我们为完全二叉树的节点从上到下、从左到右地进行编号，编号从1开始。那么父子节点之间的关系可以通过索引来表示，存在如下规律
        - 父节点的索引：如果某个节点的索引是i，那么它的父节点的索引是 `i // 2`（整数除法）
        - 左子节点的索引：如果某个节点的索引是i，那么它的左子节点的索引是 `2 * i`
        - 右子节点的索引：如果某个节点的索引是i，那么它的右子节点的索引是 `2 * i + 1`
                  1
                 / \
                2   3
               / \ / \
              4  5 6  7
          按从上到下、从左到右的顺序给每个节点编号, 节点的编号就是：1、2、3、4、5、6、7
          父子节点的关系如下:
          - 节点1（父节点）→ 左子节点：节点2（索引 2 * 1 = 2），右子节点：节点3（索引 2 * 1 + 1 = 3）
          - 节点2（父节点）→ 左子节点：节点4（索引 2 * 2 = 4），右子节点：节点5（索引 2 * 2 + 1 = 5）
          - 节点3（父节点）→ 左子节点：节点6（索引 2 *3 = 6），右子节点：节点7（索引 2 * 3 + 1 = 7）
     - 二叉搜索树(Binary Search Tree，BST)：对于每个节点，左子树的所有节点的值都小于该节点的值，右子树的所有节点的值都大于该节点的值
     - 平衡二叉树（AVL树）：一棵二叉搜索树，要求每个节点的左子树和右子树的高度差不超过1
  - 遍历
    - 前序遍历(Per-order): 根节点 → 左子树 → 右子树
    - 中序遍历(In-order): 左子树 → 根节点 → 右子树
    - 后序遍历(Post-order): 左子树 → 右子树 → 根节点
    - 层序遍历(Level-order): 逐层访问树中的节点
  - 遍历举例
                  50            - 层 1
                 /  \
               30    70         - 层 2
              /  \   /  \
             20   40 60   80    - 层 3
     1. 前序遍历：50 → 30 → 20 → 40 → 70 → 60 → 80    根节点 → 左子树 → 右子树
     2. 中序遍历：20 → 30 → 40 → 50 → 60 → 70 → 80    左子树 → 根节点 → 右子树
     3. 后序遍历：20 → 40 → 30 → 60 → 80 → 70 → 50    左子树(左子节点在最后) → 右子树(右子节点在最后) → 根节点
     4. 层序遍历：50 → 30 → 70 → 20 → 40 → 60 → 80    逐层访问树中的节点
   - 实现
     `链式存储` 和 `顺序存储`
    - 链式存储
      `常见的` 实现方式，通常使用 `节点结构` 来表示每个二叉树的节点, 每个节点保存着数据，并有 `两个指针` 分别指向其 `左子节点` 和 `右子节点`
      - 节点结构
        - 数据部分: 存储节点的值
        - 左子节点指针: 指向左子树
        - 右子节点指针: 指向右子树
      - 优点
        - 灵活性强: 不需要事先知道树的大小，动态分配内存
        - 插入和删除操作高效: 不需要移动其他元素，直接修改指针即可
      - 缺点
        - 指针开销: 每个节点需要额外的指针空间(通常是 2 个指针)，导致空间开销较大
        - 访问速度较慢: 访问节点时需要通过指针访问，相对来说，操作较为耗时
    - 顺序存储
      将二叉树的节点按 `层次` 结构存储在一个`数组` 或 `切片` 中, 通过`数组的下标` 来表示节点的位置, 这种方式通常用于 `完全二叉树`，因为完全二叉树的节点是紧凑排列的，适合使用数组来存储
      - 下标
        - 左子节点: 2i + 1
        - 右子节点: 2i + 2
        - 父节点: (i - 1) / 2（如果 i != 0）
      - 优点
        - 空间效率: 不需要额外的指针开销，数组直接存储节点数据
        - 访问效率: 通过数组下标可以直接访问节点，时间复杂度为 `O(1)`
        - 简单: 实现起来较为简单，尤其是在处理完全二叉树时
      - 缺点
        - 空间浪费: 对于不完全二叉树，可能会浪费数组中的空间，因为数组的大小需要预先确定
        - 插入和删除操作复杂：在数组中插入或删除元素需要移动其他元素，复杂度较高，通常是 `O(n)`
*/

mod link;
mod order;
mod other;
pub mod test;
