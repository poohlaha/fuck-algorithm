/*!
  二叉树
  每个节点最多有两子节点, 被称为 `左子节点` 和 `右子节点`
  - 定义
    - 节点(Node): 树中的基本单元，包含数据部分和指向左右子节点的指针
    - 根节点(Root): 树的起始节点，没有父节点
    - 叶子节点(Leaf): 没有子节点的节点
    - 父节点(Parent): 指向子节点的节点
    - 子节点(Child): 被父节点指向的节点
    - 深度(Depth): 节点到根节点的路径长度
    - 高度(Height): 从节点到最远叶子节点的路径长度
  - 类型
    - 满二叉树(Full Binary Tree): 每个节点要么没有子节点，要么有两个子节点
    - 完全二叉树(Complete Binary Tree): 除了最底层外，其他层的节点都被 `填满`，并且最底层的节点都集中在 `左侧`
      - 完全二叉树的左右子树也是完全二叉树, 完全二叉树的左右子树中，至少有一棵是满二叉树
      - 由于它的节点紧凑排列，如果从左到右从上到下对它的每个节点编号，那么父子节点的索引存在明显的规律
      - 父子节点索引的规律
        假设我们为完全二叉树的节点从上到下、从左到右地进行编号，编号从1开始。那么父子节点之间的关系可以通过索引来表示，存在如下规律
        - 父节点的索引：如果某个节点的索引是i，那么它的父节点的索引是 `i // 2`（整数除法）
        - 左子节点的索引：如果某个节点的索引是i，那么它的左子节点的索引是 `2 * i`
        - 右子节点的索引：如果某个节点的索引是i，那么它的右子节点的索引是 `2 * i + 1`
                  1
                 / \
                2   3
               / \ / \
              4  5 6  7
          按从上到下、从左到右的顺序给每个节点编号, 节点的编号就是：1、2、3、4、5、6、7
          父子节点的关系如下:
          - 节点1（父节点）→ 左子节点：节点2（索引 2 * 1 = 2），右子节点：节点3（索引 2 * 1 + 1 = 3）
          - 节点2（父节点）→ 左子节点：节点4（索引 2 * 2 = 4），右子节点：节点5（索引 2 * 2 + 1 = 5）
          - 节点3（父节点）→ 左子节点：节点6（索引 2 *3 = 6），右子节点：节点7（索引 2 * 3 + 1 = 7）
     - 二叉搜索树(Binary Search Tree，BST)：对于每个节点，左子树的所有节点的值都小于该节点的值，右子树的所有节点的值都大于该节点的值
     - 平衡二叉树（AVL树）：一棵二叉搜索树，要求每个节点的左子树和右子树的高度差不超过1
  - 遍历
    - 前序遍历(Per-order): 根节点 → 左子树 → 右子树
    - 中序遍历(In-order): 左子树 → 根节点 → 右子树
    - 后序遍历(Post-order): 左子树 → 右子树 → 根节点
    - 层序遍历(Level-order): 逐层访问树中的节点
  - 遍历举例
                  50            - 层 1
                 /  \
               30    70         - 层 2
              /  \   /  \
             20   40 60   80    - 层 3
     1. 前序遍历：50 → 30 → 20 → 40 → 70 → 60 → 80    根节点 → 左子树 → 右子树
     2. 中序遍历：20 → 30 → 40 → 50 → 60 → 70 → 80    左子树 → 根节点 → 右子树
     3. 后序遍历：20 → 40 → 30 → 60 → 80 → 70 → 50    左子树(左子节点在最后) → 右子树(右子节点在最后) → 根节点
     4. 层序遍历：50 → 30 → 70 → 20 → 40 → 60 → 80    逐层访问树中的节点
   - 实现
     `链式存储` 和 `顺序存储`
    - 链式存储
      `常见的` 实现方式，通常使用 `节点结构` 来表示每个二叉树的节点, 每个节点保存着数据，并有 `两个指针` 分别指向其 `左子节点` 和 `右子节点`
      - 节点结构
        - 数据部分: 存储节点的值
        - 左子节点指针: 指向左子树
        - 右子节点指针: 指向右子树
      - 优点
        - 灵活性强: 不需要事先知道树的大小，动态分配内存
        - 插入和删除操作高效: 不需要移动其他元素，直接修改指针即可
      - 缺点
        - 指针开销: 每个节点需要额外的指针空间(通常是 2 个指针)，导致空间开销较大
        - 访问速度较慢: 访问节点时需要通过指针访问，相对来说，操作较为耗时
    - 顺序存储
      将二叉树的节点按 `层次` 结构存储在一个`数组` 或 `切片` 中, 通过`数组的下标` 来表示节点的位置, 这种方式通常用于 `完全二叉树`，因为完全二叉树的节点是紧凑排列的，适合使用数组来存储
      - 下标
        - 左子节点: 2i + 1
        - 右子节点: 2i + 2
        - 父节点: (i - 1) / 2（如果 i != 0）
      - 优点
        - 空间效率: 不需要额外的指针开销，数组直接存储节点数据
        - 访问效率: 通过数组下标可以直接访问节点，时间复杂度为 `O(1)`
        - 简单: 实现起来较为简单，尤其是在处理完全二叉树时
      - 缺点
        - 空间浪费: 对于不完全二叉树，可能会浪费数组中的空间，因为数组的大小需要预先确定
        - 插入和删除操作复杂：在数组中插入或删除元素需要移动其他元素，复杂度较高，通常是 `O(n)`

    1. DFS(Depth-First Search, 深度优先搜索)
       - 特点
         - 一条路走到底，走不通再回溯
         - 使用 `递归` 或 `栈` 结构
         - 适用于 `路径搜索`、`拓扑排序`、`连通分量查找` 等
       - 实现方式(前序遍历, 根 → 左 → 右)
         - 访问 `当前节点`
         - 递归访问 `左子树(或下一个子节点)`
         - 递归访问 `右子树(或其他未访问节点)`
       - 使用
         - 搜索所有可能的路径(Backtracking，回溯算法)
           - 迷宫路径搜索
           - 组合问题(N 皇后、子集、排列)
         - 树的遍历(前序、中序、后序)
         - 需要占用较少内存(DFS 使用递归栈，通常比 BFS 省空间)

    2. BFS (Breadth First Search, 广度优先搜索)
       - 特点
         - 按层遍历，每一层的所有节点访问完后再进入下一层
         - 使用 `队列(Queue)` 结构，先进先出(FIFO)
         - 适用于 `最短路径搜索`、`层次遍历`、`网络流` 等
       - 实现方式(层序遍历)
         - 将 `根节点`入队
         - 队列不为空时
           - 取出 `队首节点`，访问它
           - 将其`左右子节点入队`
           - 继续处理下一个节点
       - 使用
         - 求最短路径(如无权图的最短路径)
         - 需要逐层扩展(如社交网络中的朋友推荐)
         - 目标节点比较靠近起点(避免 DFS 走太深)

      类型                     特点
    满二叉树	      每个节点要么有两个子节点，要么没有
    完全二叉树	  最后一层的节点从左到右填充
    完美二叉树	  所有叶子节点在同一层
    平衡二叉树	  任意节点左右子树高度差 ≤ 1
    二叉搜索树	  左小右大，O(log n) 查询
    自平衡 BST	  通过旋转保持平衡，避免退化
    退化二叉树	  退化成链表，O(n) 查询
    哈夫曼树	      最优数据编码，常用于压缩
    不同类型的二叉树适用于不同的场景:
     - 查找快：二叉搜索树（BST）、红黑树（RB Tree）
     - 存储结构稳定：完全二叉树、平衡二叉树
     - 压缩编码：哈夫曼树
*/

mod bbt;
mod bst;
mod order;
pub mod other;
pub mod test;
