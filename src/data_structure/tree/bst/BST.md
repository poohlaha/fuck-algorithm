# 二叉搜索树(Binary Search Tree，简称 BST)
1. 特点
    - `左子树` 的所有节点的值都 `小于根节点` 的值
    - `右子树` 的所有节点的值都 `大于根节点` 的值
    - `左、右子树` 本身也都是 `二叉搜索树(递归定义)`

2. 时间复杂度
    - 插入: O(log n), 最坏情况(退化成链表) O(n)
    - 查找: O(log n), 最坏情况(退化成链表) O(n)
    - 删除: O(log n), 最坏情况(退化成链表) O(n)
   
3. 优势/劣势
   - 优势
     - 查找、插入、删除时间复杂度平均 O(log n)，比普通链表快
     - 中序遍历(LDR) 可得到一个有序数组
   - 劣势
    - 最坏情况可能退化成链表(如顺序插入 1, 2, 3, 4, 5)
    - 不支持 O(1) 查找最小/最大值(需要遍历到最左/最右节点)
    - 删除节点时需要调整结构，可能影响平衡性

4. 使用场景
    - 数据查找与存储
      - 符号表(Symbol Table): 编译器使用 BST(如AVL 树或红黑树)存储变量、函数符号等
      - 字典(Dictionary): BST可以用于实现动态字典, 如拼写检查, 自动补全等
      - 电话号码簿: 存储联系人信息, 并支持快速查找
      ps:
      - 适合 BST 的数据
        - 需要 `频繁查找`和 `更新` 的动态数据集
        - 数据具有一定的有序性(可以高效排序)
      - 不适合 BST 的数据
        - 如果 `仅需要查找`，可以用 `哈希表 (0(1)` 代替
        - `频繁删除数据` 时，BST 可能需要额外的平衡调整(如 AVL 旋转)

    - 排序(Tree Sort)
      - BST 天然支持排序，因为 `中序遍历(左 - 根 - 右)` 可以得到一个递增的 `有序序列`，可以用于 `Tree Sort 排序算法`
        示例:
        输入数组 [5, 3, 7, 2, 4, 6, 8]，构造 BST:
        ```
             5
            / \
           3   7
          / \  / \
         2   4 6  8
        ```
        对 BST 进行 `中序遍历`，得到有序数组 [2, 3, 4, 5, 6, 7, 8]
      
      - 适用于:
        - 需要在排序的同时支持 `快速查找` 和 `删除`
        - 适用于大规模动态数据集
      - 不适用于
        - `纯粹排序场景`，如快速排序（O(n log n)）更简单，且无需额外存储结构

      ```
      | 场景                     | 适合BST |	 更优方案             |
      |-------------------------|---------|----------------------|
      | 动态数据存储(符号表、字典)  | 	 ✅	  |  哈希表（如果不需要排序）|
      | 排序(Tree Sort)          |    ✅   | 快速排序（更简单）      |
      | 数据库索引(B+ 树)         |  	 ❌	  |  B+ 树（更高效）       |
      | 自动补全、前缀匹配	        |    ✅   |  Trie（字典树）        |
      | 事件调度 & 任务管理	    |    ✅	  |  堆（如果只需最大/最小值）|
      | 网络路由表(IP 查找)       |    ✅	  |  Trie（前缀匹配更快）    |
      ```
      
5. 如何优化 BST
  - 自平衡 BST(如 AVL 树、红黑树): 避免退化为链表，保证 O(log n) 操作
  - Treap、Splay 树：通过随机或访问频率进行自平衡
  - ps: 对于高效查找、大量插入删除操作的场景，通常使用 `红黑树` 或 `跳表(Skip List)`

  - 示例:
    [8, 3, 10, 1, 6, 14, 4, 7, 13]

    ```
         8
        / \
       3   10
      / \    \
     1   6    14
        / \   /
       4   7 13
    ```
   - 构造过程
     - 插入 8，作为根节点
     - 插入 3，比 8 小，放在左子树
     - 插入 10，比 8 大，放在右子树
     - 插入 1，比 8、3 都小，放在 3 的左子树
     - 插入 6，比 8 小，但比 3 大，放在 3 的右子树
     - 插入 14，比 8、10 都大，放在 10 的右子树
     - 插入 4，比 8、3 大，但比 6 小，放在 6 的左子树
     - 插入 7，比 8、3 大，但比 6 大，放在 6 的右子树
     - 插入 13，比 8、10 大，但比 14 小，放在 14 的左子树
     
   - 查找节点
     目标: 查找 `7`
     - 从 8 开始，7 < 8，向左子树查找
     - 进入 3，7 > 3，向右子树查找
     - 进入 6，7 > 6，向右子树查找
     - 找到 7，查找成功
   时间复杂度： 平均情况 O(log n)，最坏情况(退化成链表) O(n)  
   
   - 插入节点  
     目标：插入 `5`
     - 5 < 8，进入左子树 3
     - 5 > 3，进入右子树 6
     - 5 < 6，进入左子树 4
     - 5 > 4，放在 4 的右子树
     ```
         8
        / \
       3   10
      / \    \
     1   6    14
        / \   /
       4   7 13
        \
         5
     ```
     时间复杂度： 平均情况 O(log n)，最坏情况(退化成链表) O(n)  

   - 删除节点
     目标：删除 `6`
     - 6 有两个子节点 4 和 7，需要找到 `右子树的最小节点(后继)` 来替换它
     - 7 是 6 的右子树中最小的节点，用 7 替换 6，然后删除 7
     ```
        8
       / \
      3   10
     / \    \
    1   7    14
       /    /
      4    13
       \
        5
     ```
   时间复杂度： 平均情况 O(log n)，最坏情况(退化成链表) O(n)

6. 什么是二叉搜索树（BST）的“退化成链表”情况?
   当 `二叉搜索树（BST）在插入元素时不平衡，所有新节点都插入到同一侧` ，就会导致 `树退化成链表`，从而使查找、插入、删除的时间复杂度从 `O(log n)` 变成 `O(n)`
   - 正常的 BST 树
    [8, 3, 10, 1, 6, 14, 4, 7, 13]

    ```
      8
     / \
    3   10
   /  \    \
   1   6    14
      / \   /
     4   7 13
    ```
  
    - 查找、插入、删除的时间复杂度平均为 O(log n)
    - 树的高度较小（接近 log n），查询效率高
   
  - BST 退化成链表的情况
   - 以递增顺序插入 [1, 2, 3, 4, 5, 6, 7]
   ```
    1
     \
      2
       \
        3
         \
          4
           \
            5
             \
              6
               \
                7
   ```
   - 变成了一条 `单链表`，树的高度变成 `n` ，所有操作（查找、插入、删除）都需要 `O(n)` 的时间
  - 递减顺序插入 [7, 6, 5, 4, 3, 2, 1]
  ```
  7
  /
  6
  /
  5
  /
  4
  /
  3
  /
  2
  /
  1
  ```
         
   - 树的高度 = 节点数（n），最坏情况下操作时间复杂度 O(n)
   - 失去了 BST 的“对数级”查找优势，性能变差

7. 如何避免 BST 退化成链表？
   - 采用自平衡二叉搜索树
   自平衡 BST 可以在插入和删除时自动调整结构，保持接近 O(log n) 的高度
   常见的自平衡 BST:
    - AVL 树（严格平衡，每次插入后可能需要旋转）
    - 红黑树（稍微放宽平衡要求，但插入、删除的性能更稳定）
    - Treap（利用随机优先级进行平衡）
   - 采用平衡插入策略
     如果提前知道数据是有序的，可以使用 `平衡插入策略`（如构造 `完全二叉搜索树`），避免所有节点插入到同一侧。例如：
     - 随机打乱数据，再构造 BST
     - 一次性构造平衡 BST（如利用有序数组递归构造）
  - 使用其他数据结构
    如果你的应用需要 `高效的插入`、`查找`、`删除`，并且可能遇到大量有序数据，建议:
    - 使用平衡 BST（如红黑树）
    - 使用跳表（Skip List）：提供类似 BST 的 O(log n) 查询时间，但结构更简单
    - 使用哈希表（HashMap）：如果仅需快速查找，不要求有序数据
  总结:
  - BST 退化成链表时，树的高度变为 O(n)，导致查找、插入、删除的性能下降到 O(n)
  - 当数据是单调递增或单调递减时，普通 BST 很容易退化成链表。
  - 可以通过自平衡 BST（如 AVL 树、红黑树）或跳表等方式避免退化，提高查询效率。