# 线段树(Segment Tree)
   线段树是一种用于 `解决区间(区段)` 相关问题的数据结构
   - 它是一棵 `二叉树`，`每个节点` 表示 `一个区间`
   - `叶子节点` 表示 `原始序列的单个元素`
   - `内部节点` 表示 `若干个叶子节点的区间合并结果`(如 `区间和`、`区间最大值`、`最小值` 等)

1. 特性
   - 支持快速的区间查询
   - 支持动态更新(例如修改某个元素值)
   - 分治思想: 每次将问题拆成左右两个子问题
   - 树高 `h = log₂ n`(因为 `每次二分区间`, `树高` `约 log n`)
   - 占用空间为 `O(n)`, 通常会使用 `4n` 大小的 `数组`(`方便二叉树索引`)

2. 时间复杂度
   线段树比朴素遍历查询 `O(n)` 快得多的原因
   - 建树: O(n)
   - 区间查询: O(log n)
   - 单点更新: O(log n)
   - 区间更新(懒惰标记): O(log n)(或更高)

3. 使用场景
   线段树的应用非常广泛, 常见于 `需要高效查询` 和 `修改区间` 的场景, 比如:
   - 区间和 / 区间最大值 / 区间最小值查询
     - 在一个数组中，快速求出任意区间 `[l, r]` 的 `和` 或 `最大值`
   - 动态区间更新
     - 数组某个元素变化后, 如何快速更新整棵树并保持区间查询正确性
   - 动态开点 / 区间修改
     - 在一些更复杂的题目中，线段树支持 `区间加值`、`区间赋值` 等操作(这时需要 `懒惰标记(Lazy Propagation)` 技术)
   - 数列处理
     - 股票价格变动，动态查询某段时间的最大/最小价格; 游戏中排行榜区间的实时维护等

4. 举例
   ```text
   假设有数组: [2, 1, 5, 3, 4]
   目标:
     - 查询: 任意区间 `[l, r]` 的和
     - 修改: 把某个位置的数值修改为新值
     - 修改: 把某个位置的值加上 / 减去
   ```
   
   - 拆分原则:
     - 左孩子: [l, mid]
     - 右孩子: [mid + 1, r]
     
   - 步骤 
     - 建树
     ```text
       1. 根节点: 区间 `[0, 4]`
          - 区间 `[0, 4]` 包含值: [2, 1, 5, 3, 4]
          - 不是叶子节点, 继续拆分
            - 中间值: (0 + 4) / 2 = 2
            - 左孩子: [0, 2]
            - 右孩子: [3, 4]
     
       2. 拆分根节点左孩子: [0, 2],
           - 包含值: [2, 1, 5]
           - 不是叶子节点, 继续拆分
             - 中间值: (0 + 2) / 2 = 1
             - 左孩子: [0, 1]
             - 右孩子: [2, 2]
       
       3. 继续拆分左孩子: [0, 1]
          - 包含值: [2, 1]
          - 不是叶子节点, 继续拆分
            - 中间值 (0 + 1) / 2 = 1 / 2 = 0 (向下取整)
            - 左孩子: [0, 0](只包含 2, 是叶子节点)
            - 右孩子: [1, 1](只包含 1, 是叶子节点)
       
       4. 回溯并计算父节点的值: [0, 1]
          - 左孩子: [0, 0] = 2
          - 右孩子: [1, 1] = 1
          - 父节点: [0, 1] = [0, 0] + [1, 1] = 2 + 1 = 3
     
       5. 右孩子: [2, 2]
          - 包含值: [2, 2] = 5
          - 是叶子节点
     
       6. 回溯并计算父节点的值: [0, 2]
          - 左孩子: [0, 1] = 3
          - 右孩子: [2, 2] = 5
          - 父节点: [0, 2] = [0, 1] + [2, 2] = 3 + 5 = 8
     
       7. 拆分根节点右孩子: [3, 4]
          - 包含值: [3, 4]
          - 不是叶子节点, 继续拆分
            - 中间值: (3 + 4) / 2 = 3
            - 左孩子: [3, 3](只包含 3, 是叶子节点)
            - 右孩子: [4, 4](只包含 4, 是叶子节点)
     
       8. 回溯并计算父节点的值: [3, 4]
          - 左孩子: [3, 3] = 3
          - 右孩子: [4, 4] = 4
          - 父节点: [3, 4] = [3, 3] + [4, 4] = 3 + 3 = 7
     
       9. 回溯并计算父节点的值: [0, 4](根节点)
          - 左孩子: [0, 2] = 8
          - 右孩子: [3, 4] = 4
          - 父节点: [0, 4] = [0, 2] + [3, 4] = 8 + 7 = 15    
       
       10. 线段数
                          [0,4]=15
                      /               \
                [0,2]=8                   [3,4]=7
               /       \                  /      \
          [0,1]=3       [2,2]=5       [3,3]=3    [4,4]=4
          /      \
       [0,0]=2  [1,1]=1

       ```
   
     - 查询 
       - 查询区间和 `[1, 3]`
       - 查询目标: 区间 `[1, 3]` -> `[1, 1] = 1` + `[2, 2] = 5` + `[3, 3] = 3` = `9`
       - 过程
       ```text
       1. 查询从根节点 `[0, 4]` 开始  
          根节点: [0, 4] = 15
          - 当前节点区间: [0, 4]
          - 目标查询区间: [1, 3]
          - 二者有交集, 也不是完全包含 -> 递归往左右孩子查询
       
       2. 递归左孩子: [0, 2]
          左孩子: [0, 2] = 8
          - 当前节点区间: [0, 2]
          - 目标 `[1, 3]` -> 与 `[0, 2]` 有交集 -> 继续递归
       
       3. 接着递归左孩子 `[0, 1]`
          - `[0, 1]` 和 `[1, 3]` 有交集 -> 继续递归
       
       4. 接着递归左孩子 `[0, 0]`
          - 当前 `[0, 0]`
          - `[0, 0]` 不在 `[1, 3]`  -> 返回 `0`
       
       5. 递归右孩子 `[1, 1]`
          - 当前 `[1, 1]`
          - `[1, 1]` 被 `[1, 3]` 完全包含 ➜ 返回 `1`(直接用当前节点值)
       
       6. 回溯 `[0, 1]`
          - `[0, 1]` -> 左边返回 `0`, 右边返回 `1` -> 和为 `1`
       
       7. 接着递归右孩子 `[2, 2]`
          - 当前 `[2, 2]`
          - `[2, 2]` 被 `[1, 3]` 完全包含 ➜ 返回 `5`
       
       8. 回溯 `[0, 2]` 
          - 左孩子 `[0, 1]`, 返回 `1`
          - 右孩子 `[2, 2]`, 返回 `5`
          - 和为 `1 + 5 = 6`
       
       9. 递归根节点右孩子: `[3, 4]`
          - 当前 [3, 4] = 7
          - `[3, 4]` 和 `[1, 3]` 有交集 ➜ 继续递归
       
       10. 递归左孩子: `[3, 3]`
          - `[3, 3]` 在 `[1, 3]` 内 ➜ 返回 `3`
       
       11. 递归右孩子: `[4, 4]`
           - `[4, 4]` 不在 `[1, 3]` 内 ➜ 返回 `0`
       
       13. 回溯 `[3, 4]`
           - 左孩子 `[3, 3]`, 返回 `3`
           - 右孩子 `[4, 4]`, 返回 `0`
           - 和为 `3 + 0 = 3`
       
       14. 回溯根节点 `[0, 4]`
          - 左孩子 `[0, 2]`, 返回 `6`
          - 右孩子 `[3, 4]`, 返回 `3`
          - 最终查询和为 `6 + 3 = 9`
       ```
       - 总结
         查询从根节点开始, 有以下三种情况
         - 完全不重叠 -> 返回 `0`
         - 完全包含 -> 返回 `当前节点值(不用递归)`
         - 部分重叠 -> 递归 `左孩子` 和 `右孩子`
       
     - 修改
       - 总结
         修改从根节点开始, 有以下三种情况
         - 完全不重叠 -> 跳过
         - 完全包含 -> 直接 `打懒惰标记` 并 `更新当前 sum`
         - 部分重叠 -> `递归下传懒惰标记` 后 `递归更新` `左孩子` 和 `右孩子`
         - `sum += 区间长度 * val` 是 `快速更新节点和`(`预估` `这个子区间将来会加多少值`, `提前更新 sum`)
       - 找到要修改的 `叶子节点`
       - 把 `叶子节点` 改成 `新值`
       - 沿着 `父节点向上更新` 它们的 `区间和`
     ```text
     目标: 把下标 `2(原本是 5)` 改成 `10`
     修改前:
                           [0,4]=15
                      /               \
                [0,2]=8                [3,4]=7
               /       \              /      \
         [0,1]=3       [2,2]=5    [3,3]=3    [4,4]=4
         /      \
      [0,0]=2  [1,1]=1

     修改下标 2 = 10 后:
                            [0,4]=20
                         /               \
                   [0,2]=13             [3,4]=7
                 /       \              /       \
            [0,1]=3     [2,2]=10    [3,3]=3    [4,4]=4
           /      \
       [0,0]=2  [1,1]=1
     ```

5. `懒惰标记(Lazy Propagation)` 是什么？
   - 在使用线段树时，如果我们需要执行区间更新操作(比如 `把某个区间的所有元素都加上一个值` ), 就面临一个问题:
     - 直接修改区间内所有叶子节点，代价很大(`O(n)`)，失去了线段树的效率优势
     - 但是，更新操作在大多数情况下只需要在 `以后查询` 或 `进一步更新这个区间` 时再去细化
   - 核心思想
     - 先把更新的信息 `懒惰` 地存在父节点里, `不立刻更新` 子节点
     - 当后续需要查询或更新子节点时，再把 `懒惰信息` 传递(`下推`)给它们
   - 概念
    - 懒惰标记数组
      - 通常和线段树数组 `tree[]` 并行地维护一个 `lazy[]` 数组，存放 `懒惰信息`
    - 下推(Push Down)
      - 当访问到一个节点(查询或继续更新) 时，先看它有没有懒惰标记:
        - 有: 把它的 `懒惰信息` 传给 `左右孩子（更新子节点和它们的懒惰标记）`, 并 `清空自己`
        - 没有: 直接继续处理
    - 时间复杂度
      - 由于每次懒惰信息只在 `访问时下推`, 区间更新和查询仍然是 `O(log n)`
   ```text
   假设数组: [1, 2, 3, 4, 5]
   目标：
     - 区间求和
     - 区间加法(将 `[l, r]` 区间的所有元素都加上 `x`)
   
   现将 `[1, 3]`` 区间所有元素加上 `10`
   - 一般做法
     直接更新叶子节点: [1, 12, 13, 14, 5], 此时更新 `[1,3]` 需要分别更新 `[1]`、`[2]`、`[3]` 的值, 代价较高
   
   - 懒惰标记做法
     - 不立即更新 `[1]`、`[2]`、`[3]`，而是在表示 `[1, 3`] 的节点上打一个 `懒惰标记`
       - lazy[1, 3] = 10
       - 表示: 这个区间将来需要加上 `10`
     - 后续
       - 查询 [1,3] 的区间和
       - 查询 [2,2] 的单点值
       - 或更新 [2,4] 区间时
       - 再把这个 `加 10` 的懒惰信息往 `下推` 给子节点, 保证它们的值是正确的
   ```
   - 举例
   ```text
   假设: [1, 2, 3, 4, 5]
   目标:
     - 区间更新: 将 `[1, 3]` 加上 `10`
     - 查询: `[2, 2]` (也就是 arr[2]
   
   步骤:
   1. 更新 `[1, 3`] 加上 `10`
      - 线段树节点 `[1, 3]` (或覆盖它的更大节点) 被打上 `lazy = 10` 标记, 不立刻更新下面的所有节点
   2. 查询 `[2, 2]`
      - 需要访问节点 `[1, 3]`
      - 发现它有 `lazy = 10`, 先把 `lazy = 10` 下推给左右孩子:
        - 左孩子 `[1, 2]` 加上 `10`
        - 右孩子 `[3, 3]` 加上 `10`
      - 把自身 `lazy = 10` 清空
      - 继续往下, 直到 `[2, 2]`, 最终: `[2] = 3 + 10 = 13`
   ```
   
   - 总结:
     - 优点
       - 省去了立即更新所有子节点的开销，保持了高效的 `O(log n)`
       - 在 `多次区间更新` + `查询混合` 操作时非常有用
     - 局限
       - 代码复杂度提高，需要额外管理 `lazy[]` 和正确的下推逻辑
       - 适合 `可合并` 的更新操作(`加、乘、覆盖等`)
   
   
  