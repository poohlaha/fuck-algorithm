# Merkle 树(Merkle Tree)
  Merkle 树, 又称 `哈希树`, 是一种 `树形数据结构`, 这种结构可以高效、安全地验证任意一部分数据的完整性和一致性
  - `叶子节点` 是 `数据的哈希值`, 
  - `父节点` 是 `其子节点哈希值的哈希`
  - `根节点` 称为 `Merkle根(Merkle Root)`
  - 如果 `当前层节点数` 为 `奇数`, `复制当前层` 的 `最后一个节点`

1. 特性
   - 完整性校验
     - 任何数据块的更改都会导致其哈希变化，进而影响所有父节点直至根节点
   - 高效验证
     - 只需 `O(log n)` 级别的数据就能验证某个数据块是否存在于树中
   - 抗篡改性强
     - 哈希不可逆且具抗碰撞性，使数据块被篡改后难以伪造相同 Merkle 根
   - 节省带宽
     - 不必传输所有数据，只需必要哈希路径就能完成验证
   - 结构稳定
     - 插入/删除/验证时对整体结构影响较小，且有固定方式生成

2. 时间复杂度
   其中 `n` 是 `叶子节点的个数（数据块数）`，因为树是 `二叉结构`，高度是 `log n`
   - 构建 `Merkle` 树: `O(n)`
   - 验证数据是否存在: `O(log n)`
   - 获取 `Merkle` 根: `O(1)`
   - 数据修改更新树: `O(log n)`

3. 使用场景
   - 区块链(比特币、以太坊)
     - 比特币中，一个区块可包含上千个交易，每个交易被哈希后构成 Merkle 树
     - 区块头只需记录 `Merkle Root`
     - 轻节点 (`SPV 节点`) 可通过 `Merkle` 路径验证一笔交易是否包含在区块中，而无需下载完整区块
   - Git 版本控制
     - Git 以一种简化的 `Merkle` 树结构组织内容(称为 `Merkle DAG`)
     - 每个提交是 `根节点`，指向 `树节点(文件夹)`，`每个树节点` 再指向 `blob(文件内容)`
     - 所有内容变化都会引发哈希变化，便于追踪版本和检测变化
   - 分布式存储(IPFS、Amazon Dynamo)
     - 将 `大文件分片`，每片生成哈希构建 `Merkle 树`
     - 客户端可验证接收到的部分数据是否正确、是否为某个完整文件的组成部分
     - 不需要下载整个文件，也可以校验局部正确性

4. 举例
   用 `Merkle` 树验证区块中某笔交易存在性(比特币)
   - 比特币中 Merkle 树的作用
     - 在比特币中，每一个区块都包含许多交易(`Transaction`)，这些交易会被哈希后组成一个 `Merkle` 树, 区块头中记录的仅是 `Merkle 根`(`Merkle Root`)
     - 验证某笔交易是否属于某个区块时，不需要所有交易，只要提供这笔交易的 `Merkle 路径`，就能高效验证其合法性
   - 构建 `Merkle` 树
     - 假设有 `n` 笔交易 (一般为 `2` 的幂, 为方便构建完全二叉树, 如果不是则最后一项复制末尾交易补足)
   ```text
   1. 对每笔交易进行哈希(在比特币中为两次 SHA256)
   H1 = hash(T1)
   H2 = hash(T2)
   H3 = hash(T3)
   H4 = hash(T4)  
   
   2. 每两个合并, 再哈希得到父节点
   H12 = hash(H1 + H2)
   H34 = hash(H3 + H4)
   
   3. 继续向上合并
   Markle Root = hash(H12 + H34)
   
   4. 最终
         Merkle Root
           /     \
       H12       H34
      /   \     /   \
    H1    H2   H3   H4
   
   如果交易数不是2的幂, 如有 5 笔交易, 最后一笔会被复制补足, 例如: [T1, T2, T3, T4, T5] -> 变为 [T1, T2, T3, T4, T5, T5, T5](或者按实际处理规则)
   ```
   - 插入交易
     `Merkle` 树本身不是动态插入结构(不像平衡二叉树)，一般在比特币中
     若要构建可插入的 `Merkle 树`, 需要 `每次插入后重建对应路径的哈希`，代价是 `O(log n)`
     - `Merkle 树` 一次性构建于区块生成时
     - 区块生成后就不再更改交易，因此不会进行 `动态插入`
     
   - 查询(`验证某笔交易是否存在`)
     - 不需要所有交易，只需要这笔交易的 `哈希路径`
   ```text
        Merkle Root
           /     \
       H12       H34
      /   \     /   \
    H1    H2   H3   H4
   目标: 验证交易 `T3` 是否属于这棵 `Merkle 树`
   步骤:
   1. 获取 T3 的哈希: H3 = hash(T3)
   2. 提供的 `Merkle 路径` 包括:
      - H4(H3 的兄弟)
      - H12(H34 的兄弟)
   3. 验证过程
      - H3 = hash(T3)
      - H33 = hash(H3 + H4)
      - Merkle Root = hash(H12 + H34)
   4. 比对计算出来的 Merkle Root 与区块头中的一致，说明 T3 存在于该区块中
   5. 为什么效率高？
      - 不需要下载整个区块, 只需要 log2(n) 个哈希值
      - 比如 `1024` 笔交易, 仅需 10 个哈希 + 交易数据本身就能验证
   ```
     



