# Merkle 树(Merkle Tree)
  Merkle 树, 又称 `哈希树`, 是一种 `树形数据结构`, 这种结构可以高效、安全地验证任意一部分数据的完整性和一致性
  - `叶子节点` 是 `数据的哈希值`, 
  - `父节点` 是 `其子节点哈希值的哈希`
  - `根节点` 称为 `Merkle根(Merkle Root)`
  - 如果 `当前层节点数` 为 `奇数`, `复制当前层` 的 `最后一个节点`

1. 特性
   - 完整性校验
     - 任何数据块的更改都会导致其哈希变化，进而影响所有父节点直至根节点
   - 高效验证
     - 只需 `O(log n)` 级别的数据就能验证某个数据块是否存在于树中
   - 抗篡改性强
     - 哈希不可逆且具抗碰撞性，使数据块被篡改后难以伪造相同 Merkle 根
   - 节省带宽
     - 不必传输所有数据，只需必要哈希路径就能完成验证
   - 结构稳定
     - 插入/删除/验证时对整体结构影响较小，且有固定方式生成

2. 时间复杂度
   其中 `n` 是 `叶子节点的个数（数据块数）`，因为树是 `二叉结构`，高度是 `log n`
   - 构建 `Merkle` 树: `O(n)`
   - 验证数据是否存在: `O(log n)`
   - 获取 `Merkle` 根: `O(1)`
   - 数据修改更新树: `O(log n)`

3. 使用场景
   - 区块链(比特币、以太坊)
     - 比特币中，一个区块可包含上千个交易，每个交易被哈希后构成 Merkle 树
     - 区块头只需记录 `Merkle Root`
     - 轻节点 (`SPV 节点`) 可通过 `Merkle` 路径验证一笔交易是否包含在区块中，而无需下载完整区块
   - Git 版本控制
     - Git 以一种简化的 `Merkle` 树结构组织内容(称为 `Merkle DAG`)
     - 每个提交是 `根节点`，指向 `树节点(文件夹)`，`每个树节点` 再指向 `blob(文件内容)`
     - 所有内容变化都会引发哈希变化，便于追踪版本和检测变化
   - 分布式存储(IPFS、Amazon Dynamo)
     - 将 `大文件分片`，每片生成哈希构建 `Merkle 树`
     - 客户端可验证接收到的部分数据是否正确、是否为某个完整文件的组成部分
     - 不需要下载整个文件，也可以校验局部正确性

4. 举例
   用 `Merkle` 树验证区块中某笔交易存在性(比特币)
   - 比特币中 Merkle 树的作用
     - 在比特币中，每一个区块都包含许多交易(`Transaction`)，这些交易会被哈希后组成一个 `Merkle` 树, 区块头中记录的仅是 `Merkle 根`(`Merkle Root`)
     - 验证某笔交易是否属于某个区块时，不需要所有交易，只要提供这笔交易的 `Merkle 路径`，就能高效验证其合法性
   - 构建 `Merkle` 树
     - 假设有 `n` 笔交易 (一般为 `2` 的幂, 为方便构建完全二叉树, 如果不是则最后一项复制末尾交易补足)
   ```text
   1. 对每笔交易进行哈希(在比特币中为两次 SHA256)
   H1 = hash(T1)
   H2 = hash(T2)
   H3 = hash(T3)
   H4 = hash(T4)  
   
   2. 每两个合并, 再哈希得到父节点
   H12 = hash(H1 + H2)
   H34 = hash(H3 + H4)
   
   3. 继续向上合并
   Markle Root = hash(H12 + H34)
   
   4. 最终
         Merkle Root
           /     \
       H12       H34
      /   \     /   \
    H1    H2   H3   H4
   
   如果交易数不是2的幂, 如有 5 笔交易, 最后一笔会被复制补足, 例如: [T1, T2, T3, T4, T5] -> 变为 [T1, T2, T3, T4, T5, T5, T5](或者按实际处理规则)
   ```
   - 插入交易
     `Merkle` 树本身不是动态插入结构(不像平衡二叉树)，一般在比特币中
     若要构建可插入的 `Merkle 树`, 需要 `每次插入后重建对应路径的哈希`，代价是 `O(log n)`
     - `Merkle 树` 一次性构建于区块生成时
     - 区块生成后就不再更改交易，因此不会进行 `动态插入`
     
   - 查询(`验证某笔交易是否存在`)
     - 不需要所有交易，只需要这笔交易的 `哈希路径`
   ```text
        Merkle Root
           /     \
       H12       H34
      /   \     /   \
    H1    H2   H3   H4
   目标: 验证交易 `T3` 是否属于这棵 `Merkle 树`
   步骤:
   1. 获取 T3 的哈希: H3 = hash(T3)
   2. 提供的 `Merkle 路径` 包括:
      - H4(H3 的兄弟)
      - H12(H34 的兄弟)
   3. 验证过程
      - H3 = hash(T3)
      - H33 = hash(H3 + H4)
      - Merkle Root = hash(H12 + H34)
   4. 比对计算出来的 Merkle Root 与区块头中的一致，说明 T3 存在于该区块中
   5. 为什么效率高？
      - 不需要下载整个区块, 只需要 log2(n) 个哈希值
      - 比如 `1024` 笔交易, 仅需 10 个哈希 + 交易数据本身就能验证
   ```
     
5. 什么是 `gas` 机制?
   - 基本概念
     - `Gas` 是区块链（特别是以太坊等智能合约平台）中的一种 `执行费用计量单位`
       - 每条交易、每个操作、每个函数执行都需要消耗一定的 `gas`
       - `gas` 不是钱，而是衡量计算资源(CPU、存储等)的一种单位
       - 避免滥用资源，比如写个无限循环合约，否则链就挂了
   - Gas 与手续费的关系
     - 用户 `提交交易时` 会附带
       - `gas_limit`: 最多愿意消耗多少 `gas`
       - `gas_price`: 每个 `gas` 愿意出多少钱(比如 `1 wei`)
       - `实际费用 = gas_used * gas_price`
     - 如果执行过程中耗尽 `gas_limit`，则 `交易失败`(`钱照样扣!`)
   - 为什么要引入 `gas` ? 
     - 限制资源
       - 每个节点都要执行合约，必须限制计算时间/资源
     - 防止垃圾交易
       - 每条交易都需要付费，防止 `DoS 攻击`
     - 交易优先级
       - `gas price` 高的交易，矿工更愿意`优先打包`(赚钱多)
   - 例
   ```text
    1. 用户 `Alice` 发起合约调用 `foo()`
    2. `foo()`` 内部执行 `10` 步操作，每步消耗 `100 gas`
    3. 总消耗：`1000 gas`
    4. 用户设置
       - gas_limit = 1500
       - gas_price = 2 Gwei
    5. 交易花费
       - 1000 * 2 Gwei = 2000 Gwei（大约 0.000002 ETH）
   ```
   
6. 什么是 `合约交易` ？
   - 在区块链系统里，交易通常分两类:
     - 普通转账交易（Transfer Transaction）
       - 直接把数字资产（比如币）从一个账户转到另一个账
     - 合约交易（Contract Transaction）
       - 发送给智能合约的交易，目的是触发智能合约上的某个函数逻辑，执行链上代码，可能会改变合约内部状态，甚至产生返回结果
   - 简要
     - 智能合约是写在区块链上的程序，自动执行预定义的逻辑
     - 它们可以管理资产、执行规则、触发事件、调用其他合约等
     - 合约代码是不可篡改的，执行结果在所有节点达成共识
   - 携带的关键信息
     - `调用者(caller)`: 谁发起了合约调用
     - `合约地址(contract)`: 要调用哪个合约
     - `方法名(method)`: 合约中要调用的函数名
     - `参数(args)`: 调用该函数时传入的参数
     - `gas 和优先级等`: 限制执行资源和排队顺序
     - 区块链节点会根据交易中指定的合约地址和方法，去执行对应合约中的函数，传入参数
   - 例
   ```text
    发起一个合约交易，调用合约 `Token` 的 `transfer` 方法，传入参数 `(to_address, amount)`，流程是:
    1. 节点接收到这笔合约交易
    2. 节点根据合约地址找到对应的合约代码
    3. 通过 `虚拟机(EVM、WASM、其他执行环境)` 执行合约的 `transfer 函数`, 传入参数
    4. 合约函数运行后 `修改链上状态`(如账户余额变化)
    5. 执行完成，生成交易执行结果(成功/失败、返回值等)
    6. 交易打包入区块，广播给全网
   ```
     


