# 字典树(Trie)
  字典树(Trie)，又叫 `前缀树`，是一种用于 `快速查找字符串集合` 的数据结构
  - 它的本质是一个 `多叉树`，树的每一条边代表一个字符，`节点上不存储单词(只存储路径上的字符信息)`
  - 所有`公共前缀的单词` 共用 `相同的前缀路径`, 这样可以高效地进行单词的插入、查找和前缀匹配等操作

1. 特性
   - 公共前缀的合并
     - 多个字符串中相同的前缀部分只存储一份，节约了存储空间(对比直接用哈希表存储多个完整单词)
   - 从根开始，每条边代表一个字符
   - 节点是否是 `单词末尾`
     - 通常会在节点上标记一个布尔值(如 `isEnd`)，表示该节点是否是一个单词的结尾
   - 不适合存储海量、非前缀结构化数据
     - 字典树更适合 `存储有前缀共性的单词集`，而不是随机哈希数据
   
2. 时间复杂度
   假设：
     - n:单词的数量
     - m: 单词的最大长度
     - 字母表大小为 `Σ`(如 `英语为26`，`ASCII码256`)
   - 插入单词
     时间复杂度: O(m)
     - 因为每次插入单词，都是沿着根节点往下走(最多走 `m` 步)，遇到没有的分支就创建新节点
   - 查找单词
     时间复杂度: O(m)
     - 同样是逐字符往下找，最多 `m` 步
   - 空间复杂度
     - 最坏情况下:`O(n * m)`, 所有单词 `完全没有公共前缀`
     - 但是有大量前缀共用时，空间更优
     
3. 应用场景
   - 单词词典(前缀匹配/自动补全)
     搜索引擎自动补全
   - 拼写检查
     通过字典树快速检索是否存在拼写错误，或者提供相似词提示
   - 敏感词过滤
     在聊天、评论等输入内容中，检测是否包含敏感词
   - 前缀统计
     给定一组单词，问有多少单词以某个前缀开头
   - IP路由匹配(变种)
     网络路由器查找最优匹配的网络前缀，也常用类似的前缀树(比如 `Patricia Trie`)
   
4. 举例
   - 查找单词
   ```text
   假设要存储以下单词:
    - bat
    - ball
    - barn
    - bar
    字典树结构:
        (root)
         / b
        a
        / \
       t   r
           / \
          n   l
   - 查找 `bar`
     从根出发，找` b ➜ a ➜ r`，找到 `r` 并 `isEnd=true`
   - 查找 `bal`
     从根出发，找 `b ➜ a`，但是没有 `l`，返回不存在
   - 统计前缀
     - 查询前缀 `ba`
       访问 `b ➜ a`，统计其下所有单词数 `= 4`(`bat, ball, barn, bar`)
   ```
   
   - 敏感词替换
   ```text
    假设：
     - 敏感词列表: ["bad", "damn", "hell"]
     - 原始文本:
       `This is a bad example. Oh damn, what the hell is going on?`
    步骤:
     - 从文本第一个字符 `T` 开始，尝试在字典树中匹配
       `T` ➜ 不在字典树根节点的分支，跳过，继续下一个字符
     - 依次跳过字符，直到到达 `b` (第11个字符)
     - 尝试匹配 `b`
       - `b` 存在于字典树的根节点下，继续匹配下一个字符 `a`
       - `a` 也在字典树中继续往下走
       - `d` 也存在，且此时是一个 `敏感词末尾`
       - 因此，匹配到 `bad`
    - 替换：将 `bad` 替换为 ``***`(三个 *，和长度相同)
    - 继续往后，找到 `d`(在单词 `damn` 中)
      - `d` 存在于字典树根节点，继续匹配: `a，m，n`
      - 匹配成功 `damn`, 替换为 `****`
    - 继续往后，找到 `h`(在单词 `hell` 中)
      - `h ➜ e ➜ l ➜ l`，匹配 `hell`，替换为 `****`
    - 最终输出文本
      `This is a *** example. Oh ****, what the **** is going on?`
   ```