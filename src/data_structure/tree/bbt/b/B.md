# B 树(Balanced Tree)
  B 树(Balanced Tree)是一种 `自平衡的多路搜索树`，用于维护有序数据并支持 `高效的查找、插入、删除`操作。B树广泛应用于 `数据库系统和文件系统`中，特别 `适合处理大规模数据`，能够显著`减少磁盘I/O次数`。

1. 定义
   一个 `m阶的B树` 满足以下性质
   - 每个节点最多包含 `m - 1` 个关键字(key)
   - 每个节点最多只能有 `2t - 1` 个 key
   - 每个 `非叶子节` 点最多有 `m` 个子节点
   - `根节点` `至少有一个关键字`(除非整棵树只有一个根节点)
   - 除根节点外，其他 `非叶子节点` `至少有 ⌈m/2⌉ 个子节点`
     - 最小度数 `t` 表示 每个内部节点 `至少` 有 `t - 1` 个 key
     - 对应地，`最多` 有 `2t - 1` 个 key
     - `m = 2t`
   - 所有 `叶子节点` 位于 `同一层`
   - 所有 `关键字` 在节点中 `升序排列`，子树之间具有区间性质
     - 若一个节点有 `k 个关键字`，则它有 `k + 1 个子树`
     - 所有 `左子树的关键字 < 当前关键字 < 所有右子树的关键字`
   - 判断有没有满
     - 偶数
       - `m = 2t`  ⟺  `t = m / 2`, 所以 `2t - 1 = m - 1`
         - 2t - 1
         - m - 1
     - 奇数
       - `m = 2t`, `t = ceil(m / 2)`(向上取整), 此时 `2t - 1 != m - 1`
         - m - 1 
         - 2t - 2

2. 时间复杂度
   - 插入: O(log n)
   - 搜索: O(log n)
   - 删除: O(log n)

3. 举例
   - 构造一棵 `3 阶` B 树(3阶B树：每个节点最多 2 个关键字，最多 3 个子节点)
   - 插入元素: [10, 20, 5, 6, 12, 30, 7, 17] 
   - 插入 `10`
   ```
    [10]
   ```
   - 插入 `20`
   ```
   [10, 20]
   ```
   - 插入 `5` (超过两个关键字, 需要分裂)
     - 中间值 `10 上升` 为 `新根节点`
     - `5` 和 `20` 分别放在 `左右子节点`
   ```
       [10]
      /    \
   [5]     [20]
   ```
   - 插入 `6` → 插入到 `[5]` → 变为 `[5, 6]`
   ```
       [10]
      /    \
    [5, 6]   [20]
   ```  
   - 插入 `12` → 插入到 `[20]` → 变为 `[12, 20]`
   ```
         [10]
        /    \
    [5, 6]  [12, 20]
   ```     
   - 插入 `30` → 插入 `[12, 20]` → 变为 `[12, 20, 30]`, 需要分裂
     - 中间值 `20 上升`
     - 根节点 `[10]` → 插入后变为 `[10, 20]`
   ```
         [10, 20]
        /   |    \
    [5, 6] [12]  [30]
   ```   
   - 插入 `7` → 插入 `[5, 6]` → 变为 `[5, 6, 7]`, 需要分裂
     - 小于10，去左子树 `[5,6]` → 插入后为 `[5,6,7]` → 分裂成 `[5]` 和 `[7]`
     - 中间值 `6 上升`，根节点 `[10, 20]` → 插入后为 `[6, 10, 20]` → 再次分裂
   ```
             [10]
            /     \
         [6]       [20]
        /   \      /   \
      [5]   [7]  [12]  [30]
   ```      

4. 优点 
  - 自平衡结构：所有叶子在同一层，不存在退化为链表的问题
  - 减少磁盘I/O：每个节点存多个关键字，一次磁盘读取能获取多个数据，提高查询效率
  - 支持范围查找：关键字有序排列，便于范围查询(虽然B+树更优)
  - 插入/删除高效：分裂、合并等操作平衡树结构，复杂度为 O(log n)

5. 应用场景
   B树适用于 磁盘存储和大数据量索引场景
  - 📚 数据库索引(早期)
  - 💾 文件系统的目录管理(Unix FS、HFS)
  - 📂 键值数据库内部结构(Berkeley DB)
  ps: 不过，现代数据库如 MySQL 更常用的是 B+树，因为它的叶子节点有链表结构，适合范围查询和顺序访问

6. B VS BST
   B树可以视为BST的多路扩展版(generalized BST)
```
    项目	                BST（二叉搜索树）	        B树（多路平衡树）
    节点关键字数	        1	                    多个（最多 m-1 个）
    子节点数	            最多 2	                最多 m 个
    树的深度	            可能较高，最坏退化为链表	更平衡，深度更小
    是否有序	            ✅ 是	                 ✅ 是
    是否满足 BST 性质	    ✅ 严格满足	             ✅ 满足搜索树原则，但不是二叉结构
```

7. 解释
- 术语来源
```
   术语                             表达方式                     来源/常见语境
   阶（order，记作 m）               每个节点最多 `m - 1` 个 key    教材、数据库系统如 MySQL
   最小度数（minimum degree，记作 t） 每个节点最多 `2t - 1` 个 key   算法书籍，如《算法导论》CLRS
```

- 关键对应关系
  - t 维度
    - 最小度数 `t` 表示 每个内部节点 `至少` 有 `t - 1` 个 key
    - 对应地，`最多` 有 `2t - 1` 个 key
  - m 阶 B 树
    - 每个节点最多有 `m - 1` 个 key(也就是最多有 `m` 个子节点)
```
  m = 2t  ⟺  t = m / 2
```
   - 举例
     - 使用最小度数 t = 3
       - 每个节点
         - 最少 key 数：t - 1 = 2
         - 最多 key 数：2t - 1 = 5
         - 最多子节点数：最多 key + 1 = 6
       - 对应 m = 6 的 B 树（6阶）
     
     - 使用阶数 m = 4 的 B 树
       - 每个节点最多 m - 1 = 3 个 key
       - 最多有 m = 4 个子节点
       - 这对应的 t = m / 2 = 2，所以是最小度数为 2 的 B 树
   
   - 总结
   ```
    阶数 m 表达法            	    最小度数t 表达法
    每节点最多 m - 1 个 key	    每节点最多 2t - 1 个 key
    每节点最多 m 个 children	    每节点最多 2t 个 children
    最小 key 数 = ⌈m/2⌉ - 1	    最小 key 数 = t - 1
   ```

8. 步骤
  以下都是从 `t(最小度数)` 维度来考虑, 节点已满判断条件: 2t - 1
    - 1. 根节点未满
      - 直接调用 `3. 非满插入`
    - 2. 根节点已满(len(node.keys) == 2t - 1)
      此时需要把 `中间值` 提升到 `根节点`
      - 此时需要分裂 `root`, 调用 `4. 分裂`, 返回 `new_node`
      - 创建新的根节点 `new_root`
        - `keys` 为 `mid_key`
        - `childrens` 为 [`旧的root节点`, `new_node`]
      - `new_root` = `root`
      - 重新锁定新的根节点
      - 调用 `3. 非满插入`
    - 3. 非满插入
      - 叶子节点
        - 此时没有子节点, 直接插入即可
      - 非叶子节点
        - 通过 `key < keys[i]`, 找到合适的子节点 `children[i]`(keys 升序, data 必定存在 children 中)
          - 节点已满, 调用 `4. 分裂`
            - 把 `中间的 key` 移到 `父节点`
             - node.keys.insert(i, mid_key);
             - node.children.insert(i + 1, new_root.clone());
            - 把新节点插入到父节点对应位置
            - 重新获取插入位置 `i`, 插入到分裂后的部分(需要判断左或右半部分)
              - `children[i]` 分成了两个节点
              - 左半部分: `children[i]` → 含 `t - 1` 个 key
              - 中间部分: 第 `t - 1` 个 key `上升` → 插入 `node.keys[i]`
              - 右半部分: 新建 `children[i + 1]` → 含 `t - 1` 个 key
          ```
             if data > node.keys[i] {
               i += 1; // 插入右边
             }
          ```
             - `node.keys[i]` 是从 `children[i]` 分裂出来的中间 key
             - 如果 `data` > `node.keys[i]`，说明应该插入新生成的 `children[i + 1]`
           - 重新锁定 child 节点
             - child = node.children[i].lock().unwrap();
        - 调用 `3. 非满插入`
    - 4. 分裂
      - 取 `中间的 key` (mid = t - 1)
      - 分裂 `节点 node 的 children`
        - left_children = node[0.. t]
        - right_children = node[t.. len]
      - 创建新节点 `new_node`, `新节点` 拥有 `右半部分`
        - new_node.keys = node.keys[mid + 1 .. len] (取右半部分 keys )
        - new_node.children = right_children
        - new_node.data = node.data[mid + 1 .. len] (如果是叶子节点，也需要分裂 data, 因为 mid_key 也是叶子节点的有效数据，虽然它的 key 被提升了，但它的 data 依然属于左侧)
        - 为什么 mid_key 不留在左侧?
          - 因为它会提升到父节点，`左节点不再包含它`
          - 但对于 `叶子节点的 data`: `mid_key` 的 `data` 还是 `属于左侧节点` ，所以 `data` 是 `mid + 1`
      - 截取 node.keys 的左半部分留给原节点 (树的有序性)
        - node.keys = node.keys[0 .. mid]
        - node.children = left_children
