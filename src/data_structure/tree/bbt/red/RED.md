# 红黑树(Red-Black Tree)
  一种 `自平衡的二叉搜索树(BST)`, 通过在每个节点中增加一个 `颜色` 属性（`红色`或 `黑色`）来确保树始终保持相对平衡, 从而在最坏情况下也能提供较好的查找、插入和删除效率 `(O(log n))`。

1. 特点
  - 每个节点不是 `红色` 就是 `黑色`
  - `根节点` 是 `黑色`
  - 每个 `叶子节点`（NIL节点）是`黑色`
    - 这里的叶子是指 `空节点` 或 `哨兵节点`，不是实际存储数据的节点
  - 如果一个 `节点` 是 `红色` 的，那么它的 `两个子节点都是黑色` 的
    - `红色节点不能连续出现`(没有两个相连的红节点) 
  - 从 `任意一个节点出发`，到其 `所有后代叶子节点的路径上`，经过的`黑色节点数相同`(称为 `黑高`)

2. 操作
   红黑树的 `最坏高度 ≤ 2 × log₂(n + 1)`, 因为红黑树最多只允许 `黑色路径长度的两倍` 作为 `总高度`。
  - 插入
    - 先按 `BST` 的方式插入一个 `红色节点`
    - 检查是否违反红黑性质，进行必要的 `旋转(rotation)` + `变色(recolor)` 来恢复平衡
    - 常见的调整情况包括
      - `父节点` 是 `红色`，`叔叔节点` 是 `红色 → 变色`
      - `父节点` 是 `红色`，`叔叔节点` 是 `黑色 → 旋转 + 变色`
    - 时间复杂度: (O(log n))
    
   - 查找 
     - 普通的二叉搜索树(BST) 一模一样，不涉及颜色、旋转或变色
     - 过程
       - 从根节点出发:
         - 如果 `目标值 < 当前节点值` → 往 `左子树` 找
         - 如果 `目标值 > 当前节点值` → 往 `右子树` 找
         - 如果 `相等` → `找到了`
     - 时间复杂度: (O(log n)), 红黑树是 `自平衡` 的，保证了树的高度不会退化成 O(n)
   - 删除
     - 删除比较复杂，会涉及更多的 `旋转` 和 `变色` 操作
     - 删除时，可能会破坏黑色节点数量一致的性质，因此可能需要 `双黑修复` 过程
     
3. 插入详细过程
   - 像 `普通BST` 一样 `插入新节点` (`新节点是红色`)
   - 检查是否破坏红黑性质(特别是 `不能两个红色相连`)
   - 通过 `变色` 和 `旋转` 恢复红黑性质
   - 示例
     - 像普通BST一样插入新节点(新节点是红色)
       - 为什么是红色? 因为插入一个红节点不会破坏 `黑高一致`，容易修复
     - 检查是否破坏红黑性质(特别是 `不能两个红色相连`)
       - 假设新插入的节点为 `z`，它的 `父节点为 P(z)`，`叔叔节点为 U(z)`，`祖父节点为 G(z)`
         - 1. 父节点是黑色 ✅
           - 不违反任何性质，插入完成
         - 2. 父节点是红色 ❌（出现连续红色）
           - 2.1 叔叔节点也是红色(变色)
           ```
                  G(B)
                  /   \
                P(R)   U(R)
                /
              z(R)
           ```
            - 把 P 和 U 变成黑色
            - 把 G 变成红色
            - 继续向上检查 G（可能也违反规则） → 递归处理
           
           - 2.2 叔叔节点是黑色，且 z 是 `内侧子树`(需要 `旋转`)
             内侧结构需要 `先变外` 再进行标准的 `变色 + 单旋转(前面变外只进行一次旋转, 此处再进行旋转)` 操作
           ```
                  G(B)
                  /  
                P(R)
                 \
                z(R)
           ```
           - 先进行一次 左旋（让 z 成为外侧子树）
           - 转化为情况 2.3
         
          - 2.3 叔叔节点是黑色，z 是 `外侧子树`(旋转 + 变色)
          ```
                 G(B)
                 /  
               P(R)
              /
            z(R)
          ```
           - P 变黑，G 变红
           - 对 G 进行右旋（让 P 上位）
           - 插入修复完成
         
         - 3. 递归回到根节点，保证根为黑色 
           - 因为旋转、变色可能会往上影响，所以有时需要递归调整，直到根节点

4. 应用场景
   - C++ 的 std::map / std::set
   - Java 的 TreeMap / TreeSet
   - Linux 内核的 rb_tree 实现

5. 示意图
```
        10(B)
       /     \
    5(R)     20(R)
   /   \     /   \
  3(B)  7(B) 15(B) 25(B)
```
  - 根是黑色
  - 红节点的子节点都是黑色
  - 所有到叶子的路径都有相同数量的黑色节点

6. 变色
   变色是红黑树中用来 `修复红红` 冲突的一种方式, 当 `插入一个红色节点`，且它的 `父节点也是红色`时，就触发了 `冲突`, 但有时候，这种冲突是可以通过 `变色` 简单修复的，而 `不需要旋转`。
   - `能变色就变色`
   - `不能变色再旋转`
   - 变色是 `轻量` 的修复方式
   - 变色是一种 `只改变节点颜色`、`不改变树结构` 的红黑树修复方式，用于处理 `红父红叔`的插入情况，能快速恢复红黑性质而`不增加树的高度`。
   - 触发条件(2.1 叔叔节点也是红色(变色))
     - 假设我们刚插入的节点是 `z`，它的父节点是 `P(z)`，祖父是 `G(z)`，叔叔是 `U(z)`
     ```
               G(B)
              /   \
           P(R)   U(R)
           /
         z(R)
     ```
     这时候，`P(z)` 和 `U(z)` 都为 `红色`，就可以 `变色` 了
     - 变色的过程
       - 将 `父节点 P(z)` 和 `叔叔节点 U(z)` 变成 `黑色`
       - 将 `祖父节点 G(z)` 变成 `红色`
       - 将 `G(z)` 视为 `新插入节点`，`递归向上检查`是否 `冲突`
       ```
                 G(R)
                /   \
             P(B)   U(B)
            /
          z(R)
       ```
       现在，`z` 的父是黑的，不冲突；但 G 变红了，如果它的父也是红，就要继续修复（递归处理）
     - 作用
       - 变色的目的就是消除 `连续红节点` 的情况，并维持 `黑高` 一致性
       - 假设当前子树原来的 `黑高` 是 `2`
         - G(B) → 高度 +1
         - 子节点 P(R) 和 U(R) 不计入黑高
       - 变色后
         - G(R) 不计黑高
         - P(B) 和 U(B) 变黑 → 仍然黑高为 2
       - `变色不会破坏黑高一致性`

7. 如何判断插入的时候是需要`变色`、`旋转` 还是 `两者都需要`
   当插入一个 `红色节点 z` 时，先判断其 `父节点 P(z)` 的颜色
   - ✅如果父是黑色 → 插入完成 ✅
     - 红黑树性质没有被破坏
   - ❌如果父是红色 → 出现连续红，必须修复
     - `叔叔节点 U(z)` 是否 `存在且为红色`
       - ✔ 是红色 → 变色
       - ❌是黑色或不存在 → 旋转
   - 口诀
     - `父黑`？`没事`了。
     - `父红`，`叔红`？`变色`向上走
     - `父红`，`叔黑`?
       - 插在 `内侧`？先 `旋转成外`
       - 插在 `外侧`？`变色` + `旋转`
   - 举例
     - 只需变色
       插入节点：`z = 1`
     ```
                 10(B)
                /    \
             5(R)   15(R)
             /
           1(R)  ← 插入点
     ```
       - z = 1，父是 5(R)，祖父是 10(B)，叔叔是 15(R)
       - `父` 和 `叔`都是 `红色` → 变色
       - 修复方式
         - 5 → 黑色
         - 15 → 黑色
         - 10 → 红色（可能递归上去）
         
     - 只需旋转
       插入节点：`z = 1`
     ```
                 10(B)
                /  
             5(R) 
             /
           1(R)  ← 插入点
     ```
       - z = 1，父是 5(R)，祖父是 10(B)，`叔叔 不存在/是黑色`
       - → `连续红` + `叔叔黑` → 需要旋转
       - 修复方式
         - 对 10 进行 右旋
         - 5 变黑，10 变红
         
     - 先变色，再旋转
       插入顺序：[10, 5, 15, 1, 6, 12, 18, 0]
     ```
                5(R)
               /   \
            1(R)   6(R)
           /
         0(R)  ← 插入点
     ```    
       - 0 的父 1(R)、叔叔 6(R) 都是红色 → 先变色
       - 1 → 黑，6 → 黑，5 → 红
       - 此时 5 的父也可能是红 → 继续修复（变色或旋转）
     
8. 内侧 vs 外侧结构
   ```
            G(B)
           /   \
         P(R)   U(B)  -- U(B)是 黑色（或不存在）
         /
       z(R)
   ```
   
   `插入节点` z 是`红色`，`P(z)` 也是`红色`，而 `U(z)` 是 `黑色（或不存在）`, 根据 `z` 和 `P(z)` 相对于 `G(z) 的位置` 来区分结构

   ```
   结构类型    |    P(z) 是 G(z) 的    |    z 是 P(z) 的    |    描述
   外侧结构    |    左子               |    左子            |    左左结构
   外侧结构    |    右子               |    右子            |    右右结构
   内侧结构    |    左子               |    右子            |    左右结构
   内侧结构    |    右子               |    左子            |    右左结构
   ```

9. 删除
   - 找到要删除的节点
     - 删除节点 `没有子节点`, `直接删除`
     - 删除节点 `只有一个子节点`: 将 `子节点`接入 删除节点的 `父节点`
   - 用后继节点替换删除节点
     - 删除节点 `有两个子节点`, 需要找到其`中序后继节点 y`, 并将其 `替代删除节点` , 然后 `删除真正删除后继节点 y`
     - 记录 `后继节点删除前的颜色`, 只有当 `删除` 的是 `黑色节点` 时，才需要 `修复`
     - 要`修复的节点`, `不是被删除的节点本身`, 而是被用来 `替代被删节点的那个节点` —— 也就是 `y 的孩子(通常是右孩子)`
       - 修复的是 `替代原来 y 位置的节点`, 即 `y 的右子树`
     ```
         [50]
        /    \
     [30]    [70]
             /  \
          [60]   [80]
          /
        [55]
     ```
       - 删除 50，它有两个子节点
       - 中序后继是：最小的右子树节点 → 也就是 55, y = 55
       - 最终要 `删除 y 原来的位置(也就是 55)`
       - 把 `y 的右子节点` 替代 `y`(即：用 transplant(y, y.right))
       - 提前保存: `fixed_node = y.right`
       - 修复逻辑是 `围绕 “谁替代了被删节点”展开的` ⇒ 所以 `fixed_node 就是这个候选`
   
       - ps:总结
         - `fixed_node` 是 `真正替代“被删节点位置”的孩子节点`
         - 如果 `y 是 z.right`，它就是 `直接后继` ，`没位置变动`，`fixed_node = y.right`
         - 如果 `y 不是 z.right`，你先要把 `y 的位置删除` ⇒ 即 `替换成 y.right`
           - 所以此时 `fixed_node = y.right`，用它来修复红黑性质
   
   - 怎么找中序后继节点?
     - 节点 `有右子树`
       - 中序后继就是 `右子树中的最小节点`(右子树上的左子树上找到最小节点)
     ```
       [20]
          \
          [30]
          /
       [25]
     ```
      - 20 的中序后继是右子树 [30] 中的最小值 → [25]
   
     - 节点 `没有右子树`
      - 要 `沿着父指针一直往上找`，直到 `找到一个祖先节点 p`，使得 `z 是 p 的左子树`(本质上，是找到 `比当前节点稍大` 的 `第一个节点`)
      ```
              [50]
              /
            [40]
             /
           [30]
             \
             [35]  ← z
      ```
      - 中序遍历顺序
        - 30 → 35 → 40 → 50
        - 很清楚地看到：35 的中序后继是 40
        - 不能靠遍历去找，我们得靠「结构」推理来找
      - 实现方式(找到 40)  
        - 35 没有右子树，所以往上找祖先
        - 35 是 30 的右孩子 → 不行，继续往上
        - 30 是 40 的左孩子 → ✅ 成功，40 是后继
   
     - 节点是 `整棵树中最大的` → 没有中序后继
      ```
          [20]
            \
            [40]
              \
             [50]
      ```
       - ✅ 中序遍历：20 → 40 → 50
        - 50 没有右子树
        - 也没有任何祖先是它的左父亲分支
        - 所以没有中序后继 → None
     
     - 公式
     ```
       情况       |    如何找中序后继
       有右子树    |    右子树最左节点
       无右子树    |    往上找第一个把当前节点当作左子节点的祖先
       无中序后继  |    当前节点是整棵树中最大节点(None)
     ```
   
   - 删除真正删除后继节点
     - 如果 `y` 就是 `node.right`，那说明 `y` 是 `直接的后继`，可以 `直接替换`
     - 如果 `y` `不是 node.right`，说明 `y` 是 `node.right` 的 `左边某个节点`，`y 本身也有位置、也有父节点`，这时候就要 `先删除 y 原来的位置`，再把 `y 移动到 node 的位置`
   ```
       [10B]
       /   \
    [5R]   [20B]
          /    \
       [15R]   [30R]
       /
    [12B]
   ```
   删除节点 10
   - 它有 `左右子树`，所以我们去它的 `右子树里找中序后继`
     - 右子树是 [20]
     - 一直往左走：20 -> 15 -> 12，所以后继 y = 12
   - y 的父节点是 15, 而 15 ≠ node(10)
     - y 原来是在 15 的左子树上，我们得把 12 从它原来的位置拿掉（但 12 可能还有一个右孩子）
       - 把 12 的位置用它的右子节点替代
       - 把 node 的右子树（也就是 20）接到 12 的右边
       - 把 y 接到原来 node 的位置上
   - 而如果后继 y 就是 node.right 呢?
   ```
       [10B]
       /   \
    [5R]   [15R]
   ```
    - 此时要删 10，它的中序后继就是 15，而且 15 就是 node.right 
    - 就不需要再把 y 移除原来的位置了，因为它 就是 node.right，可以直接替换
   - 总结: 如果 `中序后继 y` 不是 `待删节点的直接右孩子`，那么我们要先把 `y 从它原来的位置移除`，`并把它的右孩子提上去`，然后 `再让 y 接替 node 的位置`
   
   删除节点后，如果 `删除` 的是 `黑色节点`，会 `破坏` 红黑树的 `平衡性`
   - `从任意节点到其子孙叶子节点的所有路径上的黑色节点数量` 可能不一致了
   - 为了解决这个问题，引入一个概念叫做 `双重黑(double black)`
       - 当你删除一个 `黑色节点`，并用一个 `空节点(NIL)` 或 `黑色节点` 替代它，就会引入 `额外的黑色`
       - 红黑树的修复就是要把这 `多出来的一黑` `从底层向上` `消除`
   
   - 举例
   - 9.1 删除 `红色叶子节点`(不需要 `修复`)
   ```
       [10B]
       /   \
     [5R]  [15B]
           /   \
        [12R] [20R]
   ```
     - 9.1.1 找到要删除的节点 `z = 15B`
       - 15有两个子节点: 12 和 20
       - 找到它的 `中序后继`: y = 20R, 用 y 替代 z
     ```
       [10B]
       /   \
    [5R]  [20R]  <- y 替代了 z=15B
          /
       [12R]
     ``` 
     - 9.1.2 删除 y = 20R
       - y 是 `红色` 的, 所有删除它 `不会破坏红黑性质`, 不需要修改

  - 9.2 删除 `黑色叶子节点`(需要 `修复`)
  ```
     [10B]
     /   \
  [5R]  [15B]
        /   \
     [12B] [20B]
  ```
   - 删除节点 12B(黑色叶子节点)
     - 删掉了一个黑色节点，它路径上的黑高减少，违反了红黑树性质 5(从 `任意一个节点出发`，到其 `所有后代叶子节点的路径上`，经过的`黑色节点数相同`(称为 `黑高`))
   - 修复的 5 种情况(以 x 为当前带有 `双重黑` 的节点)
     - 假设 `x` 是当前处理的节点，`s` 是 `x` 的 `兄弟节点`，`p` 是 `x` 的 `父节点`。我们按照 `s` 的 `颜色` 和 `s` 的 `子节点颜色` 分类
     - 9.2.1. 兄弟是红色
     ```
           P(b)                   S(b)
          /   \      -->         /   \
        x(bb)  S(r)           P(r)   s.right
               / \            / \
              a   b         x(bb) a
     ```
       - 将 `s` `变黑`，`p` `变红` (S.color = Black, P.color = Red)
       - 以 `p` 为中心做一次 `旋转`(左旋或右旋，取决于 x 是左孩子还是右孩子)
       - 这样做是为了把 `兄弟` 变成 `黑色` 的，从而转化为后面的情况
     
      - 9.2.2. 兄弟是黑色, 且两个子节点也都是黑色
     ```
         P(?)                     P(bb)
         /   \       -->          /   \
      x(bb)  S(b)              x(b)   S(r)
             /  \
           b(b) c(b)
     ```
       - 将 `s` `变红`，消除它的黑色 (S.color = Red)
       - 把 `双重黑往上`(`x` 上移到 `p`) 传给 `p(x = p)`，继续 `循环` 修复
       - 如果 `p` 是 `红色`，`变黑` 就好了(`结束`)；如果 `p` 是 `黑色`，`继续往上传`
     
      - 9.2.3. 兄弟是黑色，远侄子是黑色，近侄子是红色
        - 远侄子: S.left = a
        - 近侄子: S.right = c
      ```
           P(?)                     P(?)
          /   \       -->          /   \
       x(bb)  S(b)             x(bb)   b(b)
              / \                     /
            a(r) c(b)              a(b)
      ```
        - 将 `s` `变红`，`远侄子 a` `变黑` (S.color = Red, a.color = Black)
        - 对 `s` 做一次 `旋转`()
          - 对兄弟节点做一棵子树的旋转
          - 如果 `x 是左子节点`, 则对 `兄弟节点 s 右旋`, x 在左 → 右旋兄弟
          - 如果 `x 是右子节点`, 则对 `兄弟节点 s 左旋`, x 在右 → 左旋兄弟
        - 这样转换为 `情况 4`
     
      - 9.2.4. 兄弟是黑色，远侄子是红色
        - `近侄子` `一定是黑色`
        - 如果 `近侄子是红`，我们就要 `先进入 9.2.3`。
        - 近侄子: S.left = a
        - 远侄子: S.right = c
      ```
             P(?)                     S(?)
            /   \       -->          /   \
         x(bb)  S(b)              P(b)    c(b)
                /  \              /  \
             a(b)  c(r)         x(b) a(b)
      ```
        - 让 `s` 的 `颜色` `变成` `p` 的 `颜色` (S.color = P.color)
        - 将 `p` 和 `远侄子 c` `变黑` (P.color = Black, c.color = Black)
        - 对 `p` 做一次 `旋转`(右旋或左旋，取决于 x 是左还是右)
          - 如果 `x 是左子节点`, 需要把 `s 提上去当新的节点`, 则对 `父节点 p 左旋`, `x 在左 → 左旋父节点`
          - 如果 `x 是右子节点`, 需要把 `s 提上去当新的节点`, 则对 `父节点 p 右旋`, `x 在右 → 右旋父节点`
        - 双重黑消除，结束修复!
     
      - 9.2.5. x 是根节点(特殊)
        - 如果 `x` 是 `根节点` 且是 `双重黑`，直接将其设为 `黑色` 即可，修复结束。
      
      ```
     情况   |    条件                     |    操作
      1    |    兄弟是红色                |    变色 + 旋转 → 转化为情况 2/3/4
      2    |    兄弟黑，两个侄子也都是黑色   |    兄弟变红，双黑传递给父节点
      3    |    兄弟黑，远侄子黑，近侄子红   |    兄弟变红，近侄子变黑 + 旋转（转化为情况 4）
      4    |    兄弟黑，远侄子红           |    兄弟染成父亲颜色，父变黑，远侄子变黑，旋转，双黑消除
      5    |    当前节点是根节点           |    设置为黑色即可
     ```
   - 9.2.3/9.2.4 总结
   ```
     位置    |    近侄子    |    远侄子    |    情况        |    操作
     x 左    |    红       |    黑       |    9.2.3       |    近变黑，s变红，右旋 s，再走情况 4
     x 左    |    黑       |    红       |    9.2.4       |    s染成父色，父黑，远侄黑，左旋父，终止
     x 右    |    红       |    黑       |    9.2.3       |    近变黑，s变红，左旋 s，再走情况 4
     x 右    |    黑       |    红       |    9.2.4       |    s染成父色，父黑，远侄黑，右旋父，终止
   ```
   - 口决
     `红变黑旋转，黑全黑上传；远红染旋转，近红变远红`
     - `红色兄弟` ？`变色` + `旋转`
     - `黑色兄弟` ？看 `侄子颜色`
       - `两个侄子都黑`？`上传问题`
       - `远侄子红` ？`染色` + `旋转`
       - `近侄子红` ？先 `转为远侄子红`

10. 变色 VS 旋转
   操作     |     触发条件                              |     调整对象         |     是否结构性改变
   变色     |     叔叔是红色                            |     父、叔、祖父节点   |     ❌ 不改树结构
   旋转     |     叔叔是黑色或不存在，且连红现象存在        |     父、祖父节点      |     ✅ 改变树结构

11. 红黑树 和 AVL 树 的对比
   特性               |   红黑树               |      AVL 树
   平衡性             |   相对平衡              |      严格平衡
   插入/删除效率       |   更快（少旋转）         |      较慢（频繁旋转）
   查找效率           |   稍差                  |      更快
   使用场景           |   插入/删除频繁的场景     |      查找频繁、插入/删除少的场景