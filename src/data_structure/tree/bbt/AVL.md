# AVL 树(Adelson- Velsky and Landis Tree)
  AVL 树是一种 `自平衡二叉搜索树`, 对于每个节点，`左子树和右子树的高度差（平衡因子）最多为 1`，否则就需要进行旋转调整以恢复平衡。

1. 特点
  - 二叉搜索树(BST)特性:
    - `左子树` 的所有节点值 `小于当前节点值`
    - `右子树` 的所有节点值 `大于当前节点值`
  - 平衡因子(Balance Factor):
    - `平衡因子 = 左子树高度 - 右子树高度`
    - 取值范围: `-1`, `0`, `1`
    - 超出这个范围(`<-1` 或 `>1`)时, 需要进行 `旋转` 来保持平衡
      - `> 1`: 表示左子树较高，可能需要 `右旋` 或 `先左后右旋(LR)`
      - `< -1`：表示右子树较高，可能需要 `左旋` 或 `先右后左旋(RL)`
    
2. AVL 树的旋转操作    
   AVL 树在插入或删除节点后，可能会破坏平衡，此时需要通过 `旋转` 恢复平衡
   有 `4种` 旋转方式:
   ```
   失衡类型	    旋转方式	                举例
   左-左 (LL)	右旋 (Right Rotation)	插入值导致左子树过高
   右-右 (RR)	左旋 (Left Rotation)	    插入值导致右子树过高
   左-右 (LR)	先左旋，再右旋	        插入值导致左子树的右子树过高
   右-左 (RL)	先右旋，再左旋	        插入值导致右子树的左子树过高
   ```
   
   - 左旋: 右子树太高, 当前节点 `下移`，它的 `右子节点上升`, 旋转方向: `逆时针`, 动作: `右子节点上升，自己变成左孩子`(右子上，自己左移)
   - 右旋: 左子树太高, 当前节点 `下移`，它的 `左子节点上升`, 旋转方向: `顺时针`, 动作: `左子节点上升，自己变成右孩子`(左子上，自己右移)
   - AVL 树总是从最“深”的失衡点开始修复，也就是离插入/删除点最近的失衡祖先节点
   
   示例:
   - LL 失衡(左-左失衡, Right Rotation)
      - 新插入的节点 `位于左子树的左侧`, 导致 `左子树高度增长`
      - 需要进行 `右旋` 来恢复平衡
     插入 3 导致 LL 失衡:
   ```
         5
        /
       4
      /
     3
   ```
   右旋:
   - 以 `5` 为支点，右旋
   - `4` 变成 `新的根节点`, `5` 变成 `4` 的右子节点
   ```
      4
     / \
    3   5
   ```
   
   - RR 失衡(右-右失衡, Left Rotation)
     插入 7 导致 RR 失衡:
     - 新插入的节点位于 `左子树的左侧`, 导致 `左子树高度增长`
     - 需要进行 `左旋` 来恢复平衡
   ```
      5
       \
        6
         \
          7
   ```
   左旋:
   - 以 `5 为支点`，`左旋`
   - `6` 变成新的 `根节点`, `5` 变成 `6 的左子节点`
   ```
       6
      / \
     5   7
   ```
   
   - LR 失衡(左-右失衡, Left-Right Rotation)
   - 左-右失衡修复操作 = 左旋左子节点 + 右旋当前节点
     - 新插入的节点位于 `左子树的右侧`, 导致`左子树`的右子树 `过高`
     - 需要先`左旋`, 再 `右旋` 来恢复平衡
     插入 3 导致 LR 失衡
   ```
       5
      /
     2
      \
       3
   ```
   先左旋:
    - 以 `2 为支点`, 对 `3 左旋`, `3` 变成 `2 的父节点`
   再右旋:
    - 以 `5 为支点`, 对 `3 右旋`, `3` 变成 `新的根节点`
   ```
       3
      / \
     2   5
   ```
   
   - RL 失衡(右-左失衡, Right-Left Rotation)
   - 右-左失衡修复操作 = 先右旋右子节点，再左旋当前节点
     - 新插入的节点位于 `右子树的左侧`，导致 `右子树` 的左子树 `过高`
     - 需要 `先右旋`，`再左旋` 来恢复平衡
     插入 5 导致 RL 失衡:
   ```
     2
      \
       6
      /
     5
   ```
   先右旋:
     - 以 `6 为支点`，对 `5 右旋`，`5` 变成 `6 的父节点`
   再左旋:
     - 以 `2 为支点`，对 `5 左旋`，`5` 变成 `新的根节点`
   ```
       5
      / \
     2   6
   ```
 
3. 复杂度
   - 查找: o(log n)
   - 插入: o(log n)
   - 删除: o(log n)
   
4. 应用场景
   - 数据库索引（如 MySQL 的 B-Tree）
   - 操作系统进程调度（如 Linux 红黑树）
   - 编译器优化（如符号表存储）
   - 网络路由表查找
   - 游戏引擎事件管理

5. 举例
- 示例 1
```
      y
     / \
    x   C    
   / \                   
  A   B       
```
```
# 计算节点高度
A = 1, B = 1 
-> x = max(1, 1) + 1 = 2, C = 1, balance = A - B = 1 - 1 = 0
-> y = max(x , C) +  = max(2, 1) + 1 = 3, balance = x - C = 3 - 1 = 2 -- 找到失衡点
```
- 此时 `y` 的左子树过高, 导致 `左左失衡`
- y 的左子是 x
- x 的左子是 A，右子是 B
- y 的右子是 C
- 失衡点是 y，因为左子树比右子树高了 2
- x 的左子也高（是左左失衡）

- 旋转
  - 右旋
  - 我们要将 x 上移，y 下移到 x 的右子节点
  - 规则
    - x 上升为新的根
    - y 变成 x 的右子节点
    - x.right（也就是 B）变成 y.left
  - 过程
  ```
       y
      / \
     x   C    
    / \                   
   A   B       
  ```
    - 右旋 y（x 上升，y 下移）
      - x 成为新的根
      - y 成为 x 的右子节点
      - B（x 原来的右子）成为 y 的左子节点
      ```
        x
       / \
      A   y
         / \
        B   C
      ```
      - x 成为了新的根节点
      - A 和 B 保持在它们原来的位置
      - y 仍然是 C 的父节点，只是现在变成 x 的右子

- 示例 2
```
          y
        /   \
      x       C
     / \     / \
    A   B   G   H
   / \
  z   f
 /
e
```
- 从最深处开始查找失衡点
```
# 计算节点高度
e = 1, balance = 0 
-> z = max(e, 0) + 1 = 1 + 1 = 2, f = 1, balance = e - 0 = 1 - 0 = 1
-> A = max(z, f) + 1 = max(2, 1) + 1 = 3, B = 1, balance = z - f = 2 - 1 = 1
-> x = max(A, B) + 1 = max(3, 1) + 1 = 3 + 1 = 4, balance = A - B = 3 - 1 = 2 -- 找到失衡点

G = 1, H = 1
-> C = max(G, H) + 1 = max(1, 1) + 1 = 2
-> y = max(x, C) + 1 = max(4, 2) + 1 = 5
```
- 因为是左左失衡，只需要做一次 `右旋`
- 过程
  - 旋转点是 y, x 将成为新的根节点
  ```
          x
         / \
        A   B
       / \
      z   f
     /
    e
  ```
    - x 暂时是孤立的根
    - y、C、G、H 暂时“脱挂”
  - y 下沉，变成 x.right
    - 将原本的根 y 挂在 x.right，此时 y 的左子树和右子树还保持原样（包括 x 被删掉的旧位置），但注意：x.right 原本是 B，现在被替换为 y
   ```
          x
        /   \
       A     y
      / \   / \
     z   f ?   C
    /         / \
   e         G   H
   ``` 
   - B 暂时“脱挂”，还没挂到 y.left
   - x.right = y
   - y.left 暂时是空（下一步处理）
  - x.right 原本是 B，需要移交给 y.left
   - B 原来是 x.right，但现在 x.right 是 y 了，为了不丢失 B，我们把它挂到 y.left
  ```
          x
        /   \
       A     y
      / \   / \
     z   f B   C
    /         / \
   e         G   H
  ```
  - 计算平衡因子
  ```
   e = 1,
   -> z = max(e, 0) + 1 = 2, f = 1, balance = e - 0 = 1 - 0 = 1
  -> A = max(z, f) = max(2, 1) + 1 = 2, balance = z - f = 2 - 1 = 1
  
  G = 1, H = 1,
  -> C = max(G, H) + 1 = max(1, 1) + 1 = 2, B = 1, balance = G - H = 0
  -> y = max(B, C) + 1 = max(1, 2) + 1 = 3, balance = B - C = 1 - 2 = -1
  
  -> x = max(A, y) + 1 = max(2, 3) + 1 = 4, balance = A - y = 2 - 3 = -1
  ```