# DP 练习
  
1. 斐波那契数列
  ```text
  给定整数 n，返回斐波那契数列的第 n 项（从 0 开始），即：
  - fib(0) = 0
  - fib(1) = 1
  - 对于 n >= 2, fib(n) = fib(n - 1) + fib(n - 2)
  
  示例:
  输入: n = 4
  输出: n = 3
  解释: fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3
  
  1. 是否可用 DP
  1.1 最优子结构
      计算 fib(n) 可拆成 fib(n-1) + fib(n-2)，由小问题直接组合得出大问题，符合最优子结构
  1.2 重叠子问题
      在递归中计算时，fib(n-1) 和 fib(n-2) 会被重复计算多次，存在重叠子问题。
  1.3 无后效性
      当前状态只取决于:
        当前 n 的值
        与历史的选择顺序(先算 n-1 还是先算 n-2)无关
        
  2. 定义状态
     状态是 `子问题的刻画`, 用于表达“当前子问题要做什么”
     我们需要求出:
     - 当 n = 0 时的结果
     - 当 n = 1 时的结果
     - 当 n = 2 时的结果
     ...
     - 一直到 n = n 的结果
     
     定义: dp[i] = fib(i), 表示斐波那契数列第 i 项的值
     
  3. 列出选择(Choice)
     我们要求: dp[i] = fib(i)
     求 dp[i] 时有哪些选择?
       根据斐波那契数列定义: fib(n) = fib(n - 1) + fib(n - 2)
       在求 dp[i] 时需要:
         1️⃣ 选择使用 dp[i-1]（即斐波那契第 i-1 项的值）
         2️⃣ 选择使用 dp[i-2]（即斐波那契第 i-2 项的值）
       然后将二者相加，得到当前 dp[i] 的值。  
     可理解为: 在状态 i 时，我们“选择”使用前一个状态和前前一个状态来构造当前状态的值。
     
  4. 写出转移方程(递推公式)
     将“选择”转化为最优性方程: 
     dp[i] = dp[i-1] + dp[i-2](i >= 2) 
     
  5. 边界条件(初始化)
     根据: 斐波那契数列
     - fib(0) = 0
     - fib(1) = 1 
     得到:
     - dp[0] = 0
     - dp[1] = 1  
     
  6. 计算顺序
     由于 dp[i] 依赖于 dp[i - 1] 和 dp[i - 2], 必须先计算 i - 1 和 i - 2 的值,  必须从 i = 2 开始顺序计算到 i = n
     
  7. 返回结果   
      最终我们要求的就是: dp[i], 即 fib(n)
  ```

2. 爬楼梯
   ```text
   假设你正在爬楼梯, 需要 n 阶你才能到达楼顶。每次你可以爬 1 阶或 2 阶
   问你有多少种不同的方法可以爬到楼顶？
   
   示例:
   输入：n = 3
   输出：3
   解释：
       - 1 阶 + 1 阶 + 1 阶
       - 1 阶 + 2 阶
       - 2 阶 + 1 阶
   
   1. 判断是否可以用 DP
   1.1 最优子结构
       爬到第 n 阶, 可以由:
         - 从 n - 1 阶再爬 1 阶
         - 从 n - 2 阶再爬 2 阶
       得到。
       因此爬到第 n 阶的总方案数 = 爬到 n - 1 阶的方案数 + 爬到 n - 2 阶的方案数
   1.2 重叠子问题
       在递归计算时，爬到 n-1 和 n-2 会重复计算相同阶数时的方案数。
   1.3 无后效性。
       爬到第 n 阶的方法数只与当前阶数 n 有关，与到达此阶的路径无关(顺序不影响结果)。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
      获取状态:
        我们需要获取:
        - 爬到 n-1 阶的方案数(从 n-1 阶再爬 1 阶)
        - 爬到 n-2 阶的方案数(从 n-2 阶再爬 2 阶)
      因此定义: dp[i] = 爬到第 i 阶的方法数, 用于表示从地面爬到第 i 阶共有多少种不同的方法
   
   3. 列出选择(Choice)
      爬到第 i 阶, 有两种选择路径
      - 从 i-1 阶再爬 1 阶到达 i
      - 从 i-2 阶再爬 2 阶到达 i
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程:
      dp[i] = dp[i - 1] + dp[i - 2], i >= 2    
   
   5. 边界条件(初始化)
      从 0 阶（地面）开始爬:
      - dp[0] 表示 爬到第 0 阶的方法数，也就是原地不动的方案数
      - 通常定义为 1，表示“什么都不做”，这对递推有帮助
      - dp[0] = 1
   
      爬到第 1 阶的方法数(dp[1])
      - 只有一种方法: 直接爬 1 阶
      - dp[1] = 1
      
      所以:
      起点只有 1 种方案——原地不动: dp[0] = 1
      爬 1 阶只有 1 种方法: dp[1] = 1 
   
   6. 计算顺序
      从小到大依次计算 dp[2] 到 dp[n]
     
   7. 返回结果   
      最终我们要求的就是: dp[n]
   ```
   
3. 不同路径
   ```text
   一个机器人位于 m x n 网格的左上角(起点在(0, 0))。
   机器人每次只能 `向下或向右移动一步`, 机器人试图到达网格的右下角(终点在(m - 1, n - 1))。
   问有多少条不同的路径到达终点。
   
   示例:
   输入: m = 3, n = 2 
   输出: 3
   
   解释:
   下 -> 下 -> 右
   下 -> 右 -> 下
   右 -> 下 -> 下
   
   1.  判断是否可以用 DP
   1.1 最优子结构
       要走到 (i, j) 的路径数, 可以由:
       - 从 上方(i - 1, j) 向下走到 (i, j)
       - 从 左方(i, j - 1) 向右走到 (i, j)
       得到。
       因此要走到 (i, j) 的方案数可以由子问题(到达(i - 1, j) 和 (i, j - 1))组合得到, 满足最优子结构。
   1.2 重叠子问题
       不同路径会经过同一格(i, j), 需要反复计算从 (0, 0) 到 (i, j) 的路径数。
   1.3 无后效性
       走到(i, j) 的方案数, 只依赖位置 (i, j), 与路径的历史顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
     
     获取状态:
     要求从左上角 (0,0) 走到右下角 (m-1, n-1) 的方案数, 而走到 (i, j) 的方案数依赖于:
     - 从 上方(i - 1, j) 向下走到 (i, j) 的方案数
     - 从 左方(i, j - 1) 向右走到 (i, j) 的方案数
     因此定义: dp[i][j] = 从 (0, 0) 走到(i, j) 的不同路径数
   
   3. 列出选择(Choice)
      从左上角 (0, 0) 走到 (i, j), 有两种不同的路径:
      - 从 上方(i - 1, j) 向下走到 (i, j) 
      - 从 左方(i, j - 1) 向右走到 (i, j) 
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
   
   5. 边界条件(初始化)
      从 (0,0) 到 (0,0) 不需要走，默认就在那里,计作 1 种方式(即 `原地不动` 也是一种方案):
      dp[0][0] = 1
      
      对于第一行 dp[0][j], 只能向右走到(0, j), 每个格子只有 1 种走法, 因此: dp[0][j] = 1
      对于第一列 dp[i][0], 只能面下走到(i, 0), 每个格子只有 1 种走法, 因此: dp[i][0] = 1
   
     最终:
     dp[0][0] = 1
     dp[0][j] = 1
     dp[i][0] = 1
   
   6. 计算顺序
      因为: dp[i][j] = dp[i - 1][j] + dp[i][j - 1], 因此计算 (i, j) 时需要先计算(i - 1, j) 和 (i, j - 1)。
      执行顺序
      - 从上到下(i 从 0 到 m - 1)
      - 从左到右(j 从 0 到 n - 1)
   
   7. 返回结果  
      我们要求的就是从 (0,0) 到达右下角 (m-1, n-1) 的不同路径数，因此返回 dp[m - 1][n - 1]
   ```
   
4. 最小路径和
   ```text
   给定一个 m x n 的网格 grid, 网格中每个单元格包含一个非负整数, 表示走到该位置的代价。
   机器人从左上角(0, 0) 出发, 只能 向右或向下 移动, 直到到达右下角(m - 1, n - 1)。
   求：从左上角到右下角路径上数字之和的最小值(最小代价)。
   
   示例:
   输入: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]
   输出: 7
   解释: 路径 1 -> 3 -> 1 -> 1 -> 1, 总和 = 7
   
   1.  判断是否可以用 DP
   1.1 最优子结构
       要走到(i, j), 可以由:
       - 从 上方(i - 1, j) 向下走一下到 (i, j)
       - 从 左边(i, j - 1) 向左走一下到 (i, j)
       得到。
       从 (0,0) 到 (i,j) 的最小路径和，等于到达 (i-1, j) 或 (i, j-1) 的最小路径和 + grid[i][j]
   1.2 重叠子问题
       不同路径会经过同一个网格(i, j), 如果递归会重复计算
   1.3 无后效性
       走到 (i, j) 的最小代价只与当前位置有关，与路径顺序无关
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
     
     获取状态:
     要求从左上角 (0,0) 走到右下角 (m-1, n-1) 的最短路径和, 而走到 (i, j) 的最短路径和依赖于:
     - 从 上方(i - 1, j) 向下走到 (i, j) 的最短路径和
     - 从 左方(i, j - 1) 向右走到 (i, j) 的最短路径和
     因此定义: dp[i][j] = 从 (0, 0) 走到(i, j) 的最短路径和
   
   3. 列出选择(Choice)
      从左上角 (0, 0) 走到 (i, j), 机器人有且仅有 两种选择来源:
      - 从 上方(i - 1, j) 向下走到 (i, j)，消耗 dp[i-1][j] 的最小路径和。
      - 从 左方(i, j - 1) 向右走到 (i, j)，消耗 dp[i][j-1] 的最小路径和。
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j](当前格子的代价)
   
   5. 边界条件(初始化)
      从 (0, 0) 出发: dp[0][0] = grid[0][0], 因为从起点到起点的最小路径和就是起点自身的值。
      第一行初始化: 只能一直向右走, dp[0][j] = dp[0][j - 1] + grid[0][j]
      第一列初始化: 只要一直往下走, dp[i][0] = dp[i - 1][0] + grid[i][0]
      最终:
      dp[0][0] = grid[0][0]
      dp[0][j] = dp[0][j - 1] + grid[0][j]
      dp[i][0] = dp[i - 1][0] + grid[i][0]
   
    6. 计算顺序
      因为: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j](当前格子的代价), 因此计算 (i, j) 时需要先计算(i - 1, j) 和 (i, j - 1)。
      执行顺序
      - 从上到下(i 从 0 到 m - 1)
      - 从左到右(j 从 0 到 n - 1)
   
    7. 返回结果  
       我们要求的就是从 (0,0) 到达右下角 (m-1, n-1) 的最短路径和，因此直接返回 dp[m - 1][n - 1]
   ```
   
5. 零钱兑换
   ```text
   给定不同面额的硬币 coins 和一个总金额 amount, 求凑成总金额所需的最少硬币数量。如果凑不出，返回 -1
   
   示例:
   输入: coins = [1, 2, 5], amount = 11
   输出: 3
   解释: 11 = 5 + 5 + 1
   
   输入: coins = [2], amount = 3
   输出: -1
   
   1. 判断是否可用 DP
   1.1 最优子结构
      要凑出总金额为 i 的最少硬币数, 可以由:
      对于每种硬币:
      如果选择使用该 coin, 则转为求解 `凑出金额 i - coin 的最小硬币数量`, 再加上当前选用的这枚 coin(即 + 1)
      因此: 总金额 i 的最优解可以由子问题 i - coin 的最优解加上 1(当前硬币)得到
   1.2 重叠子问题
       不同选择的硬币组合过程中，可能多次遇到同一个子问题 amount = k(如同时 i - 1 和 i - 2 会求解相同的子问题)
   1.3 无后效性
       凑出总金额 i 所需的最少硬币数量, 只取决于当前子问题 i，与之前选择硬币的顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
      
      获取状态:
      每个硬币 coin, 如果选择当前硬币, 获取金额为 i - coin 的最少硬币数 + 1(当前硬币),
      因些定义: dp[i] 为获取金额为 i 的最少硬币数
   
   3. 列出选择(Choice)
      为了获取金额为 i 的最少硬币数, 对于每一个 coin, 有两种选择:
      - 不选当前硬币 coin, 此时 dp[i] 保持不变（继续保持之前的最优值）
      - 选择当前硬币 coin, 可以从子问题 dp[i − coin](i >= coin) 转移过来,表示“凑出金额 i - coin 所需的最少硬币数”, 再加上当前使用的这枚硬币 +1
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = min(dp[i], dp[i - coin]) + 1, i >= coin
      - dp[i]: 当前已经存储的凑出金额 i 的最少硬币数（初始化时是 inf 表示不可达）
      - dp[i - coin]: 凑出金额 i - coin 的最少硬币数
      - + 1: 表示加上当前选用的这枚 coin
   
   5. 边界条件(初始化)
      dp[0] = 0 (凑出金额 0 所需硬币数为 0)
      其他金额 dp[i] 初始设为 +∞（表示当前状态不可达，需要通过转移逐步更新）
   
   6. 计算顺序
      因为 dp[i] = min(dp[i], dp[i - coin]) + 1, i >= coin, 计算 dp[i] 时依赖 dp[i - coin], 因此:
      - 必须从小到大计算 i，保证 dp[i - coin] 在计算 dp[i] 前已被计算
      - 外层循环: 遍历 i = 1 .. amount(从 1 到目标金额)
      - 内层循环: 遍历每个 coin ∈ coins
   
   7. 返回结果 
      最终要求 `凑出金额 amount 所需的最少硬币数`，因此直接返回:
      若 dp[amount] != ∞，则返回 dp[amount]
      否则，若无法凑出金额 amount，返回 -1
   ```
   
6. 最长上升子序列
   ```text
   给定一个长度为 n 的整数数组 nums, 返回最长严格上升子序列的长度。
   
   示例:
   输入: nums = [10, 9, 2, 5, 3, 7, 101, 18]
   输出: 4
   解释: 最长上升子序列是 [2, 5, 7, 101], 长度为 4。
   
   输入: nums = [0,1,0,3,2,3]
   输出: 4
   
   输入: nums = [7,7,7,7,7,7,7]
   输出: 1
   
   1. 判断是否可用 DP
   1.1 最优子结构
       要求 `以 nums[i] 结尾的最长严格上升子序列长度`:
       如果选择包含 nums[i]:
       - 需要找出所有 j < i 且 nums[j] < nums[i] 的位置
       - 从中选择最长子序列长度 dp[j]
       - 再加上当前元素 nums[i](长度 + 1) 
   1.2 重叠子问题
       在计算不同位置的 LIS 时，会重复查询以同一个 j 结尾的最长上升子序列长度 dp[j]
   1.3 无后效性
       “以 nums[i] 结尾的最长上升子序列长度”只依赖于前面符合条件的状态 dp[j]，与之前选择的顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
      
      获取状态:
      为了求解【最长严格上升子序列（LIS）】:
       - 需要找出“以 nums[i] 结尾的最长严格上升子序列长度”
      如果考虑将 nums[i] 包含进子序列:
       - 就需要在所有满足 j < i 且 nums[j] < nums[i] 的位置 j 中，找出 dp[j] 最大的
       - 再加上当前元素 nums[i]（即 +1）
      因些定义: dp[i] 为以 nums[i] 结尾的最长严格上升子序列长度
   
   3. 列出选择(Choice)
      为了求以 nums[i] 结尾的最长严格上升子序列长度, 对于每一个位置j, 满足 j < i 且 nums[j] < nums[i], 有两种选择:
      - 不选当前 nums[j], 不更新 dp[i]，保持当前值（初始化时为 1，即只包含自己）
      - 选择当前 nums[j], 如果 nums[j] < nums[i]，则可以将 nums[i] 放在 nums[j] 的后面形成更长的严格上升子序列: dp[i] = dp[j] + 1
      对于所有满足条件的 j : dp[i] = max(dp[i], dp[j] + 1)
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = max(dp[i], dp[j] + 1)(j < i 且 nums[j] < nums[i])
   
   5. 边界条件(初始化)
      在【最长上升子序列（LIS）】问题中:
      - 每个位置 i 至少可以构成一个长度为 1 的严格上升子序列（即只包含 nums[i] 自身）
      - 因此，无论后续是否能拼接前面的子序列，最少长度都应为 1
   
      对于长度为 n 的数组:
      dp[i] = 1 
     
   6. 计算顺序
      因为 dp[i] = max(dp[i], dp[j] + 1)(j < i 且 nums[j] < nums[i]), 计算 dp[i] 时依赖 dp[j], 因此:
      - 必须保证在计算 dp[i] 前，所有 dp[j] (j < i) 已被计算
      - 外层循环: 遍历 i = 0 .. n - 1, 按从左到右依次计算每个位置 dp[i]
      - 内层循环: j < i 且 nums[j] < nums[i]
   
   7. 返回结果 
      最终要求返回数组 nums 的最长严格上升子序列的长度, 因此直接返回: max(dp[i])
   ```