# DP 练习
  
1. 斐波那契数列
  ```text
  给定整数 n，返回斐波那契数列的第 n 项（从 0 开始），即：
  - fib(0) = 0
  - fib(1) = 1
  - 对于 n >= 2, fib(n) = fib(n - 1) + fib(n - 2)
  
  示例:
  输入: n = 4
  输出: n = 3
  解释: fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3
  
  1. 是否可用 DP
  1.1 最优子结构
      计算 fib(n) 可拆成 fib(n-1) + fib(n-2)，由小问题直接组合得出大问题，符合最优子结构
  1.2 重叠子问题
      在递归中计算时，fib(n-1) 和 fib(n-2) 会被重复计算多次，存在重叠子问题。
  1.3 无后效性
      当前状态只取决于:
        当前 n 的值
        与历史的选择顺序(先算 n-1 还是先算 n-2)无关
        
  2. 定义状态
     状态是 `子问题的刻画`, 用于表达“当前子问题要做什么”
     我们需要求出:
     - 当 n = 0 时的结果
     - 当 n = 1 时的结果
     - 当 n = 2 时的结果
     ...
     - 一直到 n = n 的结果
     
     定义: dp[i] = fib(i), 表示斐波那契数列第 i 项的值
     
  3. 列出选择(Choice)
     我们要求: dp[i] = fib(i)
     求 dp[i] 时有哪些选择?
       根据斐波那契数列定义: fib(n) = fib(n - 1) + fib(n - 2)
       在求 dp[i] 时需要:
         1️⃣ 选择使用 dp[i-1]（即斐波那契第 i-1 项的值）
         2️⃣ 选择使用 dp[i-2]（即斐波那契第 i-2 项的值）
       然后将二者相加，得到当前 dp[i] 的值。  
     可理解为: 在状态 i 时，我们“选择”使用前一个状态和前前一个状态来构造当前状态的值。
     
  4. 写出转移方程(递推公式)
     将“选择”转化为最优性方程: 
     dp[i] = dp[i-1] + dp[i-2](i >= 2) 
     
  5. 边界条件(初始化)
     根据: 斐波那契数列
     - fib(0) = 0
     - fib(1) = 1 
     得到:
     - dp[0] = 0
     - dp[1] = 1  
     
  6. 计算顺序
     由于 dp[i] 依赖于 dp[i - 1] 和 dp[i - 2], 必须先计算 i - 1 和 i - 2 的值,  必须从 i = 2 开始顺序计算到 i = n
     
  7. 返回结果   
      最终我们要求的就是: dp[i], 即 fib(n)
  ```

2. 爬楼梯
   ```text
   假设你正在爬楼梯, 需要 n 阶你才能到达楼顶。每次你可以爬 1 阶或 2 阶
   问你有多少种不同的方法可以爬到楼顶？
   
   示例:
   输入：n = 3
   输出：3
   解释：
       - 1 阶 + 1 阶 + 1 阶
       - 1 阶 + 2 阶
       - 2 阶 + 1 阶
   
   1. 判断是否可以用 DP
   1.1 最优子结构
       爬到第 n 阶, 可以由:
         - 从 n - 1 阶再爬 1 阶
         - 从 n - 2 阶再爬 2 阶
       得到。
       因此爬到第 n 阶的总方案数 = 爬到 n - 1 阶的方案数 + 爬到 n - 2 阶的方案数
   1.2 重叠子问题
       在递归计算时，爬到 n-1 和 n-2 会重复计算相同阶数时的方案数。
   1.3 无后效性。
       爬到第 n 阶的方法数只与当前阶数 n 有关，与到达此阶的路径无关(顺序不影响结果)。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
      获取状态:
        我们需要获取:
        - 爬到 n-1 阶的方案数(从 n-1 阶再爬 1 阶)
        - 爬到 n-2 阶的方案数(从 n-2 阶再爬 2 阶)
      因此定义: dp[i] = 爬到第 i 阶的方法数, 用于表示从地面爬到第 i 阶共有多少种不同的方法
   
   3. 列出选择(Choice)
      爬到第 i 阶, 有两种选择路径
      - 从 i-1 阶再爬 1 阶到达 i
      - 从 i-2 阶再爬 2 阶到达 i
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程:
      dp[i] = dp[i - 1] + dp[i - 2], i >= 2    
   
   5. 边界条件(初始化)
      从 0 阶（地面）开始爬:
      - dp[0] 表示 爬到第 0 阶的方法数，也就是原地不动的方案数
      - 通常定义为 1，表示“什么都不做”，这对递推有帮助
      - dp[0] = 1
   
      爬到第 1 阶的方法数（dp[1])
      - 只有一种方法: 直接爬 1 阶
      - dp[1] = 1
      
      所以:
      起点只有 1 种方案——原地不动: dp[0] = 1
      爬 1 阶只有 1 种方法: dp[1] = 1 
   
   6. 计算顺序
      从小到大依次计算 dp[2] 到 dp[n]
     
   7. 返回结果   
      最终我们要求的就是: dp[n]
   ```