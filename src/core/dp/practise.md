# DP 练习
  
1. 斐波那契数列
  ```text
  给定整数 n，返回斐波那契数列的第 n 项（从 0 开始），即：
  - fib(0) = 0
  - fib(1) = 1
  - 对于 n >= 2, fib(n) = fib(n - 1) + fib(n - 2)
  
  示例:
  输入: n = 4
  输出: n = 3
  解释: fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3
  
  1. 是否可用 DP
  1.1 最优子结构
      计算 fib(n) 可拆成 fib(n-1) + fib(n-2)，由小问题直接组合得出大问题，符合最优子结构
  1.2 重叠子问题
      在递归中计算时，fib(n-1) 和 fib(n-2) 会被重复计算多次，存在重叠子问题。
  1.3 无后效性
      当前状态只取决于:
        当前 n 的值
        与历史的选择顺序(先算 n-1 还是先算 n-2)无关
        
  2. 定义状态
     状态是 `子问题的刻画`, 用于表达“当前子问题要做什么”
     我们需要求出:
     - 当 n = 0 时的结果
     - 当 n = 1 时的结果
     - 当 n = 2 时的结果
     ...
     - 一直到 n = n 的结果
     
     定义: dp[i] = fib(i), 表示斐波那契数列第 i 项的值
     
  3. 列出选择(Choice)
     我们要求: dp[i] = fib(i)
     求 dp[i] 时有哪些选择?
       根据斐波那契数列定义: fib(n) = fib(n - 1) + fib(n - 2)
       在求 dp[i] 时需要:
         1️⃣ 选择使用 dp[i-1]（即斐波那契第 i-1 项的值）
         2️⃣ 选择使用 dp[i-2]（即斐波那契第 i-2 项的值）
       然后将二者相加，得到当前 dp[i] 的值。  
     可理解为: 在状态 i 时，我们“选择”使用前一个状态和前前一个状态来构造当前状态的值。
     
  4. 写出转移方程(递推公式)
     将“选择”转化为最优性方程: 
     dp[i] = dp[i-1] + dp[i-2](i >= 2) 
     
  5. 边界条件(初始化)
     根据: 斐波那契数列
     - fib(0) = 0
     - fib(1) = 1 
     得到:
     - dp[0] = 0
     - dp[1] = 1  
     
  6. 计算顺序
     由于 dp[i] 依赖于 dp[i - 1] 和 dp[i - 2], 必须先计算 i - 1 和 i - 2 的值,  必须从 i = 2 开始顺序计算到 i = n
     
  7. 返回结果   
      最终我们要求的就是: dp[i], 即 fib(n)
  ```

2. 爬楼梯
   ```text
   假设你正在爬楼梯, 需要 n 阶你才能到达楼顶。每次你可以爬 1 阶或 2 阶
   问你有多少种不同的方法可以爬到楼顶？
   
   示例:
   输入：n = 3
   输出：3
   解释：
       - 1 阶 + 1 阶 + 1 阶
       - 1 阶 + 2 阶
       - 2 阶 + 1 阶
   
   1. 判断是否可以用 DP
   1.1 最优子结构
       爬到第 n 阶, 可以由:
         - 从 n - 1 阶再爬 1 阶
         - 从 n - 2 阶再爬 2 阶
       得到。
       因此爬到第 n 阶的总方案数 = 爬到 n - 1 阶的方案数 + 爬到 n - 2 阶的方案数
   1.2 重叠子问题
       在递归计算时，爬到 n-1 和 n-2 会重复计算相同阶数时的方案数。
   1.3 无后效性。
       爬到第 n 阶的方法数只与当前阶数 n 有关，与到达此阶的路径无关(顺序不影响结果)。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
      获取状态:
        我们需要获取:
        - 爬到 n-1 阶的方案数(从 n-1 阶再爬 1 阶)
        - 爬到 n-2 阶的方案数(从 n-2 阶再爬 2 阶)
      因此定义: dp[i] = 爬到第 i 阶的方法数, 用于表示从地面爬到第 i 阶共有多少种不同的方法
   
   3. 列出选择(Choice)
      爬到第 i 阶, 有两种选择路径
      - 从 i-1 阶再爬 1 阶到达 i
      - 从 i-2 阶再爬 2 阶到达 i
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程:
      dp[i] = dp[i - 1] + dp[i - 2], i >= 2    
   
   5. 边界条件(初始化)
      从 0 阶（地面）开始爬:
      - dp[0] 表示 爬到第 0 阶的方法数，也就是原地不动的方案数
      - 通常定义为 1，表示“什么都不做”，这对递推有帮助
      - dp[0] = 1
   
      爬到第 1 阶的方法数(dp[1])
      - 只有一种方法: 直接爬 1 阶
      - dp[1] = 1
      
      所以:
      起点只有 1 种方案——原地不动: dp[0] = 1
      爬 1 阶只有 1 种方法: dp[1] = 1 
   
   6. 计算顺序
      从小到大依次计算 dp[2] 到 dp[n]
     
   7. 返回结果   
      最终我们要求的就是: dp[n]
   ```
   
3. 不同路径
   ```text
   一个机器人位于 m x n 网格的左上角(起点在(0, 0))。
   机器人每次只能 `向下或向右移动一步`, 机器人试图到达网格的右下角(终点在(m - 1, n - 1))。
   问有多少条不同的路径到达终点。
   
   示例:
   输入: m = 3, n = 2 
   输出: 3
   
   解释:
   下 -> 下 -> 右
   下 -> 右 -> 下
   右 -> 下 -> 下
   
   1.  判断是否可以用 DP
   1.1 最优子结构
       要走到 (i, j) 的路径数, 可以由:
       - 从 上方(i - 1, j) 向下走到 (i, j)
       - 从 左方(i, j - 1) 向右走到 (i, j)
       得到。
       因此要走到 (i, j) 的方案数可以由子问题(到达(i - 1, j) 和 (i, j - 1))组合得到, 满足最优子结构。
   1.2 重叠子问题
       不同路径会经过同一格(i, j), 需要反复计算从 (0, 0) 到 (i, j) 的路径数。
   1.3 无后效性
       走到(i, j) 的方案数, 只依赖位置 (i, j), 与路径的历史顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
     
     获取状态:
     要求从左上角 (0,0) 走到右下角 (m-1, n-1) 的方案数, 而走到 (i, j) 的方案数依赖于:
     - 从 上方(i - 1, j) 向下走到 (i, j) 的方案数
     - 从 左方(i, j - 1) 向右走到 (i, j) 的方案数
     因此定义: dp[i][j] = 从 (0, 0) 走到(i, j) 的不同路径数
   
   3. 列出选择(Choice)
      从左上角 (0, 0) 走到 (i, j), 有两种不同的路径:
      - 从 上方(i - 1, j) 向下走到 (i, j) 
      - 从 左方(i, j - 1) 向右走到 (i, j) 
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
   
   5. 边界条件(初始化)
      从 (0,0) 到 (0,0) 不需要走，默认就在那里,计作 1 种方式(即 `原地不动` 也是一种方案):
      dp[0][0] = 1
      
      对于第一行 dp[0][j], 只能向右走到(0, j), 每个格子只有 1 种走法, 因此: dp[0][j] = 1
      对于第一列 dp[i][0], 只能面下走到(i, 0), 每个格子只有 1 种走法, 因此: dp[i][0] = 1
   
     最终:
     dp[0][0] = 1
     dp[0][j] = 1
     dp[i][0] = 1
   
   6. 计算顺序
      因为: dp[i][j] = dp[i - 1][j] + dp[i][j - 1], 因此计算 (i, j) 时需要先计算(i - 1, j) 和 (i, j - 1)。
      执行顺序
      - 从上到下(i 从 0 到 m - 1)
      - 从左到右(j 从 0 到 n - 1)
   
   7. 返回结果  
      我们要求的就是从 (0,0) 到达右下角 (m-1, n-1) 的不同路径数，因此返回 dp[m - 1][n - 1]
   ```
   
4. 最小路径和
   ```text
   给定一个 m x n 的网格 grid, 网格中每个单元格包含一个非负整数, 表示走到该位置的代价。
   机器人从左上角(0, 0) 出发, 只能 向右或向下 移动, 直到到达右下角(m - 1, n - 1)。
   求：从左上角到右下角路径上数字之和的最小值(最小代价)。
   
   示例:
   输入: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]
   输出: 7
   解释: 路径 1 -> 3 -> 1 -> 1 -> 1, 总和 = 7
   
   1.  判断是否可以用 DP
   1.1 最优子结构
       要走到(i, j), 可以由:
       - 从 上方(i - 1, j) 向下走一下到 (i, j)
       - 从 左边(i, j - 1) 向左走一下到 (i, j)
       得到。
       从 (0,0) 到 (i,j) 的最小路径和，等于到达 (i-1, j) 或 (i, j-1) 的最小路径和 + grid[i][j]
   1.2 重叠子问题
       不同路径会经过同一个网格(i, j), 如果递归会重复计算
   1.3 无后效性
       走到 (i, j) 的最小代价只与当前位置有关，与路径顺序无关
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
     
     获取状态:
     要求从左上角 (0,0) 走到右下角 (m-1, n-1) 的最短路径和, 而走到 (i, j) 的最短路径和依赖于:
     - 从 上方(i - 1, j) 向下走到 (i, j) 的最短路径和
     - 从 左方(i, j - 1) 向右走到 (i, j) 的最短路径和
     因此定义: dp[i][j] = 从 (0, 0) 走到(i, j) 的最短路径和
   
   3. 列出选择(Choice)
      从左上角 (0, 0) 走到 (i, j), 机器人有且仅有 两种选择来源:
      - 从 上方(i - 1, j) 向下走到 (i, j)，消耗 dp[i-1][j] 的最小路径和。
      - 从 左方(i, j - 1) 向右走到 (i, j)，消耗 dp[i][j-1] 的最小路径和。
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j](当前格子的代价)
   
   5. 边界条件(初始化)
      从 (0, 0) 出发: dp[0][0] = grid[0][0], 因为从起点到起点的最小路径和就是起点自身的值。
      第一行初始化: 只能一直向右走, dp[0][j] = dp[0][j - 1] + grid[0][j]
      第一列初始化: 只要一直往下走, dp[i][0] = dp[i - 1][0] + grid[i][0]
      最终:
      dp[0][0] = grid[0][0]
      dp[0][j] = dp[0][j - 1] + grid[0][j]
      dp[i][0] = dp[i - 1][0] + grid[i][0]
   
    6. 计算顺序
      因为: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j](当前格子的代价), 因此计算 (i, j) 时需要先计算(i - 1, j) 和 (i, j - 1)。
      执行顺序
      - 从上到下(i 从 0 到 m - 1)
      - 从左到右(j 从 0 到 n - 1)
   
    7. 返回结果  
       我们要求的就是从 (0,0) 到达右下角 (m-1, n-1) 的最短路径和，因此直接返回 dp[m - 1][n - 1]
   ```
   
5. 零钱兑换
   ```text
   给定不同面额的硬币 coins 和一个总金额 amount, 求凑成总金额所需的最少硬币数量。如果凑不出，返回 -1
   
   示例:
   输入: coins = [1, 2, 5], amount = 11
   输出: 3
   解释: 11 = 5 + 5 + 1
   
   输入: coins = [2], amount = 3
   输出: -1
   
   1. 判断是否可用 DP
   1.1 最优子结构
      要凑出总金额为 i 的最少硬币数, 可以由:
      对于每种硬币:
      如果选择使用该 coin, 则转为求解 `凑出金额 i - coin 的最小硬币数量`, 再加上当前选用的这枚 coin(即 + 1)
      因此: 总金额 i 的最优解可以由子问题 i - coin 的最优解加上 1(当前硬币)得到
   1.2 重叠子问题
       不同选择的硬币组合过程中，可能多次遇到同一个子问题 amount = k(如同时 i - 1 和 i - 2 会求解相同的子问题)
   1.3 无后效性
       凑出总金额 i 所需的最少硬币数量, 只取决于当前子问题 i，与之前选择硬币的顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
      
      获取状态:
      每个硬币 coin, 如果选择当前硬币, 获取金额为 i - coin 的最少硬币数 + 1(当前硬币),
      因些定义: dp[i] 为获取金额为 i 的最少硬币数
   
   3. 列出选择(Choice)
      为了获取金额为 i 的最少硬币数, 对于每一个 coin, 有两种选择:
      - 不选当前硬币 coin, 此时 dp[i] 保持不变（继续保持之前的最优值）
      - 选择当前硬币 coin, 可以从子问题 dp[i − coin](i >= coin) 转移过来,表示“凑出金额 i - coin 所需的最少硬币数”, 再加上当前使用的这枚硬币 +1
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = min(dp[i], dp[i - coin]) + 1, i >= coin
      - dp[i]: 当前已经存储的凑出金额 i 的最少硬币数（初始化时是 inf 表示不可达）
      - dp[i - coin]: 凑出金额 i - coin 的最少硬币数
      - + 1: 表示加上当前选用的这枚 coin
   
   5. 边界条件(初始化)
      dp[0] = 0 (凑出金额 0 所需硬币数为 0)
      其他金额 dp[i] 初始设为 +∞（表示当前状态不可达，需要通过转移逐步更新）
   
   6. 计算顺序
      因为 dp[i] = min(dp[i], dp[i - coin]) + 1, i >= coin, 计算 dp[i] 时依赖 dp[i - coin], 因此:
      - 必须从小到大计算 i，保证 dp[i - coin] 在计算 dp[i] 前已被计算
      - 外层循环: 遍历 i = 1 .. amount(从 1 到目标金额)
      - 内层循环: 遍历每个 coin ∈ coins
   
   7. 返回结果 
      最终要求 `凑出金额 amount 所需的最少硬币数`，因此直接返回:
      若 dp[amount] != ∞，则返回 dp[amount]
      否则，若无法凑出金额 amount，返回 -1
   ```
   
6. 最长上升子序列
   ```text
   给定一个长度为 n 的整数数组 nums, 返回最长严格上升子序列的长度。
   
   示例:
   输入: nums = [10, 9, 2, 5, 3, 7, 101, 18]
   输出: 4
   解释: 最长上升子序列是 [2, 5, 7, 101], 长度为 4。
   
   输入: nums = [0,1,0,3,2,3]
   输出: 4
   
   输入: nums = [7,7,7,7,7,7,7]
   输出: 1
   
   1. 判断是否可用 DP
   1.1 最优子结构
       要求 `以 nums[i] 结尾的最长严格上升子序列长度`:
       如果选择包含 nums[i]:
       - 需要找出所有 j < i 且 nums[j] < nums[i] 的位置
       - 从中选择最长子序列长度 dp[j]
       - 再加上当前元素 nums[i](长度 + 1) 
   1.2 重叠子问题
       在计算不同位置的 LIS 时，会重复查询以同一个 j 结尾的最长上升子序列长度 dp[j]
   1.3 无后效性
       “以 nums[i] 结尾的最长上升子序列长度”只依赖于前面符合条件的状态 dp[j]，与之前选择的顺序无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
      
      获取状态:
      为了求解【最长严格上升子序列（LIS）】:
       - 需要找出“以 nums[i] 结尾的最长严格上升子序列长度”
      如果考虑将 nums[i] 包含进子序列:
       - 就需要在所有满足 j < i 且 nums[j] < nums[i] 的位置 j 中，找出 dp[j] 最大的
       - 再加上当前元素 nums[i]（即 +1）
      因些定义: dp[i] 为以 nums[i] 结尾的最长严格上升子序列长度
   
   3. 列出选择(Choice)
      为了求以 nums[i] 结尾的最长严格上升子序列长度, 对于每一个位置j, 满足 j < i 且 nums[j] < nums[i], 有两种选择:
      - 不选当前 nums[j], 不更新 dp[i]，保持当前值（初始化时为 1，即只包含自己）
      - 选择当前 nums[j], 如果 nums[j] < nums[i]，则可以将 nums[i] 放在 nums[j] 的后面形成更长的严格上升子序列: dp[i] = dp[j] + 1
      对于所有满足条件的 j : dp[i] = max(dp[i], dp[j] + 1)
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = max(dp[i], dp[j] + 1)(j < i 且 nums[j] < nums[i])
   
   5. 边界条件(初始化)
      在【最长上升子序列（LIS）】问题中:
      - 每个位置 i 至少可以构成一个长度为 1 的严格上升子序列（即只包含 nums[i] 自身）
      - 因此，无论后续是否能拼接前面的子序列，最少长度都应为 1
   
      对于长度为 n 的数组:
      dp[i] = 1 
     
   6. 计算顺序
      因为 dp[i] = max(dp[i], dp[j] + 1)(j < i 且 nums[j] < nums[i]), 计算 dp[i] 时依赖 dp[j], 因此:
      - 必须保证在计算 dp[i] 前，所有 dp[j] (j < i) 已被计算
      - 外层循环: 遍历 i = 0 .. n - 1, 按从左到右依次计算每个位置 dp[i]
      - 内层循环: j < i 且 nums[j] < nums[i]
   
   7. 返回结果 
      最终要求返回数组 nums 的最长严格上升子序列的长度, 因此直接返回: max(dp[i])
   ```
   
7. 零钱兑换II
   ```text
   给定不同面额的硬币和一个总金额，求有多少种组合可以凑成总金额
   - 每种硬币可无限使用
   - 返回组合数(不是最少硬币数)
   
   示例:
   输入: coins = [1, 2, 5], amount = 5
   输出: 5
   
   1. 判断是否可用 DP
   1.1 最优子结构
       要凑出金额 i 的组合数：
       可以从选择 coins 中某个 coin 入手。
       选择 coin 后，子问题变为：“凑出金额 i - coin 的组合数”。
       对每个硬币都做此选择，累加其子问题结果，得到最终的总组合数。
   1.2 重叠子问题
       在不同选择组合路径下，可能多次需要知道 amount = k 时的组合数
   1.3 无后效性
       凑出总金额 i 的组合, 与之前使用硬币的顺序无关（只要最终选的组合相同），不依赖于选择顺序，只依赖于子问题规模（金额大小和可选硬币集合）。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
     每个硬币 icon, 如果选择该硬币, 获取金额为 i - coin 的组合数
     因些定义: dp[i] 为获取金额为 i 的所有组合数
   
   3. 列出选择(Choice)
      为了获取金额为 i 的所有组合数, 对于每一个 coin, 有两种选择:
      - 不选当前硬币 coin, 此时 dp[i] 保持不变(继续保持之前的最优值)
      - 选择当前硬币 coin, 等价于在凑出金额 i - coin 的组合方案基础上，增加当前硬币 coin, 即: dp[i] += dp[i - icon]
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = dp[i] + dp[i - icon]
      - dp[i]: 当前已经存储的凑出金额 i 的组合数
      - dp[i - icon]: 凑出金额 i - coin 的组合数
   
   5. 边界条件(初始化)
      dp[0] = 1 (凑出金额 0 的组合数)
      其他金额: dp[i] = 0
   
   6. 计算顺序
      因为 dp[i] = dp[i] + dp[i - coin], i >= coin, 计算 dp[i] 时依赖 dp[i - coin], 因此:
      - 必须从小到大计算 i，保证 dp[i - coin] 在计算 dp[i] 前已被计算
      - 外层循环: 遍历每个 coin ∈ coins
      - 内层循环: 遍历 i = 1 .. amount(从小到大)
   
   7. 返回结果 
      最终要求 `凑出金额 amount 的所有组合`，因此直接返回 dp[amount]
   ```
   
8. 最长回文子序列
   ```text
   最长回文子序列:
   给定一个字符串 s, 请你求出 s 中, 最长回文子序列(不要求连续)的长度
   
   示例:
   输入 s = "bbbab"
   输出: 4
   解释: 一个可能的最长回文子序列是 "bbbb"
   
   1. 判断是否可用 DP
   1.1 最优子结构
       求字符串 s[l..r] 的最长回文子序列长度, 若:
       s[l] = s[r], 则: 长度 = 2 + s[l + 1..r - 1] 的最长回文子序列长度
       s[l] != s[r], 最长回文子序列一定不可能同时包含s[l] 和 s[r] 两个字符(因为回文需要对称), 则: 长度 = max(s[l + 1..r], s[l..r - 1]) 的最长回文子序列长度
   1.2 重叠子问题
       (l, r) 会被不同选择重复访问
   1.3 无后效性
       最长回文子序列的长度, 只取决于当前子问题 s[l..r], 与之前是如何选择或到达 l,r 无关。
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
      获取状态:
      问题是求字符串 s 的最长回文子序列长度, 子问题可以定义为: 计算字符串区间 s[l..r] 中最长回文子序列的长度。
      l 和 r 是两个边界索引，标识了当前关注的字符串子区间
      状态即用 (l, r) 表示。
      因些定义: dp[l][r] 为字符串区间 s[l..r]的最长回文子序列长度
   
   3. 列出选择(Choice)
      为了求字符串 s[l..r] 的最长回文子序列长度, 有以下两种选择:
      - s[l] = s[r]:
        此时两端字符相同，可以被计入回文长度贡献
        那么，s[l] 和 s[r] 贡献长度 2
        剩下要继续计算中间部分 s[l+1..r-1] 的最长回文子序列长度
        dp[l][r] = dp[l + 1][r - 1] + 2  
      - s[l] != s[r]
        两端字符不同，不能同时出现在同一个回文子序列的两端
        有两个选择:
        1️⃣ 不考虑 s[l]，则问题变为求 s[l+1..r] 的最长回文子序列长度。
        2️⃣ 不考虑 s[r]，则问题变为求 s[l..r-1] 的最长回文子序列长度。
        要取这两种选择中的最大值: 
        dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])
   
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: 
      - s[l] = s[r]:
        两端字符相同，可以纳入回文长度
        可“收缩区间”到中间 s[l+1..r-1] 再加上两端的 2
        公式: dp[l][r] = dp[l + 1][r - 1] + 2  
   
      - s[l] != s[r]
        两端字符不同，此时:
        要么舍弃左边，考虑 s[l+1..r]
        要么舍弃右边，考虑 s[l..r-1]
        取其中能形成最长回文子序列的最大值
        公式: dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])
   
   5. 边界条件(初始化)
      - 当 l == r (区间长度为 1) 时:
        区间只包含一个字符，回文长度就是 1
        初始化: dp[i][i] = 1 (i 从 0 到 n - 1)
      - 当 l > r (空区间) 时:
        不存在的区间，回文长度为 0
        在递归写法时会隐含处理: dp[l][r] = 0 (l > r)
   
   6. 计算顺序
      - s[l] = s[r]
        dp[l][r] = dp[l + 1][r - 1] + 2 
        此时需要保证 dp[l + 1][r - 1] 先被计算
      - s[l] != s[r]
        max(dp[l + 1][r], dp[l][r - 1])
        此时需要保证 dp[l + 1][r] 和 dp[l][r - 1] 先被计算
   
     最终:
        n: 字符串的长度
        len: 当前正在计算的子区间长度(包含的字符数量) 
        外层循环: 遍历 1 到 n, 先计算长度为 1 的区间（即单个字符），再计算长度为 2，依次递增，保证依赖状态已被计算
        内层循环: 遍历 0 到 n - len, 因为区间长度固定为 len，终点 r 唯一确定, 遍历所有可能的 l，保证区间覆盖完整

     for len in 1..= n:          # 从短到长
        for l in 0..= n - len:    # 所有起点, 对于长度 len 的区间，要保证不越界, 终点 r = l + len - 1，不能超过 n-1, 所以最大 l 是 n - len
           r = l + len - 1    # 唯一对应的终点
   
   7. 返回结果
      我们要求整个字符串（s[0..=n-1]）的最长回文子序列长度, 因此直接返回: dp[0][n - 1]
   ```
   
9. 最长公共子序列
   ```text
   给定两个字符串 text1 和 text2, 返回这两个字符串的 `最长公共子序列` 的长度
   子序列: 可以不连续, 但保持顺序
   例如:
   text1 = "abcde"
   text2 = "ace"
   返回3(因为 `ace` 是最长公共子序列)
   
   1. 判断是否可用 DP
   1.1 最优子结构
     求两个字符串 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度, 若:
     text1[i - 1] = text2[j - 1], 可以将这对字符加入 LCS, 长度 = text1[0..i - 2] 和 text2[0..j - 2] 最长公共子序列长度 + 1
     text1[i - 1] != text2[j - 1], 此时不能同时选这两个字符, 则长度 = text1[0..i - 1] 和 text2[0..j - 1] 最长公共子序列长度
   1.2 重叠子问题
       在不同选择路径下，(i, j) 的组合会被重复计算
   1.3 无后效性
       当前状态 dp[i][j] 只依赖于 dp[i-1][j-1], dp[i-1][j], dp[i][j-1]
   
   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
   
     获取状态:
      要计算 text1 和 text2 的最长公共子序列长度, 将问题缩小为子问题 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度
      i - 1 是 text1 当前考虑的末尾位置
      j - 1 是 text2 当前考虑的末尾位置
     (i, j) 可唯一确定当前考虑的子区间范围
      i - 1 和 j - 1 是两个边界索引，标识了字符串子区间
      状态即用 (i, j) 表示。
      因些定义: dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
   
   3. 列出选择 (Choice)
      为了求 text1 和 text2 的最长公共子序列长度, 有两种选择:
      - text1[i - 1] = text2[j - 1]:
      两端字符串相同计入 LCS
      剩下只需求解 text1[i - 2] 和 text2[j - 2] 的最长公共子序列的长度
      dp[i][j] = dp[i - 1][j - 1] + 1
   
      - text1[i - 1] != text2[j - 1]:
      两端字符串不同, 不能计入 LCS, 有两种选择:
      1️⃣ 不考虑 text1[i - 1]，则问题变为求 text1[i - 2] 和 text2[j - 1] 的最长公共子序列的长度
      2️⃣ 不考虑 text2[j - 1]，则问题变为求 text1[i - 1] 和 text2[j - 2] 的最长公共子序列的长度
      要取这两种选择中的最大值:
      dp[i][j] = max(dp[i-1][j], dp[i][j - 1])
      
   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: 
      - text1[i - 1] = text2[j - 1]:
      两端字符相同, 可计处 LCS 尾部, 长度 + 1
      dp[i][j] = dp[i - 1][j - 1] + 1
   
      - text1[i - 1] != text2[j - 1]
      两端字符不同, 无法计入 LCS:
      要么舍弃 text1[i - 1], 看 dp[i - 1][j]
      要么舍弃 text2[j - 1], 看 dp[i][j - 1]
      取其中能形成最长公共子序列的长度
      dp[i][j] = max(dp[i-1][j], dp[i][j - 1])
   
   5. 边界条件(初始化)
      当 i = 0 或 j = 0 时:
      - 表示其中 有一个字符串为空
      - 空串与任何字符串的 LCS 长度都为 0
      因此: 
      第一行全 0：dp[0][j] = 0
      第一列全 0：dp[i][0] = 0
      dp[0][j] = 0 (0 <= j <= n)
      dp[i][0] = 0 (0 <= i <= m)
   
   6. 计算顺序
      - text1[i - 1] = text2[j - 1]
        dp[l][r] = dp[l - 1][j - 1] + 1 
        此时需要保证 dp[l - 1][j - 1] 先被计算
      - text1[i - 1] != text2[j - 1]
        max(dp[i-1][j], dp[i][j - 1])
        此时需要保证 dp[i-1][j] 和 dp[i][j - 1] 先被计算
   
     最终:
        外层循环: i 从 1 到 m(text1 长度)
        内层循环: j 从 1 到 n(text2 长度)
   
   7. 返回结果
       我们要求两个字符串 text1 和 text2 这两个字符串的 `最长公共子序列` 的长度, 因此直接返回: dp[m][n], 表示 text1[0..m-1] 与 text2[0..n-1] 的最长公共子序列长度
   ```
   
10. 最长递增子序列的长度
   ```text
   给定一个长度为 n 的整数数组 nums, 返回最长严格递增子序列的长度。
   如:
   输入 nums = [10, 9, 2, 5, 3, 7, 101, 18]
   输出: 4
   解释: 最长递增子序列是 [2,3,7,101]，因此长度为 4

   1. 判断是否可用 DP
   1.1 最优子结构
       求 nums[0..n-1] 最长严格递增子序列, 考虑是否选择 nums[i], 则变成子问题: 前面比 nums[i] 小的 nums[j](j < i) 中最长递增子序列长度, 然后再加 1
   1.2 重叠子问题
       计算以 nums[i] 结尾的 LIS 时，会多次计算以 nums[j] 结尾的 LIS(j < i)
   1.3 无后效性
       当前子问题 LIS(nums, i) 只依赖于 nums[i] 的值 和 前面各子问题的状态, 与选择顺序、未来决策无关。

   2. 定义状态(State)
      什么是状态?
      - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
     
      每个数 nums[i], 如果选择该数, 则变成前面比 nums[i] 小的 nums[j](j < i) 中最长递增子序列长度
      因此定义: dp[i] 为以 nums[i] 结尾的最长严格递增子序列的长度

   3. 列出选择
      对于当前值 nums[i]，求以 nums[i] 结尾的最长严格递增子序列长度, 有两种选择:
      - 选择当前 nums[i],  等价于前面比 nums[i] 小的 nums[j](j < i) 的基础上, 再加 1, 即: dp[i] = max(dp[i], dp[j] + 1)
      - 不选择当前 nums[i], 此时 dp[i] 保持不变(继续保持之前的最优值)
      - 如果前面没有比 nums [i] 更小的数, 则 dp[i] = 1 

   4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[i] = max(dp[i], dp[j] + 1)(j < i), 如果没有符合条件的 j, 则 dp[i] = 1
   
   5. 边界条件(初始化)
      dp[i] = 1 (如果只考虑 nums[i] 自身作为子序列, 也算是一个 长度为 1 的严格递增子序列)

   6. 计算顺序
      因为 dp[i] = max(dp[i], dp[j] + 1), 计算 dp[i] 时需要先计算 dp[j], 因此:
      - 保证 dp[j] 在计算 dp[i] 前已被计算
      - 外层循环: 遍历每个 i ∈ nums (0..n-1)
      - 内层循环: 遍历 j = 0..i

   7. 返回结果 
      最终要求 `返回 nums[0..n-1] 最长严格递增子序列的长度`，因此:
      - dp[i] 表示以 nums[i] 结尾的最长严格递增子序列的长度
      - 整个数组的最长严格递增子序列长度是所有 dp[i] 的最大值: max(dp[i], dp[j] + 1)(j < i)
      - 如果某个 nums[i] 前面没有比它小的数，初始化时 dp[i] = 1(单独一个数的长度就是1)
   ```

11. 不同的二叉搜索树
    ```text
    给定一个整数 n，求由 1 ... n 为节点组成的不同二叉搜索树的个数。
    
    1 判断是否可以用 DP
    1.1 最优子结构
        对于 n 个不同的数(1..n), 选择其中 i 作为根节点:
        - 左子树 1.. i - 1 构成, 形成 dp[i - 1] 种不同的 BST
        - 右子树 i + 1..n 构成, 形成 dp[n - i] 种不同的 BST
    1.2 重叠子问题
       对于不同的根 i，会多次使用相同的子问题 dp[k]（即同样大小的子树方案数）
    1.3 无后效性
       二叉搜索树的结构只依赖于子树大小和组合方式，与插入顺序或未来状态无关
    
    2. 定义状态
       什么是状态?
       - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。
       
       对于固定的总节点数 = i（即值域大小为 i）, 以每个值 j (l <= j <= i) 作为根节点:
         - 左子树由 j - 1 个节点组成
         - 右子树由 i - j 个节点组成
         - 两边子树分别构成 dp[j - 1] 和 dp[i - j] 种 BST
         - 因为左右子树互相独立，组合数相乘(每种左子树都可以和任意一种右子树组合, 因此组合数相乘)
         - 所以以 j 为根的方案数 = dp[j - 1] * dp[i - j]
       
       因此定义: dp[i] = 由 1..i构成不同 BST 的总数
    
    3. 列出选择
       为了计算由 1..n 构成的不同二叉搜索树个数, 选择哪一个值 j ∈ [1, n] 作为根节点, 一旦选定根节点 j:
       - 左子树只能使用 1..j-1，可构成 dp[j - 1] 种 BST
       - 右子树只能使用 j+1..n，可构成 dp[n - j] 种 BST
       因此: 对于每个 j(作为根), 组合方式数 = 左子树方案数 × 右子树方案数, 最终统计所有可能的根节点 j 的方案数之和，即为总不同 BST 个数
    
    4. 写出转移方程(递推公式)
      将“选择”转化为最优性方程: dp[j] = dp[j - 1] * dp[i - j]
    
    5. 边界条件(初始化)
       dp[0] = 1 (空树也是一种合法的 BST)
       dp[1] = 1 (单节点树只有一种 BST)
    
    6. 计算顺序
       因为 dp[j] = dp[j - 1] * dp[i - j], 计算 dp[j] 时需要先计算 dp[j - 1] 和 dp[i - j], 因此:
      - 保证 dp[j] 在计算 dp[j - 1] 和 dp[i - j] 前已被计算
      - 外层循环: 遍历每个 i = 2 .. n (从小规模子问题到大规模)
      - 内层循环: 遍历 j = 1..i (枚举每个节点作为根)
    
    7. 返回结果 
       最终要求 `返回 1..n 组成的不同二叉搜索树的个数`，因此直接返回 dp[n]
    ```