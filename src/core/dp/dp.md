# 动态规划(Dynamic Programming)
  动态规划(DP)是一种 `通过将原问题拆解为子问题, 保存子问题的解(记忆化)避免重复计算, 从而高效求解最优解` 的方法
  与回溯穷举的 `枚举所有可行解` 不同, 动态规划 `只枚举不同子问题的状态, 并记录最优解`
  
1. 特性
   - `最优子结构 + 重叠子问题 + 无后效性`
   - 最优子结构(Optimal Substructure)
     - 一个问题的最优解包含其子问题的最优解
     - 例: 求最短路径，整条路径的最短长度包含子路径的最短长度
   - 重叠子问题(Overlapping Subproblems)
     - 大问题拆解的子问题之间是重复的, 若直接递归会重复求解相同的子问题
     - 通过记录(备忘录或表格)避免重复计算
   - 无后效性(No Aftereffect)
     - 当前状态的决策只依赖于前面的状态, 不依赖于决策路径本身
   
2. 时间复杂度
   - 取决于 `状态数量 × 每个状态的转移计算复杂度`
   - 通常 `O(N^2)`、`O(NM)` 量级(比回溯快得多)
   
3. 空间复杂度
   - 通常需要 `O(N)`、`O(NM)` 空间记录状态(表格或滚动数组)
   - 可使用 `状态压缩` 优化空间

4. 使用场景
   - 背包问题(01 背包、多重背包)
   - 最长公共子序列(LCS)
   - 最短路径问题(Dijkstra、Floyd)
   - 硬币找零问题(完全背包)
   - 股票买卖问题
   - 编辑距离
   - 划分问题(子集和问题)
   
5. 实际使用场景
   - `优化问题 + 重叠子问题 + 需要缓存子状态避免重复计算`
   - 降低计算复杂度(从指数降到多项式)
   - 获得可解释的最优解(状态推导链可回溯)
   - 简化逻辑(避免回溯时的复杂分支剪枝)
   - 路径规划(地图导航、机器人路径)
     - 场景
       - 高德地图、谷歌地图导航中找最短路径
       - 仓储机器人在仓库最短路径取货
     - 对应问题
       - 最短路径问题(Dijkstra、Floyd、Bellman-Ford)都用到 DP 思想
       - 网格型地图求从左上到右下最短路径、最小代价路径
     - 为什么用 DP
       - 子路径的最优性可复用(最优子结构)
       - 避免重复计算相同位置下的状态(重叠子问题)
   - 资源分配与成本优化
     - 场景
       - 云服务器资源分配(CPU、内存分配最优成本)
       - 项目排期以最小成本完成最大收益
       - 投资组合最大收益
     - 对应问题
       - 0/1 背包问题、多重背包问题
       - 完全背包问题(无限资源情况下最优分配)
     - 为什么用 DP
       - 每个资源的选择是否放入组合与容量有关，组合可能重叠
       - 只需求最大值而非所有组合
   - 序列比较与版本控制
     - 场景
       - Git Diff、VS Code Diff 文件比较
       - DNA 序列比对
       - 拼写纠正、自然语言处理文本相似度计算
     - 对应问题
       - 最长公共子序列(LCS)
       - 编辑距离(Levenshtein Distance)
     - 为什么用 DP
       - 两个序列的比较结果依赖于子串的比较结果
       - 子问题重叠且组合数巨大，暴力无法计算
   - 财务计算(股票买卖)
     - 场景
       - 股票买卖收益最大化
       - 交易次数有限时如何最大化利润
     - 对应问题
       - 股票买卖系列问题(k 次交易最大利润)
     - 为什么用 DP
       - 某一天买卖决策依赖于前几天买卖状态，且存在重复状态
       - 状态量化、状态转移关系明确
   - 拼接、切割、填充问题
     - 场景
       - 切割钢条获得最大收益(生产排产优化)
       - 切割广告时间片最大收益
       - 填充货物到固定容量容器(填充最优组合)
     - 对应问题
       - 切割钢条问题(与完全背包类似)
     - 为什么用 DP
       - 大问题由小问题切割组合而成，存在重叠子问题
   - 游戏与 AI
     - 场景
       - 游戏自动寻路(地图走迷宫)
       - 博弈类游戏的最优解策略(如 Nim 游戏)
       - Reinforcement Learning 中的 Value Iteration、Policy Iteration 均基于 DP
     - 对应问题
       - 确定在每一步做什么决策使长期收益最大
     - 为什么用 DP
       - 子状态组合最优决策
       - 可缓存状态避免重复计算
   - 图像处理与机器学习
     - 场景
       - 图像分割、图像拼接
       - HMM 隐马尔可夫模型中 Viterbi 算法用于解码最可能的隐藏状态序列
       - CRF 条件随机场的序列标注问题
     - 对应问题
       - 最优路径求解
       - 最大概率路径估计
     - 为什么用 DP
       - 可能路径组合太多
       - 重叠状态需要缓存避免重复计算
   - 自然语言处理(NLP)
     - 场景
       - 分词、词性标注
       - 拼写纠错
       - 句子最优分割
     - 对应问题
       - 分词使用最大概率路径(使用 Viterbi)
       - 编辑距离用于相似度计算与纠错
     - 为什么用 DP
       - 子问题之间的重叠
       - 状态之间存在转移和概率积累，需缓存最优结果

6. 举例
   ```text
   问题: 求第 n 个斐波那契数
   定义:
     - F(0) = 0
     - F(1) = 1
     - F(n) = F(n-1) + F(n-2)
   
   步骤:
   1. 明确状态
   状态: 设 dp[i] 表示第 i 个斐波那契数的值
   
   2. 明确转移方程(递推公式)
   根据定义 
       dp[i] = dp[i - 1] + dp[i - 2]
   
   3. 边界条件(初始化)
   dp[0] = 0, dp[1]= 1
   
   4. 状态计算顺序
   i 从 2 到 n, 依次计算 dp[i]
   
   5. 时间复杂度
   计算 n 次, 每次 `O(1)`, 因此时间复杂度为 O(n)
   
   6. 空间复杂度
   若保留整个dp数组, 空间复杂度 O(N)
   若只保留 dp[i - 1] 和 dp[i - 2], 可优化为 O(1)
   ```
   ```text
   0/1 背包问题
   问题: 有 N 件物品, 每件物品的重量为 w[i], 价值为 v[i], 背包容量为 W, 求能装下的最大价值
   
   1. 明确状态
   定义: 
       dp[i][j] = 在前 i 件物品中, 容量不超过 j 时的最大价值
   
   2. 明确转移方程
   两种情况:
   - 不选第 i 件: dp[i][j] = dp[i - 1][j]
   - 选第 i 件: dp[i][j] = dp[i - 1][j - w[i]] + v[i]
   取最大值: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])
   
   3. 边界问题(初始化)
   dp[0][*] = 0, 表示不选任何物品时最大价值为 0
   
   4. 状态计算顺序
   i 从 1 到 N
   j 从 0 到 W
   
   5. 时间复杂度
   O(NW)
   
   6. 空间复杂度
   若完整表格 `O(NW)`
   可使用 `滚动数组` 优化到 `O(W)`
   ```
   
7. 如何从暴力递归转换为动态规划
   - 明确 `状态` 是什么(子问题的定义)
     - 参数中哪些会变化, 需要记录下来
   - 明确 `选择` 是什么(递归分支情况)
     - 每一步有哪些选择，选择如何影响状态
   - 明确 `转移方程`
     - 如何通过子问题推导父问题
   - 明确 `边界条件`
   - 优化空间(可选)

8. 动态规划本质总结
   - 只要满足
     - 最优子结构
     - 重叠子问题
     - 无后效性
   - 就可以使用动态规划, 将指数复杂度问题降为多项式复杂度
   - 与回溯的区别
     - 回溯暴力遍历所有可能，时间复杂度高
     - 动态规划通过记录子问题，避免重复计算
   - 与滑动窗口的区别
     - 滑动窗口用于维护动态区间满足条件时的最优子区间，通常用于 `连续区间统计问题`
     - 动态规划用于 `需要组合、选择子问题状态进行最优性决策的问题`

9. 编辑距离(Levenshtein Distance)
   是衡量两个字符串相似度的一种方式, 表示: `将一个字符串转换成另一个字符串所需的最少编辑操作次数` 
   编辑操作包括:
   - 插入(Insert)
   - 删除(Delete)
   - 替换(Replace)
   每次操作的代码均为 1
   ```text
   word1 = "kitten"
   word2 = "sitting"
   最小编辑操作:
   1. kitten → sitten(k→s 替换)
   2. sitten → sittin(e→i 替换)
   3. sittin → sitting(插入 g)
   总操作数 = 3, 编辑距离 = 3
   
   word1 = "horse"
   word2 = "ros"
   最小编辑操作:
   1. horse → rorse(h→r 替换)
   2. rorse → rose(删除 o)
   3. rose → ros(删除 e)
   总操作数 = 3, 编辑距离 = 3
   ```
   - 编辑距离的实际应用场景
     - 拼写纠正
       - 判断输入词与字典词的相似度，取距离最小的词做自动纠正
     - DNA / RNA 序列比对
       - 比较基因序列差异程度
     - 自然语言处理中的相似度计算
       - 比较两个句子的相似度用于模糊搜索
     - 版本控制 diff 工具
       - 比较文件差异时，衡量不同文本之间的最小修改量
   - 编辑距离的动态规划求解
     - 由于:
       - 大问题 = 小问题状态的组合(最优子结构)
       - 同一子字符串组合出现多次(重叠子问题)
   ```text
   word1 = "horse"
   word2 = "ros"
   
   1. 状态定义
   设 word1 长度为 n, word2 长度为 m
   dp[i][j] 表示将 word1[0..i - 1] 转换为 word2[0..j - 1] 的最小操作数
   
   2. 转换方程(递推公式)
   考虑 word1[i - 1] 与 word2[j - 1]:
   如果 word1[i - 1] = word2[j - 1], 则不需要操作: dp[i][j] = dp[i - 1][j - 1]
   如果不同, 则需要考虑三种情况:
     1. 插入: dp[i][j - 1] + 1
     2. 删除: dp[i - 1][j] + 1
     3. 替换: dp[i - 1][j - 1] + 1
   取最小值:
     dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1)
   
   3. 边界条件(初始化)
      dp[0][j] = j: 将空串转换为 word2[0..j - 1] 需要插入 j 次
      dp[i][0] = i: 将 word1[0..i - 1] 转换为空串需要删除 i 次
   
   4. 时间和空间复杂度
      时间复杂度：O(n * m)，需要遍历所有 i 和 j
      空间复杂度：O(n * m)，需要记录表格
   若进行空间优化(滚动数组):
      空间可优化到 O(min(n, m))
   
   示例:
   1. 初始化 dp 表
         ''  r   o   s
       +---+---+---+---+
    '' | 0 | 1 | 2 | 3 |
     h | 1 |   |   |   |
     o | 2 |   |   |   |
     r | 3 |   |   |   |
     s | 4 |   |   |   |
     e | 5 |   |   |   |

   填表:
   -> dp[1][1]: 'h' vs 'r', 不同
   -> min(dp[0][1] + 1 = 2(删除), dp[1][0] + 1 = 2(插入), dp[0][0] + 1 = 1(替换)) = 1
   -> dp[1][2]: 'h' vs '0', 不同
   -> min(dp[0][2] + 1 = 3(删除), dp[1][0] + 1 = 2(插入), dp[1][0] + 1 = 2(替换)) = 2
   -> dp[1][3]: 'h' vs 's', 不同
   -> min(dp[0][3] + 1 = 4(删除), dp[1][0] + 1 = 2(插入), dp[2][0] + 1 = 3(替换)) = 3
   ```
   
10. 步骤
    - 判断是否可以用 DP
      - 是否满足最优子结构(子问题最优解可组合成原问题最优解)
        - 一个 `大问题的最优解`, 可以通过 `子问题的最优解组合得到`, 且 `组合方式简单(如加一步操作、加当前值)`
      - 是否存在重叠子问题(递归子问题会被重复计算)
        - 在递归拆解问题时, 会 `反复计算相同子问题`, 可以 `将中间结果存储下来避免重复计算(即用 DP 代替纯递归)`
      - 是否无后效性(状态只与子状态结果相关，与决策路径无关)
        - 某一状态（子问题）的最优解 `不会依赖于如何到达这个状态的路径`, `只依赖于当前“状态本身”的数据`(如 i 和 j)
    - 定义状态(State)
      - 状态是什么？
        `状态 = 当前子问题的描述方式`
      - 使用哪些变量唯一标识一个子问题？
      - 示例:
        - 斐波那契: `dp[i] = 第 i 个斐波那契数`
        - 背包: `dp[i][j] = 前 i 个物品，容量不超过 j 的最大价值`
        - 编辑距离: `dp[i][j] = word1[0..i-1] 转换为 word2[0..j-1] 的最少操作数`
    - 明确选择(Choice)
      - 每个状态如何从子状态转移得到
        - 对每个子问题，考虑有哪些可选操作(选、不选、插入、删除、替换等)
    - 写出转移方程(递推公式)
      - 结合子问题最优解，推导出当前状态的最优值
    - 边界条件(Base Case)
      - 写出递推的起点
        - `dp[0][]`、`dp[][0]` 是什么？
        - `dp[0]`、`dp[1]` 是什么？
      - 示例
        - 斐波那契: `dp[0] = 0`, `dp[1] = 1`
        - 编辑距离: `dp[0][j] = j`, `dp[i][0] = i`
        - 背包：`dp[0][*] = 0`
    - 确实计算顺序
      - 保证依赖的子状态在使用前已经被计算
        - 一维从小到大顺序遍历
        - 二维
          - i 从 1..n
          - j 从 1..m
        - 完全背包或特殊依赖时注意遍历方向
    - 返回结果
      - 通常是
        - 一维: `dp[n]`
        - 二维: `dp[n][m]`
        - 或根据题意找最大/最小值遍历 dp 数组取最大值
    - 空间优化(可选)
      - 如果 `dp[i][j]` 只依赖 `dp[i-1][*]`，可压缩到一维滚动数组，降低空间复杂度
    - 口诀
      - `判可用 → 定状态 → 列选择 → 写方程 → 边界条件 → 遍历顺序 → 返回结果`
      - 并始终牢记
        - 子问题是什么？
        - 如何通过子问题得出当前问题？
        - 如何避免重复计算？
    
11. 详细示例(背包问题)
    ```text
    在一个容量为 W 的背包中，给你 N 件物品，每件物品有:
    - 重量 w[i]
    - 价格 v[i]
    问: 在不超过容量 W 的前提下，能装入物品的 `最大总价值` 是多少。
    
    1. 判断是否可用 DP
    刷题时，判断是否可用 DP 的 核心逻辑是：
    ✅ 是否有“最优子结构”？
       一个 `大问题的最优解`, 可以通过 `子问题的最优解组合得到`, 且 `组合方式简单(如加一步操作、加当前值)`
       大问题的最优解可以由小问题的最优解组合得来。
    ✅ 是否有“重叠子问题”？
       当用递归解时，会重复计算相同的子问题(相同选择与容量组合)。
    ✅ 是否无后效性？
       当前的决策不会影响后续状态转移(只和当前状态有关)
    
    1.1 是否有“最优子结构”？
        在前 i 件物品和容量 j 下的最优解可以由前 i - 1 件物品和容量 j(不选第 i 件) 或容量 j - w[i](选第 i 件) 组件得出。
    1.2 是否有“重叠子问题”？
        相同 i 和 j 的组合在递归中会被反复计算
    1.3 是否无后效性？
        只要知道前 i 件和容量 j 下的最优解即可转移到后续状态, 不依赖选择顺序。
    
    2. 定义状态(State)
       什么是状态?
       状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么
    
    2.1 获取状态:
        我们需要描述:
         - 前多少件物品,
         - 当前可用容量
        因此定义: dp[i][j] = 在前 i 件物品中，容量不超过 j 时，能获得的最大总价值
    
        为什么是 i 和 j ?
        - i 表示 `考虑了前 i 件物品`:
          - 用来表示我们是否考虑当前这件物品
          - 有助于我们“选与不选”做状态转移
        - j 表示 `当前背包的剩余的容量(0 ~ W)`:
          - 我们需要考虑容量限制，保证不超过容量
       
        为什么是 i - 1 和 j - w[i]?
        推导时:
        - `dp[i-1][j]` 表示 `不选第 i 件物品，容量不变`
        - `dp[i-1][j-w[i]]` 表示 `选了第 i 件物品，因此前 i-1 件物品容量剩余为 j-w[i]`
        这些用于转移方程时有非常清晰的物理含义，保证我们从子问题的结果转移到父问题结果
    
    3. 列出选择(Choice)
       在考虑第 i 件物品时，有两种选择:
       - ✅ 不选：容量不变，价值不变，转移来自 dp[i-1][j]
       - ✅ 选：容量减少 w[i]，价值增加 v[i]，转移来自 dp[i-1][j-w[i]] + v[i](这里用 dp[i - 1] 防止重复选到 C, 如果可以重复选就用 dp[i])
    
    4. 写出转移方程(递推公式)
       将“选择”转化为最优性方程:
       dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
       - dp[i-1][j]: 不选第 i 件物品
       - dp[i-1][j-w[i]] + v[i]: 选第 i 件物品(前提是 j - w[i] >= 0)
       最终取两者较大的，确保价值最大
    
       为什么要取 max?
       因为我们要在容量限制下使总价值最大。
    
    5. 边界条件(初始化)
       - dp[0][*] = 0: 表示不选任何物品时，无论容量是多少，价值都为 0
       - dp[*][0] = 0: 容量为 0 时，无论是否考虑物品，价值都为 0
    
    6. 计算顺序
       由于 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i-1][j-w[i]], 必须先计算 i - 1 层后计算第 i 层
       遍历:
          i 从 1 ~ N
          j 从 0 ~ W
    
    7. 返回结果
       最终我们要求的就是: dp[N][W]
       即: ✅ 考虑了所有 N 件物品，✅ 容量不超过 W 时的最大价值
    ```
    
12. 详细示例(编辑距离) 
    ```text
    word1="horse"
    word2="ros"
    求将 word1 转成 word2 的最少编辑步骤数, 允许:
    插入一个字符
    删除一个字符
    替换一个字符
    
    1. 判断是否可用 DP
    1.1 是否有“最优子结构”？
       将 "horse" 转成 "ros" 至少需要几步:
       可以拆成:
       - 先将 "hors" 转成 "ros", 再考虑 "e"
       - 或先将 "horse" 转成 "ro", 再考虑 "s"
       - 或先将 "hors" 转成 "ro", 再考虑 "e" 和 "s"
       这些“小问题最优解”可被用于构造“大问题最优解”，符合最优子结构。
    
    1.2 是否有“重叠子问题”？
        在不同拆解路径中可能多次需要:
        - "ho" 转 "ro" 的最少操作数
        - "hor" 转 "r" 的最少操作数
        ... 
    这些子问题会在不同路径下反复出现，因此完全符合重叠子问题。
    
    1.3 是否无后效性？
        - 当前在考虑 word1 的前 i 个字符
        - 当前在考虑 word2 的前 j 个字符
        - 以及从这两段字符串相互转换所需的最少操作数
    就足够求下一步的结果，不关心具体做了哪些操作到达这里。
    
    2. 定义状态(State)
       状态 = 当前子问题的描述方式
      
       把 word1 转成 word2 最少需要多少步？
       拆解: 把 word1 的 前 i 个字符(0..i-1) 转成 ord2 的 前 j 个字符(0..j-1), 需要最少多少步?
       得到: dp[i][j] = 将 word1 的前 i 个字符转成 word2 的前 j 个字符所需的最少操作数
    
    3. 列出选择(Choice)
       我们正在考虑
        - word1 的第 i 个字符(下标 i-1)
        - word2 的第 j 个字符(下标 j-1)
    
       可能发生三种操作:
         1. 删除 word1 的第 i 个字符(下标 i - 1)
            如果 word1[i - 1] 与 word2[j - 1] 不同, 可以选择删除 word[i - 1],
            继续考虑"前 i - 1 字符" 去匹配 word2 的前 j 个字符
            对应子问题:
            从 dp[i-1][j] 转移过来(因为 word1 缩短了，word2 不变), 删除操作 +1 步
         2. 插入字符到 word1，使其匹配 word2 的第 j 个字符(直接使用最后一个位置插入, 插入位置不重要, 只要插入后能保证“word1 的前 i 个字符”能与 “word2 的前 j 个字符”匹配即可)
            如果 word1[i-1] 与 word2[j-1] 不同，我们想使它们匹配，可以选择在 word1 末尾插入 word2[j-1]
            因为我们希望最终 word1 和 word2 一致，因此在 word1 末尾插入字符时，一定要插入 word2 当前对应位置的字符，即 word2[j-1]
            对应子问题:
            插入后, word1 变长(i 不变)，但 word2 的这一位视作已经匹配(j-1)，所以考虑: dp[i][j - 1] + 1
         3. 替换 word1 的第 i 个字符(下标 i - 1)为 word2 的第 j 个字符(下标 j - 1)
            如果不相同，可以直接替换，使其匹配
            对应子问题:
            替换后两者末位相同，因此下一步看前 i-1 个字符与前 j-1 个字符如何匹配: dp[i - 1][j - 1] + 1
       还有一个特殊情况:
          如果 word1[i-1] 和 word2[j-1] 相同，则不需要操作，可以直接继承子问题 dp[i-1][j-1]
    
    4. 写出转移方程(递推公式)
       结合选择:
       如果字符相同，没必要操作，最优操作数跟 dp[i-1][j-1] 一样: dp[i][j] = dp[i - 1][j - 1]
       如果不同, 只能三选一:
       - 删除: dp[i - 1][j] + 1
       - 插入：dp[i][j - 1] + 1
       - 替换: dp[i - 1][j - 1] + 1
       取最小值: dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1)
       如果末位相同，无需操作: dp[i][j] = dp[i - 1][j - 1]
    
    5. 边界条件(初始化)
       考虑 i=0 或 j=0
       dp[0][j]: word1 空串转 word2 前 j 个字符, 只能插入 j 次(插入所有字符)
       dp[i][0]: word1 前 i 个字符转空串, 只能删除 i 次(删光所有字符)
    
    6. 计算顺序
       要保证计算 dp[i][j] 时，dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 已经计算好。
       所以:
         外层循环 i 从 0 到 m
         内层循环 j 从 0 到 n
       按照行列顺序依次填充，保证依赖状态存在
    
    7. 返回结果
       最后，dp[m][n] 就是把整个 word1 转换成整个 word2 的最少编辑操作数。
    ```
    
13. 如何分析问题
   - 如何判断能否用 DP？
     - ✅最优子结构
       - 问题 `能否分解为子问题`？
       - `大问题最优解` 是否可由 `子问题最优解 + 当前决策` 得到？
     - ✅重叠子问题
       - 不同决策路径是否会重复遇到相同子问题？
       - 如果递归写法会超时，需要记忆化避免重复计算？
     - ✅无后效性
       - 状态是否只与当前的“子问题规模”有关，与历史决策顺序无关？
   - 如何“拆解问题”？
     - ❓题目要求最小/最大值吗？
       - 如果是 → 80% 是 DP 或贪心
     - ❓问题能拆成规模更小的同类问题吗？
       - 即“问题规模减少”后问题结构不变。
       - 如:
         - 子串/子数组/子集问题
         - 前 i 个元素、容量为 j
         - 树上子问题
         - 1 ~ n 区间的问题
     - ❓重复子问题出现了吗？
       - 如:
         - 从 i 到 j 的最小/最大
         - 容量为 c，物品 i
         - 前缀为 i，后缀为 j
     - 如果出现 → 用记忆化 / DP。
   - 如何定义状态？
     - 状态是 `子问题的刻画`, 用于表达 `当前子问题要做什么`
     - ⚡ 模板记忆:
       - 字符串问题: `dp[i][j] = word1 前 i，word2 前 j 的关系（匹配、编辑距离）`
       - 数组问题: `dp[i] = 前 i 个元素时的最优值`
       - 背包问题: `dp[i][j] = 前 i 个物品，在容量 j 下的最优值`
       - 区间问题(如戳气球、矩阵链乘): dp[l][r] = 区间 l~r 的最优值
     - 思考法
       - ❓`如果问题规模减小一格（如 i-1），问题会变成什么？`
     - 答案就是你的状态定义
   - 如何写转移方程？
     - 1️⃣ 选择是什么？
       - 对于当前状态，你有哪些选择(取/不取，插入/删除/替换，切/不切)？
     - 2️⃣ 选择后子问题变成什么？
       - 选择后问题规模发生的变化(i-1？j-1？i？j-1？)
     - 3️⃣ 目标是什么？
       - 最大？最小？可行性？
     - 然后用: dp[...] = min/max(dp[子问题] + 当前代价), 即可写出方程。

14. DP 中是否需要双重循环，什么时候看得出来？
    - 只需要单层循环的 DP
      - 子问题转移来自固定范围：dp[i] = dp[i-1] + dp[i-2]（如爬楼梯、斐波那契）
      - 不需要内层枚举，直接用固定关系转移。
    - 需要双重循环（内层枚举）的 DP
      - 当状态依赖于前面一系列满足条件的位置
        - LIS（依赖所有 j < i 且 nums[j] < nums[i] 的位置）
        - LCS（依赖 dp[i-1][j-1]）
        - 完全背包、0/1 背包（枚举容量、物品）
      - 就需要内外循环结构：
        - 外层遍历子问题规模 (i)
        - 内层枚举可转移的位置 (j) 或决策（选与不选某物品）
    - 总结
      - 是否可用 DP
        - 能否用子问题最优解递推出大问题
        - 看问题是否是【最值、计数、可行性】问题
      - 分析子问题依赖
        - 只依赖单一状态：单层循环
        - 依赖前面多个状态满足条件的最优值：双重循环，内层用于遍历可选状态或决策空间。
        - 很多字符串相关问题，尤其是 `最长回文子序列`、`最长公共子序列` 等，都会考虑首尾字符是否相等
      - 必须先想解题思路
        - 不要直接套 DP 模板，先问自己
          - 我要求的最终结果是啥？
          - 能否由子问题得到？
          - 子问题需要看哪些子状态？
          - 是否需要在状态上加更多维度（如二维 DP）？
      
15. DP 方案
    - 组合选择 × 独立排列 → 乘法(DP = 枚举根节点，每次加上 左子树方案 * 右子树方案)
    - 单侧选择最大/最小 → 取 min/max
    - 不同选择结果总和 → 加法