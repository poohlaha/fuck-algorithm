# 回溯算法(Backtracking)
  回溯算法是一种 `系统地搜索问题所有解的算法`:
  - 本质是 `试探 + 撤销`
  - 将问题分解为多个步骤, 每一步尝试所有可能的选择
  - 如果某一步发现当前选择不可行(不满足约束或不可能得到最优解), 则 `撤销该选择(回溯)并尝试其他选择`
  - 常用于
    - 组合问题
    - 排列问题
    - 子集问题
    - 路径问题(迷宫、图遍历)
    - 约束满足问题(N 皇后、数独)
    
1. 特性
   - 递归树遍历
     - 回溯本质是 `在递归树上深度优先搜索`:
       - 每一层表示一个决策步骤(选择一个元素、放置棋子等)
       - 每个分支表示不同选择
       - 回溯是在 `深度遍历时发现无效或不优时回退到上一步`，换另一条路径继续探索
   - 可撤销性
     - 每一步做出选择后，如果发现无法继续(或约束不满足)，可以撤销选择
       - 撤销上一步的选择，恢复现场(状态恢复)
       - 尝试下一种可能性
   - 剪枝
     - 为了避免遍历所有无效状态，可使用剪枝
       - 可行性剪枝(当前选择无效直接回退)
       - 最优性剪枝(当前分支不可能产生更优解时回退)
       
2. 时间复杂度
   - 回溯时间复杂度通常取决于:
     - 决策深度 d(通常是选择的步数)
     - 每步可选的分支数 b
   - 最坏情况下需要遍历完整棵树: O(b^d)
   - 具体例子
     - N 皇后: 约 O(N!)
     - 子集问题(集合大小为 n): O(2^n)
     - 排列问题: O(n!)
   - 若加剪枝, 复杂度可大幅降低, 但最坏情况下通常仍是指数级

3. 空间复杂度
   - 回溯使用递归, 空间复杂度: `O(d)`, `d` 为 `决策深度`

4. 使用场景
   - 需要穷举所有可能解
     - 子集生成
     - 全排列
     - 组合问题
   - 需要找到可行解
     - 迷宫可达性
     - 图遍历找路径
   - 需要满足约束的可行解
     - N 皇后(每行、列、对角线只能放一个皇后)
     - 数独(每行、列、九宫格不能重复)
   - 需要找到满足条件的最优解(可配合剪枝)
   
5. 举例
  ```text
  问题: 在 N * N 棋盘上放 N 个皇后, 使得任意两个皇后不在同一行、同一列、同一对角线上, 输出所有可行方案
  
  1. 从第 0 行开始深度放置皇后
  2. 当前行的第一列尝试放置:
     - 检查当前列和两条对角线上是否有皇后
     - 如有冲突, 撤销(继续下一列)
     - 如果无冲突, 放置皇后, 进入下一行
  3. 重复步骤 2, 直到:
     - 放到第 N 行, 表示已放置完 N 个皇后, 记录结果
     - 或者当前行已无可放列, 返回上一步(回溯), 撤销上一步的放置并继续尝试下一列
  4. 不断回溯 + 尝试直到遍历完所有状态   
  ```

6. 回溯 VS 其他算法
   ```text
   特性          回溯算法         贪心算法           动态规则
   可穷举所有解	✅	            ❌	              ❌
   可撤销试探 	✅	            ❌	              ❌
   用于求最优解	可(配合剪枝)  	可(局部最优)        ✅(全局最优)
   时间复杂度  	指数级	        通常较低	          通常较低
   空间复杂度  	O(d)	        O(1)	          O(n) 或 O(n^2)
   
   回溯适用于:
     - 问题规模较小
     - 需要完整解空间
     - 需要找出所有可行解或可行方案数量
   ```
  
7. 模板
   `回溯 = DFS + 状态撤销（回退） + 可选剪枝`
   - 核心过程:
     - 判断递归结束条件(`找到解` or `走到尽头`)
     - 在当前位置尝试所有可选选择
     - 做选择(标记状态、压入路径)
     - 递归探索下一步
     - 撤销选择(回退状态、弹出路径)
   ```text
   result = []
   fn backtrack(当前状态) {
      if 满足约束条件 {
        result.push(当前状态的拷贝)
        return
      }
   
      for choice in 当前状态的所有可选选择 {
        if 不合法(chioce) { // 剪枝
          contine;
        }
   
        做选择(chioce) // 修改状态
        backtrack(更新后的状态) // 递归探索
        撤销选择(chioce) // 恢复状态(回退)
      }
   }
   
   解释:
   1. 结束条件
      - 如: `长度 == k`、`已遍历完所有行` 等
   2. 可选选择
      - 在组合问题中: 可选的下一个数
      - 在排列问题中: 所有未使用过的数
      - 在 N 皇后问题中: 本行的所有列
   3. 做选择
      - 将元素加入 path
      - 标记 visited、占用列、对角线等
   4. 递归探索下一层
      - 常是递归到下一层(下一步、下一行)
   5. 撤销选择(回退)
      - 从 path 中移除元素
      - visited/状态标记撤销
   ```
