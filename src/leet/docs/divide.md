# 分治法(Divide and Conquer)
  分治法(Divide and Conquer) 是一种算法设计思想，解决问题的思路是:
  - 分解(Divide): 把一个复杂的问题分成多个规模较小、结构相似的子问题。
  - 解决(Conquer): 递归地解决这些子问题。当子问题足够简单时，直接解决。
  - 合并(Combine): 将子问题的解合并起来，得到原问题的解。
  - 简单来说，就是 `把问题拆分成小块，分别解决，再把答案拼起来`

1. 特性
   - 递归结构明显
     - 分治法天然是递归的，因为它会不断把问题拆解成更小的子问题
   - 子问题相互独立
     - 分治的子问题之间通常是独立的，互不干扰，这使得它很适合并行计算
   - 适合规模较大、结构相似的问题
     - 比如排序、查找、矩阵运算、数论等
   - 存在合并步骤
     - 不仅仅是解决子问题，还需要把多个子问题的结果合并成整体解
   - 存在分解和合并成本影响算法效率合并步骤
     - 如果分解太复杂或者合并太耗时，算法效率会受影响

2. 使用场景
   - 排序算法
     - 归并排序、快速排序都用到了分治
   - 查找问题
     - 二分查找(虽然简单，但也是分治思想的体现)
   - 数值计算
     - 大整数乘法(Karatsuba算法)、矩阵乘法(Strassen算法)
   - 组合问题
     - 快速傅里叶变换、凸包算法
   - 求解递归问题
     - 斐波那契数列的优化(分治法+记忆化)
   
3. 举例
   ```text
   字符串: ["flower", "flow", "flight", "flute"]
   
   1. 把整个数组分成两部分
      左半部分: ["flower", "flow"]
      右半部分: ["flight", "flute"]
   
   2. 分别递归求左半部分的最长公共前缀和右半部分的最长公共前缀
      对 ["flower", "flow"]:
   -> 再分解为 "flower" 和 "flow"
   -> 两个字符串直接求最长公共前缀，比较字符
   -> f == f, l == l, o == o, w == w, e != (flow 比 flower 短，不匹配)
   -> 结果是 flow
   
      对 ["flight", "flute"]
   -> 分解为 "flight" 和 "flute"
   -> 两个字符串直接求最长公共前缀，比较字符
   -> f == f, l == l, i != u
   -> 结果是 fl
   
   3. 合并左右两部分的结果 "flow" 和 "fl":
   -> 比较字符:
   -> f == f, l == l, o != (l 比 flow 短，不匹配)
   -> 所以两个部分的最长公共前缀是 "fl"   
   
   复杂度:
        每次将问题对半拆分，递归深度是 O(log n)，其中 n 是字符串数量
        合并时最长公共前缀比较两个字符串，最坏比较字符串长度 m
        所以整体时间复杂度大概是 O(m * n)，其中 m 是字符串平均长度，n 是字符串个数
        空间复杂度主要是递归栈深度 O(log n)
   
   总结:
        分治求公共前缀就是:
        把字符串列表分成两半，各自求最长公共前缀
        合并左右的最长公共前缀得到整体最长公共前缀
        递归到只剩一个字符串时，返回它自身
   
   二分优化 LCP(Longest Common Prefix, LCP):
   1. 核心思路
      最长公共前缀一定在: 
         - 长度范围: [0, minLen]
         - 其中 minLen = 所有字符串中最短字符串的长度
      关键思路
         使用二分判断 `长度为 mid 的前缀是否在所有字符串中都相同`
         - 如果是，说明 LCP 至少为 mid，继续向右二分
         - 如果否，说明 LCP 必须小于 mid，继续向左二分
   
   2. 为什么可以用二分优化
      因为: `长度为 k 的前缀都相同` = `长度为 <= k 的前缀也都相同` (满足单调性)
      满足 `前缀长度越短越容易相同` 的单调性质, 所以可以用二分查找最大全匹配的长度
   
   3. 优势对比
      假设:
          字符串数量：n
          字符串长度：m  
   
      垂直扫描 / 分治: 
          最坏时间复杂度：O(n * m)
   
      二分优化:
          二分查找次数：O(log m)
          每次检查所有字符串是否匹配长度 mid：O(n * mid)，最坏 mid ≈ m
      
      合起来:
           最坏时间复杂度：O(n * m * log m)
           但在实际场景下（LCP 较短时），通常显著减少了比较字符的次数
      
      综合:
           时间复杂度: O(log n)
           空间复杂度: O(1)
   
   4. 举例说明
      字符串: ["flower", "flow", "flight"]
     
      找 minLen
   -> flower = 6, flow = 4, flight = 6, minLen = 4
   -> 搜索范围: left = 0, right = 4
   
      二分过程
   -> mid = (0 + 4) / 2 = 2
   -> 检查前缀长度 = 2
   -> flower: [0, 2] = fl, flow: [0, 2] = fl, flight: [0, 2] = fl, 都相同
   -> 更新: left = mid + 1 = 3
   
   -> mid = (3 + 4) / 2 = 3
   -> 检查前缀长度 = 3
   -> flower: [0, 3] = flo, flow: [0, 3] = flo, flight: [0, 3] = fli, 不相同
   -> 更新: right = mid - 1 = 2
   
   -> left > right
   -> 终止
   
   最长公共前缀长度 = (left + right) / 2 = (3 + 2) / 2 = 2
   最终公共前缀 = fl
   
      字体串: ["interstellar", "internet", "internal", "interval"]
     
      找 minLen
   -> interstellar = 12, internet = 8, internal = 8, interval = 8, minLen = 8
   -> 搜索范围: left = 0, right = 8
   
      二分过程
   -> mid = (0 + 8) / 2 = 4
   -> 检查前缀长度 = 4
   -> interstellar: [0, 4] = inte, internet: [0, 4] = inte, internal: [0, 4] = inte, interval: [0, 4] = inte 都相同
   -> 更新: left = mid + 1 = 4 + 1 = 5
   
   -> mid = (5 + 8) / 2 = 6
   -> 检查前缀长度 = 6  
   -> interstellar: [0, 6] = inters, internet: [0, 4] = intern, internal: [0, 4] = interna, interval: [0, 4] = interv 不相同
   -> 更新: right = mid - 1 = 6 - 1 = 5
   
   -> mid = (5 + 5) / 2 = 5
   -> 检查前缀长度 = 5
   -> interstellar: [0, 5] = inter, internet: [0, 5] = inter, internal: [0, 5] = inter, interval: [0, 5] = inter 都相同
   -> 更新: left = mid + 1 = 5 + 1 = 6
   
   -> left > right
   -> 终止
   
   最长公共前缀长度 = (left + right) / 2 = (6 + 5) / 2 = 5
   最终公共前缀 = inter
   ```
   
4. 二分优化 LCP
   - 优点
     - 利用了 `长度越长越难匹配` 的单调性
     - 降低了大量重复字符比较的开销
     - 在字符串较长但 LCP 较短时效果显著
   - 适用场景
     - 大量长字符串取公共前缀
     - 实际系统中(如搜索提示词前缀匹配、词典前缀优化)
   - 流程
     - 找最短字符串长度作为右边界
     - 二分枚举前缀长度
     - 判断所有字符串是否都包含该长度前缀
     - 收缩区间，直到得到最长公共前缀长度
