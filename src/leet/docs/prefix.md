# 前缀和(Prefix Sum)
  `预处理一次`，把累加结果储存下来，后续查询可以 `O(1)`完成

1. 概念
   `前缀和数组` 是对原始数组的一个预处理结果, 表示从 `起点`(通常是 `索引 0`) 到当前位置的累积和, 建议长度为 `n + 1`
   ```text
   A = [3, 1, 4, 2, 5]
   P = [3, 4, 8, 10, 15]
   即:
   P[0] = A[0] = 3
   P[1] = A[0] + A[1] = 4
   P[2] = A[0] + A[1] + A[2] = 8
   P[3] = A[0] + A[1] + A[2] + A[3] = 10
   P[4] = A[0] + A[1] + A[2] + A[3] + A[4] = 15
   
   这样可以快速求任意区间 `[i, j]` 的和:
   sum(i, j) = P[j] - P[i - 1] (i > 0)
   sum(0, j) = P[j]            (i = 0)
   ``` 

  - 公式
  ```text
  sum(i, j) = P[j] - P[i - 1] (i > 0)
  sum(0, j) = P[j]            (i = 0)
  ```
   
2. 时间复杂度
   - 构造前缀和: O(n)
   - 区间求和查询: O(1)

3. 空间复杂度
   额外 `O(n)` 空间存储前缀和数组

4. 使用场景
   - 多次计算不同区间和
     - 需要频繁查询数组上不同起止点的区间和(子数组的最大/最小/定值问题)
   - 子数组和为某值的统计
     - 如: 找出和为 K 的连续子数组个数
   - 固定边界的前缀或后缀和
     - 如从头累加、或者从某一点往后累加
   - 解决 `双指针+滑动窗口` 问题
     - 提前处理前缀和，再用差值快速求得某段的和，避免重复遍历
   - 某些 `DP` 优化
     - 如累加转移状态时频繁做区间求和
   - 应用于 `2D` 算法
     - 扩展到二维前缀和，可 O(1) 查询任意子矩阵之和
     - 处理矩阵区域和的问题，比如地图、图像像素、热力图统计等
   - 差分数组(前缀和的逆操作)
     - 当我们需要在某段区间加一个值时，差分数组结合前缀和可以快速实现区间修改
   
5. 举例(连续查询某区间的总和)
   ```text
   假设有一个网站日志数据，记录了每天的访问量:
   访问量 = [10, 20, 30, 25, 15, 35, 40]
   
   现在想查询:
   1. 第 2 天到第 4 天的访问总量是多少？
   2. 第 0 天到第 6 天的访问总量是多少？
   
   前缀和 = [10, 30, 60, 85, 100, 135, 175]
   第 2~4 天访问量 = 前缀和[4] - 前缀和[1] = 100 - 30 = 70
   第 0~6 天访问量 = 前缀和[6] = 175
   ```
   
6. 二维矩阵的前缀和(Prefix Sum in 2D)
   在一个二维矩阵里, 通过预处理得到一个辅助矩阵 `prefixSum`, 使能在 `O(1)` 时间内 `求出任意一个子矩形内的所有元素和`
   - 大小 `(m + 1) × (n + 1)`
     - `第 0 行` 和 `第 0 列` 全是 0, 避免边界判断
     - `prefixSum[i][j]` 表示：原矩阵中，从 `(0, 0)` 到 `(i-1, j-1)` 所围成的矩形区域内的 `所有元素之和`
       - `prefixSum[1][1]` 是原矩阵的 `matrix[0][0]`
       - `prefixSum[2][3]` 是原矩阵中, 从 `(0, 0)` 到 `(1, 2)` 这个矩形的和
     ```text
       P = | 0 0 0 0 |
           | 0 ? ? ? |
           | 0 ? ? ? |
           | 0 ? ? ? |
     ```
   - 公式
     口诀: `左边 + 上边 - 左上角重叠区域 = P[i - 1][j](只在 i > 0 且 j > 0 时存在)`
     ```text
     prefixSum[i][j] = matrix[i - 1][j -1]
                     + prefixSum[i - 1][j]
                     + prefixSum[i][j - 1]
                     - prefixSum[i - 1][j - 1]
     
     口诀:
     prefixSum[i][j] = 当前值 + 左边 + 上边 - 左上角重叠区域
     左边 + 上边 - 左上角重叠区域 = P[i - 1][j](只在 i > 0 且 j > 0 时存在)
     
     左上角重复区域(矩形区域): `上区域` 和 `左区域` 的交集(`P[i−1][j−1]`(只在 i > 0 且 j > 0 时存在))
     A = | 1 2 3 |
         | 4 5 6 |
         | 7 8 9 |
     
     计算P[1][1](从 (0, 0) 到 (1, 1)) 的值
     - 上边(P[0][1]): 从(0, 0) 到 (0, 1) 的值
        | 1 2 |
        P[0][1] = 1 + 2 = 3
     
     - 左边(P[1][0]): 从(0, 0) 到(1, 0) 的值
       | 1 |
       | 4 |
       P[1][0] = 1 + 4 = 5
     
     - 左上重叠区域(P[0][0]): (只有 (0, 0))
       P[0][0] = 1
     
     - 当前值: A[1][1] = 5
     
     计算 P[2][2](从 A (0, 0) 到 (2, 2)) 的值
     - 上边(P[1][2]): 从 (0, 0) 到 (1, 2) 的矩形:
         | 1 2 3 |
         | 4 5 6 | 
         P[1][2] = 1 + 2 + 3 + 4 + 5 + 6 = 21
     
     - 左边(P[2][1]): 从 (0, 0) 到 (2, 1) 的矩形:
         | 1 2 |
         | 4 5 |
         | 7 8 |
         P[2][1] = 1 + 2 + 4 + 5 + 7 + 8 = 27
     
     - 左上重叠区域(P[0][1]): 从 (0, 0) 到 (1, 1) 的矩形:
         | 1 2 |
         | 4 5 |
         P[0][1] = 1 + 2 + 4 + 5 = 12
     
     - 当前值: A[2][2] = 9

     A = | 1  2  3  4 |
         | 5  6  7  8 |
         | 9 10 11 12 |
     
     计算 P[1][2](从 (0, 0) 到(1, 2)) 的值
     - 上边(P[0][2]): 从 (0, 0) 到 (0, 2) 的矩形:
       | 1 2 3 |
       P[0][2] = 1 + 2 + 3 = 6
     
     - 左边(P[1][1]): 从 (0, 0) 到 (1, 1) 的矩形:
       | 1 2 |
       | 5 6 |
       P[1][1] = 1 + 2 + 5 + 6 = 14
     
     - 左上重叠区域(P[0][1]): 从 (0, 0) 到 (0, 1) 的矩形:
       | 1 2 |
       P[0][1] = 1 + 2 = 3  
     
     - 当前值: A[1][2] = 7 
     ```
     ```text 
     公式推导:
     A = | 1 2 3 |
         | 4 5 6 |
         | 7 8 9 |
     
     P = | ? ? ? |
         | ? ? ? |
         | ? ? ? |
     
     第一行计算:
     P[0][0] = A[0][0] = 1
     P[0][1] = A[0][0] + A[0][1] = 1 + 2 = 3
     P[0][2] = A[0][0] + A[0][1] + A[0][2] = 1 + 2 + 3 = 6
     
     P = | 1 2 6 |
         | ? ? ? |
         | ? ? ? |
     
     第二行计算:
     P[1][0] 表示从 A 的左上角 (0, 0) 到 (1, 0) 的所有数的和:
     坐标点:
         | 1 |
         | 4 |
      -> A[0][0] = 1
      -> A[1][0] = 4
      -> P[1][0] = A[0][0] + A[1][0] = 5
      -> P[1][0] = 1 + 4 = 5
     
     P[1][1] 表示从 A 的左上角 (0, 0) 到 (1, 1) 的所有数的和
     坐标点:
         | 1 2 |
         | 4 5 |
      -> A[0][0] = 1
      -> A[0][1] = 2
      -> A[1][0] = 4
      -> A[1][1] = 5
      -> P[1][1] = 1 + 2 + 4 + 5 = 12
      -> P[1][1] = A[0][0] + A[0][1] + A[1][0] + A[1][1]
      -> P[1][1] = (A[0][0] + A[0][1]) + (A[0][0] + A[1][0]) - A[0][0] + A[1][1]
                 = P[0][1] + P[1][0] - A[0][0] + A[1][1]
                 = 3 + 5 - 1 + 5
                 = 12
     -> P[1][1] = 上(P[0][1]) + 左(P[1][0]) - 左上重复区域(P[0][0] = A[0][0]) + 当前值(A[1][1])
     
     P[1][2] 表示从 A 的左上角 (0, 0) 到 (1, 2) 的所有数的和
     坐标点:
         | 1 2 3 |
         | 4 5 6 |
      -> A[0][0] = 1    
      -> A[0][1] = 2    
      -> A[0][2] = 3    
      -> A[1][0] = 4   
      -> A[1][1] = 5   
      -> A[1][2] = 6   
      -> P[1][2] = 1 + 2 + 3 + 4 + 5 + 6 = 21
      -> P[1][2] = A[0][0] + A[0][1] + A[0][2] + A[1][0] + A[1][1] + A[1][2]
                 = (A[0][0] + A[0][1] + A[0][2]) + ((A[0][0] + A[0][1]) + (A[0][0] + A[1][0]) - A[0][0] + A[1][1]) - (A[0][0] + A[0][1]) + A[1][2]
                 = P[0][2] + P[1][1] - P[0][1] + A[1][2]
                 = 6 + 12 - 3 + 6
                 = 21
     -> P[1][2] = 上(P[0][2]) + 左(P[1][1]) - 左上重复区域(P[0][1]) + 当前值(A[1][2])
     
     P = | 1  2  6 |
         | 5 12 21 |
         | ?  ?  ? |
     
     总结: 
     第三行计算同理:
     
     P = |  1  2  6 |
         |  5 12 21 |
         | 12 27 45 |
     ```
   - 区域查询
     口诀: `整个区域 - 上方多余区域 - 左边多余区域 + 左上角重叠区域(被减了两次, 要加回来)`
     查询从 `(row1, col1)` 到 `(row2, col2)`
     ```text
     在 P 中查询 (row1 + 1, col1 + 1) 到 `(row2 + 1, col2 + 1) 的区域
     公式: 整个区域 - 上方多余区域 - 左边多余区域 + 左上角重叠区域(被减了两次, 要加回来)
        -> (row2 + 1, col2 + 1) - (row1, col2 + 1) - (row2 + 1, col1) + (row1, col1)  
     A = | 1 2 3 |
        | 4 5 6 |
        | 7 8 9 |

     P = | 0    0    0   0  |   
       | - - - - - - - -  |
       | 0 |  1    3   6  |
       | 0 |  5  [12  21] |
       | 0 | 12  [27  45] |

     现在要查询从 `(1, 1)` 到 `(2, 2)`, 即:
     | x  x x  |
     | x [5 6] |
     | x [8 9] |
     预计总和: 5 + 6 + 8 + 9 = 28
   
     - 整个区域(P[3][3]): 从 `(0, 0)` 到 `(2, 2)`
     - 上方多余区域(P[1][3]): 从 `(0, 0)` 到 `(0, 2)`
     - 左边多余区域: P[3][1]: 从 `(0, 0)` 到 `(2, 1)`
     - 左上角重叠区域: P[1][1]: 从 `(0, 0)` 到 `(0, 0)`
     ```