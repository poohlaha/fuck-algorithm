# 中位数(Median)
  将一组数据按从小到大排列后, 位于 `中间位置` 的数

1. 取中位数
   - 元素个数为奇数
     - 中位数是 `正蹭的那个数`
   ```text
   如: [1, 3, 5]
   中位数 = 3(下标 1)
   ```
   
   - 元素个数为偶数
     - 中位数是 `中间两个数的平均值`
   ```text
   例如: [1, 3, 5, 7]
   中位数: (3 + 5) / 2 = 4
   ```
   
2. 中位数 VS 平均数
   ```text
   对比               中位数(Median)               平均数(Mean)
   计算方式            排序后取中间值                所有数值求各再除以个数
   是否受极端值影响     不敏感, 更稳健                敏感, 极端值会拉动平均值
   使用场景            数据分布不均、抗异常时优先      正态分布、数据稳定性较高时常用
   ```
   
3. 为什么中位数重要
   - 在有极端值的数据中(如收入分布、房价), `平均数会失真`, 而中位数能更真实反映 `大多数人的真实水平`
   - 在算法中, 如:
     - 寻找两个有序数组的中位数
     - 滑动窗口中位数
     - 快速选择算法
     - 求数据分布的一半以上位置
   
4. 直观记忆口诀
   - 排序后，取中间的那个数(奇数)
   - 排序后，取中间两个数的平均(偶数)

5. 查找中位数的算法
   - 排序后取中间值
     - 思路
       - 先排序
       - 奇数: 取中间那个元素
       - 偶数: 取中间两个的平均
     - 时间复杂度
       O(n log n)     
     - 适用场景
       - 一次性求中位数
       - 数据量不大，或者不要求实时动态更新
   - 快速选择算法
     - 思路
       - 和快速排序类似，基于 `分治 + partition`
       - 每次随机选一个 pivot，把数组划分为小于 pivot 和大于 pivot 的两部分
       - 比较左边长度和 k
         - 如果正好等于 k，则 pivot 即为结果
         - 如果小于 k，则在右边继续找第 k - left.len() - 1 小
         - 如果大于 k，则在左边递归找第 k 小
     - 时间复杂度
       - 平均: O(n)
       - 最坏: O(n^2)
     - 场景
       - 只想找第 k 小(如找中位数是第 n/2 小)
       - 不关心完整排序，只要找到那个位置的数即可
   - 双堆法
     - 思路
       - 维护一个最大堆 maxHeap(左半部分，保存较小的一半)
       - 维护一个最小堆 minHeap(右半部分，保存较大的一半)
       - 保证:
         - 左边最大 <= 右边最小
         - 两堆大小差不超过 1
       - 中位数:
         - 如果两堆一样大: 取 `maxHeap.top()` 和 `minHeap.top()` 的 `平均`
         - 如果不一样大: 取多的那堆的堆顶
     - 时间复杂度
       - 插入: O(log n)
       - 取中位数: O(1)
     - 场景
       - 数据是不断流入的(如滑动窗口、流式统计)
       - 需要实时输出中位数
   - 二分法
     - 思路
       - 二分法
     - 时间复杂度
       - O(log(min(m, n)))
     - 应用场景
       - 对两个有序数组做二分，找出第 k 小元素（k = (m+n)/2）


6. 两个有序数组中找中位数
    - 利用两个数组本身有序, 利用二分 `切分` 两个数组, 构造使得左边刚好包含总长度一半, 右边包含另一半
   ```text
   给定两个有序数组 nums1(长度 m) 和 nums2(长度 n),
   要求:
   1. 合并后找 `中位数`
   2. 时间复杂度: O(log (m + n))
   
   暴力思路:
   合并后排序，再取中位数:
   - 时间复杂度: O(m + n)
   - 空间复杂度: O(m + n)
   不满足题目要求
   
   因此: 利用两个数组本身有序, 利用二分 `切分` 两个数组, 构造使得左边刚好包含总长度一半, 右边包含另一半

   思路: 
   设定:
   - 数组 A(长度 m)
   - 数组 B(长度 n)
   - 保证 m <= n(对短的数组做二分，避免越界)
   
   找到一个切分:
   A[0 .. i - 1] | A[i .. m - 1]
   B[0 .. j - 1] | B[j .. n - 1]
   使得:
   - 左半部分元素总数 == 右半部分元素总数 (或相差 1)
   - 左半部分最大值 <= 右半部分最小值
   - 奇数时：让左半部分多 1 个，以保证中位数在左半部分最大值中
   - 偶数时：恰好左右对半分
   
   数学公式: i + j = (m + n + 1) / 2(加 1 的目的：确保“左半部分包含的元素数量恰好等于总长度的一半（向上取整）”，无论奇偶都成立)
   确保:
   - 若总长度奇数，左半部分比右半部分多 1
   - 若总长度偶数，左右相等
   - A 的左半部分：i 个元素
   - B 的左半部分：j 个元素
   - 要让左半部分总数量等于一半（向上取整）
   - 计算:
     - i = (left + right) / 2(left = 0, right = 交换后的较短数组长度)
     - j = (m + n + 1) / 2 - i
     - i 向下取整
   
   交换, 避免二分越界:
   i + j = (m + n + 1) / 2
   -> j = (m + n + 1) / 2 - i
   数组 A 上进行二分, 确定数组 B 上的切分点
   如果不保证 m <= n:
   - 当 A 很大，B 很小，可能出现：
     - j = 负数
     - j > n
     - 导致越界访问 B[j] 或 B[j-1]
   保证 m <= n:
   - 避免在 B 上越界
   - 限制二分范围为: i: [0, m], j: [0, n]
   无论怎么移动二分指针都不会超出 B 的索引范围
   
   切分是否正确的判断条件:
   设:
   - L1 = A[i - 1]（A 切分左半最大）
   - L2 = B[j - 1]（B 切分左半最大）
   - R1 = A[i]（A 切分右半最小）
   - R2 = B[j]（B 切分右半最小）
   满足: L1 <= R2 && L2 <= R1
   - L1 <= R2: A 左边最大 <= B 右边最小
   - L2 <= R1: B 左边最大 <= A 右边最小
   - 这样左半部分最大值 max(L1, L2) 小于等于右半部分最小值 min(R1, R2)，保证合并后有序
   
   如何调整二分(二分都是在短数组上进行):
   若 L1 > R2，切分太右，要左移, right = i - 1
   若 L2 > R1，切分太左，要右移, left = i + 1
   
   如果 L1 > R2:
   - A[i - 1] > B[j]
   - A 左半部分最大值 > B 右半部分最小值
   - A 左半部分太大，要减小，让右半部分变大
   - 说明 A 切分太右，需要左移
   - 要左移切分点 i: right = i - 1
   
   如果 L2 > R1: 
   - B[j - 1] > A[i]
   - B 左半部分最大值 > A 右半部分最小值
   - B 的左半部分中有值太大，应该“移到右边去”
   - A 的右半部分太小，应该“再切更多 A 的元素放入左半部分”，让右半部分变大
   - 说明 A 切分太左，需要右移，
   - 要右移切分点 i: left = i + 1
   
   中位数如何计算: 
   若 (m + n) 为奇数: 中位数 = max(L1, L2)
   若 (m + n) 为偶数: 中位数 = (max(L1, L2) + min(R1, R2)) / 2
   
   例: 
   A = [1, 3, 8, 9, 15]
   B = [7, 11, 18, 19, 21, 25]
   
   m = 5
   n = 6
   total = 11
   
   计算切分点: i + j = (total + 1) 2 = 6
   
   1. 第一次二分:
   -> left = 0, right = 5
   -> i = (0 + 5) / 2 = 2
   -> j = 6 - 2 = 4
   -> L1 = A[i - 1] = A[1] = 3
   -> R1 = A[i] = A[2] = 8
   -> L2 = B[j - 1] = B[3] = 19
   -> R2 = N[j] = B[4] = 21
   -> 检查  L1 <= R2 && L2 <= R1
   -> L1 <= R2 (3 <= 21) ✅, L2 <= R1 (19 <= 8) ❌
   -> 错误在 L2 > R1，说明 A 切分太左，需要右移: left = i + 1 = 3
   
   2. 第二次二分:
   -> left = 3, right = 5
   -> i = (3 + 5) / 2 = 4
   -> j = 6 - 4 = 2
   -> L1 = A[i - 1] = A[3] = 9
   -> R1 = A[i] = A[4] = 15
   -> L2 = B[j - 1] = B[1] = 11
   -> R2 = N[j] = B[2] = 18
   -> 检查  L1 <= R2 && L2 <= R1
   -> L1 <= R2 (9 <= 18) ✅, L2 <= R1 (11 <= 15) ✅
   -> 满足中位数条件
   
   最终取中位数: 
   toal = 11(奇数)
   中位数 = max(L1, L2) = max(9, 11) = 11
   ```
