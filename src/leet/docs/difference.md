# 差分数组
  一种高效执行 `区间修改` 的数据结构, 相比前缀和(Prefix Sum)适合用于 `区间查询`, 差分数则非常适用于 `频繁修改数组某个区间的值`  的场景。

1. 特性
   将一个区间加法操作转化为两个位置的修改，从而实现 `O(1)` 修改, 建议长度也为 `n + 1`

   - 定义
   ```text
   对于一个原始数组 `A{1..n]`, 我们构造一个差分数组 `D[1..n]`:
   D[1] = A[1]
   D[i] = A[i] - A[i - 1] ( i > 1)
   
   那么，我们可以通过差分数组还原原始数组的方式就是前缀和:
   A[i] = D[1] + D[2] + ... + D[i]
   ```
   
   - 为什么可以做到区间修改?
   差分数组可以在 `O(1)` 时间内把原数组某个区间 `[l, r]` 的值统一加个某个值 `x`:
   ```text
   D[l] += x
   D[r + 1] -= x (r + 1 <= n)
   
   这样我们还原回原数组时, 相当于 `[l, r]` 区间内的值都被加上 `x`
   ```

2. 时间复杂度
   - 单次区间修改: O(1)
   - 全部恢复成原数组: O(n)

3. 空间复杂度
   - O(1)
   
4. 应用场景
   - `频繁区间加法操作`，但不频繁查询单个元素的值
   - 处理多个区间操作的批量计算题
   - 算法竞赛常见场景
     - 交通流量分析(某路段某时间段加人)
     - 区间染色、区间温度变化、加热器影响范围等模拟类题目

5. 推导过程
   ```text
   A = [2, 3, 5, 7, 11]
   索引: 1, 2, 3, 4, 5
   
   1. 计算差分数组 D
   D[1] = A[1]        = 2
   D[2] = A[2] - A[1] = 3 - 2 = 1
   D[3] = A[3] - A[2] = 5 - 3 = 2
   D[4] = A[4] - A[3] = 7 - 5 = 2
   D[5] = A[5] - A[3] = 11 - 7 = 4
   
   所以: D = [2, 1, 2, 2, 4]
   
   2. 对区间 `[2, 4]` 的元素都加上 3
   A[2] = 3 + 3 = 6
   A[3] = 5 + 3 = 8
   A[4] = 7 + 3 = 10
   即新数组: 
   A' = [2, 6, 8, 10, 11]

   3. 重新计算差分数组 D
   D[1] = A[1]        = 2
   D[2] = A[2] - A[1] = 6 - 2 = 4
   D[3] = A[3] - A[2] = 8 - 6 = 2
   D[4] = A[4] - A[3] = 10 - 8 = 2
   D[5] = A[5] - A[3] = 11 - 10 = 1
   
   D = [2, 4, 2, 2, 1]
   
   4. 比较原来的 D  和现在的 D
   发现 D[2] 和 D [5] 发生变化
   D[2] = 4 - 1 = 3
   D[5] = 1 - 4 = -3
   
   5. 推导
   发现:
   D[2] += 3   ← 区间起点
   D[5] -= 3   ← 区间终点的后一位

   -> D[l] += 3
      D[r + 1] -= 3
   ```

6. 举例
   ```text
   A = [0, 0, 0, 0, 0]
   1. 将区间 `[1, 3]` 所有元素加上 `5`
   2. 将区间 `[2, 4]` 所有元素加上 `2`
   求最终数组的结果
   
   步骤:
   1. 初始化差分数组 `D`
   D = [0, 0, 0, 0, 0, 0] (长度为 n + 1)
   
   2. 区间 [1, 3] 加 5
      即: 下标 [0, 2] -> A[1], A[2], A[3]
   D[1] += 5 => D = [0, 5, 0, 0, 0, 0]
   D[4] -= 5 => D = [0, 5, 0, 0, -5, 0]
   
   注意 r + 1 = 3 + 1 = 4
   D = [0, 5, 0, 0, -5, 0]
   
   3. 区间 [2, 4] 加 2
      即: 下标 [1, 3] -> A[2], A[3], A[4]
   D[2] += 2 => D = [0, 5, 2, 0, -5, 0]
   D[5] -= 2 => D = [0, 5, 2, 0, -5, -2]
   
   D = [0, 5, 2, 0, -5, -2]
   
   4. 求前缀和还原数组 A
   A[0] = D[0]        = 0
   A[1] = D[1]        = 5
   A[2] = A[1] + D[2] = 5 + 2 = 7
   A[3] = A[2] + D[3] = 7 + 0 = 7
   A[4] = A[3] + D[4] = 7 + (-5) = 2
   
   最终:
   A = [0, 5, 7, 7, 2](下标从 0 开始)
   ```
   
# 二维差分数组
  `对一个矩形子区域的批量加法操作`, 差且多个操作后, 一次性还原原始矩阵
  - 每次操作只需要改动 `4` 个位置, 然后再还原矩阵
  - 矩阵大小 `(m + 2) * (n + 2)` (需要操作 4 个位置, 防止越界, 当然也可以用 `(n + 1) * (n + 1)`, 但需要判断是否越界)

1. 公式
  ```text
   差分矩阵 D:
   D[i][j]: 原始矩阵 A[i][j] 的增量来源
   
   在 [x1, x2] 到 [y1, y2] 上加上 `c`, 更新差分矩阵 D:
   D[x1][y1]         += c  // 左上(启发传播)
   D[x1][y2 + 1]     -= c  // 右上(右边一列清除)
   D[x2 + 1][y1]     -= c  // 左下(下边一行清除)
   D[x2 + 1][y2 + 1] += c  // 右下(右下角修正补回来)
   
   D = [
       [0, | 0,  0, 0,  0,  0], 
       [- - - - - - - - - - - ],
       [0, | 0,  0, 0,  0,   0],
       [0, | 0, [D1, 0, 0], D2],
       [0, | 0, [0, 0,  0],  0],
       [0, | 0, [0, 0,  0],  0],
       [0, | 0,  D3, 0, 0,  D4],
   ]
   
   D1: 左上(矩形顶点)
   D2: 右上(在矩形右边之外一列)
   D3: 左下(在矩形下边之外一行)
   D4: 右下(在矩形右下之外一行一列)
   
   口诀:
       主对角线相加,
       负对角线相减,
       右下点在外边,
       负对角线全在外
   
   还原矩阵(前缀和公式):
   A[i][j] = D[i][j]
           + A[i - 1][j](i > 0) // 左边
           + A[i][j - 1](j > 0) // 上边
           - A[i - 1][j -1](i > 0 && j > 0) // 左上角重叠区域(`上区域` 和 `左区域` 的交集(`A[i−1][j−1]`)
  
  口诀(前缀和口诀):
      左边 + 上边 - 左上角重叠区域 + D中当前值
  ```

  ```text
  推导过程:
    A = [
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
   ]
   
    将矩形区域(1, 1) 到 (3, 3) 中所有元素加上 `5`
    
   1. 构造差分矩阵 D:
   D = [
       [0, | 0,  0, 0, 0,  0], 
       [- - - - - - - - - - ],
       [0, | [0, 0, 0], 0, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, |  0, 0, 0, 0,  0],
       [0, |  0, 0, 0, 0,  0],
   ]

   2. 将矩形区域(1, 1) 到 (3, 3) 
   A = [
       [5, 5, 5, 0, 0],
       [5, 5, 5, 0, 0],
       [5, 5, 5, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
   ]
   
   公式: A[i][j] - 上 - 左 + 左上(`上区域` 和 `左区域` 的交集(`A[i−1][j−1]`, i> 0 && j > 0)
   
    D = [
       [0, | 0, 0, 0, 0, 0], 
       [- - - - - - - - - ],
       [0, | 5, 0, 0, 0, 0],
       [0, | 0, 0, 0, 0, 0],
       [0, | 0, 0, 0, 0, 0],
       [0, | 0, 0, 0, 0, 0],
       [0, | 0, 0, 0, 0, 0],
   ]
   
   第一行:
   D[1][0] = A[0][0] = 5
   D[1][1] = A[0][1] - A[0][0] = 5 - 5 = 0
   D[1][2] = A[0][2] - A[0][1] = 5 - 5 = 0
   D[1][3] = A[0][3] - A[0][2] = 0 - 5 = -5
   D[1][4] = A[0][4] - A[0][3] = 0 - 0 = 0
   
   第二行:
   D[2][0] = A[1][0] - A[0][0] = 5 - 5 = 0
   D[2][1] = A[1][1] - A[1][0] + A[0][0] = 5 - 5 - 5 + 5 = 0
   D[2][2] = A[1][2] - A[1][1] + A[0][1] = 5 - 5 - 5 + 5 = 0
   D[2][3] = A[1][3] - A[1][2] + A[0][2] = 0 - 0 - 5 + 5 = 0
   D[2][4] = A[1][4] - A[1][3] + A[0][3] = 0 - 0 - 0 + 0 = 0
  
   ...
   
   最终:
   D = [
       [0, |  0, 0, 0,  0, 0], 
       [- - - - - - - - - - ],
       [0, |  5, 0, 0, -5, 0],
       [0, |  0, 0, 0,  0, 0],
       [0, |  0, 0, 0,  0, 0],
       [0, | -5, 0, 0,  5, 0],
       [0, |  0, 0, 0,  0, 0],
   ]
  ```

2. 时间复杂度
   - 单次操作(区间加)：`O(1)`
   - 最终还原原数组：`O(n * m)` 前缀和一次过

3. 空间复杂度
   - O(n * m), 因为要维护 `原矩阵` + `差分矩阵`

4. 举例
   ```text
   A = [
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
   ]
   
   将矩形区域(1, 1) 到 (3, 3) 中所有元素加上 `2`
   1. 构造差分矩阵 D:
   D = [
       [0, | 0,  0, 0, 0,  0], 
       [- - - - - - - - - - ],
       [0, | [0, 0, 0], 0, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, |  0, 0, 0, 0,  0],
       [0, |  0, 0, 0, 0,  0],
   ]

   x1 = 1, y1 = 1, x2 = 3, y2 = 3
   D[1][1] += 2 // 左上: [x1, y1]
   D[1][4] -= 2 // 右上: [x1, y2 + 1]
   D[4][1] -= 2 // 左下: [x2 + 1, y2]
   D[4][4] += 2 // 右下: [x2 + 1, y2 + 1]
   
   D = [
       [0, | 0,  0, 0, 0,  0], 
       [- - - - - - - - - - ],
       [0, | [2, 0, 0], -2, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, | [0, 0, 0], 0, 0],
       [0, |  -2, 0, 0, 2,  0],
       [0, |  0, 0, 0, 0,  0],
   ]

   还原矩阵:
   A[i][j] = D[i][j]
           + A[i - 1][j](i > 0)
           + A[i][j - 1](j > 0)
           - A[i - 1][j -1](i > 0 && j > 0)
   
   A = [
       [ 0,  0,  0,  0,  0],
       [ 0,  2,  2,  2,  0],
       [ 0,  2,  2,  2,  0],
       [ 0,  2,  2,  2,  0],
       [ 0,  0,  0,  0,  0],
   ]
   ```