# 子序列(Subsequence)

1. 子序列
   ```text
   给定字符串: abcde
   如果从中删除 `任意数量(可以是 0)` 的字符串(但保持相对顺序不变), 得到的字符串即为其 `子序列`
   
   举例:
   - ace 是 abcde 的子序列(去掉 b, d)
   - bd 是 abcde 的子序列(去掉 a, c, e)
   - abcde 本身也是它的子序列
   - 空集也是 abcde 的子序列(任意数量(可以是 0))
   ```
   
2. 公共子序列
   ```text
   给定两个字符串: text1, text2
   如果存在一个字符串: 同时是 text1 的子序列, 同时是 text2 的子序列, 则称它为 text1 和 text2 的公共子序列
   
   举例:
   给定:
   text1: abcde
   text2: ace
   则: 
   - ace 是两者的公共子序列
   - ae 也是公共子序列
   - a 也是公共子序列
   ```
   
3. 最长公共子序列
   - 在所有公共子序列中
   - `长度最长` 的那个
   - 称为 Longest Common Subsequence(LCS)
   ```text
   text1: abcde
   text2: ace
   - 公共子序列: a, c, e, ac, ae, ce, ace
   - 长度最长: ace
   - 长度: 3
   - LCS("abcde", "ace") = "ace"
   ```
   - 应用场景
     - 比较两个文件相似度(Git diff)
     - 比较 DNA 序列相似性
     - 数据比较和容错(Diff 工具)
     - 经典 DP 刷题高频考点(如 LeetCode 1143)
   
4. 总结
   - 子序列: 在原字符串中按顺序挑选部分字符形成的字符串
   - 公共子序列: 在两个字符串中都存在且保持顺序的子序列
   - 最长公共子序列(LCS): 在所有公共子序列中长度最长的那个
   ```text
   概念                     含义                              如何求
   子序列                   从一个串中去掉若干字符且保持顺序       枚举每个字符选/不选 (2^n)
   公共子序列                在两个串中都出现的子序列             枚举子序列后验证 (2^n)
   最长公共子序列             两串公共子序列中长度最长的           动态规划 O(mn)
   ```

5. 求子序列
   - 子序列 = 对每个字符选择 `要` 或 `不要`，保持相对顺序不变
     - 方法:
       - 递归回溯或位运算枚举
       - 共 `2^n` 种可能(n = s.len())
     ```text
     示例:
     对于 abc: 
     - 选: 空集(子序列是从原字符串中 `删除任意个(可为 0)字符` 后，保持原有顺序得到的字符串)
     - 选: a, b, c
     - 选: ab, ac, bc
     - 选: abc
     共 2^3 = 8 种: 
     "", "a", "b", "c", "ab", "ac", "bc", "abc"
     
     用位运算符
     长度: 3,
     mask: 0 ... 7(二进制: 000 ... 111)(最高位是左侧，最低位是右侧，仍从下标 i = 0 开始对应字符)
         a b c
     位: 2 1 0
     值: 1 0 0

     当 mask = 0b000 = 0:
     -> 不选任何字符
     -> 子序列为 ""
     
     当 mask = 0b001 = 1:
     -> 只选 s[2] = 'c'
     -> 子序列为 'c'  
     
     当 mask = 0b010 = 2:
     -> 只选 s[1] = 'b'
     -> 子序列为 'b'  
     
     当 mask = 0b011 = 3:
     -> 选 s[1] = 'b', s[2] = 'c'
     -> 子序列为 'bc'
     
     当 mask = 0b100 = 4
     -> 只选 s[0] = 'a'
     -> 子序列为 'a'
     
     当 mask = 0b101 = 5
     -> 选 s[0] = 'a', s[2] = 'c'
     -> 子序列为 'ac'
     
     当 mask = 0b110 = 6:
     -> 选 s[0] = 'a', s[1] = 'b'
     -> 子序列为 'ab'
     
     当 mask = 0b111 = 7:
     -> 选 s[0] = 'a', s[1] = 'b', s[2] = 'c'
     -> 子序列为 'abc'
     ```
   - 公共子序列   
   ```text
   给定:
   s1 = abcde
   s2 = ace
   找出 `同时在 s1 和 s2 中出现且顺序不变的子序列`
   
   方法:
   - 穷举 s1 的所有子序列(2^n)，检查是否是 s2 的子序列(双指针判定)
   - 或反过来遍历 s2 的所有子序列判断
   - 这种方法 `时间复杂度非常高(指数级)`，一般仅用于面试小规模验证
   ```
   - 最长公共子序列(LCS)
   ```text
   给定:
   s1 = abcde
   s2 = ace
   求: ace, 长度: 3
   
   方法: 动态规划(DP)
   状态定义: dp[i][j] = s1[0..i) 与 s2[0..j) 的最长公共子序列长度
   状态转移:
   如果: s1[i - 1] = s2[j - 1], dp[i][j] = dp[i - 1][j - 1] + 1
   否则: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
   
   初始化: 
   - dp[0][*] = 0
   - dp[*][0] = 0
   最终: dp[s1.len()][s2.len()]
   ```
