# 子序列(Subsequence)

1. 子序列
   ```text
   给定字符串: abcde
   如果从中删除 `任意数量(可以是 0)` 的字符串(但保持相对顺序不变), 得到的字符串即为其 `子序列`
   
   举例:
   - ace 是 abcde 的子序列(去掉 b, d)
   - bd 是 abcde 的子序列(去掉 a, c, e)
   - abcde 本身也是它的子序列
   - 空集也是 abcde 的子序列(任意数量(可以是 0))
   ```
   
2. 公共子序列
   ```text
   给定两个字符串: text1, text2
   如果存在一个字符串: 同时是 text1 的子序列, 同时是 text2 的子序列, 则称它为 text1 和 text2 的公共子序列
   
   举例:
   给定:
   text1: abcde
   text2: ace
   则: 
   - ace 是两者的公共子序列
   - ae 也是公共子序列
   - a 也是公共子序列
   ```
   
3. 递增子序列
   ```text
   如果子序列满足:
   a1 < a2 < a3 < ... < ak
   即 `严格递增`，那么它是一个 `递增子序列`, 递增子序列 `不要求连续`
   
   举例:
   给定数组: [3, 1, 4, 2, 5]
   则:
   - [3, 4, 5] 是递增子序列
   - [1, 2, 5] 是递增子序列
   - [1, 4, 5] 是递增子序列
   - [3, 2] 不是递增子序列（因为 2 < 3）
   
   ```
   
4. 最长公共子序列
   - 在所有公共子序列中
   - `长度最长` 的那个
   - 称为 Longest Common Subsequence(LCS)
   ```text
   text1: abcde
   text2: ace
   - 公共子序列: a, c, e, ac, ae, ce, ace
   - 长度最长: ace
   - 长度: 3
   - LCS("abcde", "ace") = "ace"
   ```
   - 应用场景
     - 比较两个文件相似度(Git diff)
     - 比较 DNA 序列相似性
     - 数据比较和容错(Diff 工具)
     - 经典 DP 刷题高频考点(如 LeetCode 1143)
     
5. 最长递增子序列
   - 在所有递增子序列中 
   - `长度最长` 的那个
   - 称为 Longest Increasing Subsequence(LIS)
   - 使用 `DP(O(n^2))` 或 `贪心 + 二分(O(n log n))`
   ```text
   数组: 10,9,2,5,3,7,101,18
   - 递增子序列
     - 10, 101
     - 9, 101
     - 2, 5, 7, 101
     - 5, 7, 101
     - 3, 7, 101
     - 7, 101
   - 长度最长: 2, 5, 7, 101
   - 长度: 4
   ```
   
4. 总结
   - 子序列: 在原字符串中按顺序挑选部分字符形成的字符串
   - 公共子序列: 在两个字符串中都存在且保持顺序的子序列
   - 最长公共子序列(LCS): 在所有公共子序列中长度最长的那个
   ```text
   概念                     含义                              如何求
   子序列                   从一个串中去掉若干字符且保持顺序       枚举每个字符选/不选 (2^n)
   公共子序列                在两个串中都出现的子序列             枚举子序列后验证 (2^n)
   最长公共子序列             两串公共子序列中长度最长的           动态规划 O(mn)
   ```

5. 求子序列
   - 子序列 = 对每个字符选择 `要` 或 `不要`，保持相对顺序不变
     - 方法:
       - 递归回溯或位运算枚举
       - 共 `2^n` 种可能(n = s.len())
     ```text
     示例:
     对于 abc: 
     - 选: 空集(子序列是从原字符串中 `删除任意个(可为 0)字符` 后，保持原有顺序得到的字符串)
     - 选: a, b, c
     - 选: ab, ac, bc
     - 选: abc
     共 2^3 = 8 种: 
     "", "a", "b", "c", "ab", "ac", "bc", "abc"
     
     用位运算符
     长度: 3,
     mask: 0 ... 7(二进制: 000 ... 111)(最高位是左侧，最低位是右侧，仍从下标 i = 0 开始对应字符)
         a b c
     位: 2 1 0
     值: 1 0 0

     当 mask = 0b000 = 0:
     -> 不选任何字符
     -> 子序列为 ""
     
     当 mask = 0b001 = 1:
     -> 只选 s[2] = 'c'
     -> 子序列为 'c'  
     
     当 mask = 0b010 = 2:
     -> 只选 s[1] = 'b'
     -> 子序列为 'b'  
     
     当 mask = 0b011 = 3:
     -> 选 s[1] = 'b', s[2] = 'c'
     -> 子序列为 'bc'
     
     当 mask = 0b100 = 4
     -> 只选 s[0] = 'a'
     -> 子序列为 'a'
     
     当 mask = 0b101 = 5
     -> 选 s[0] = 'a', s[2] = 'c'
     -> 子序列为 'ac'
     
     当 mask = 0b110 = 6:
     -> 选 s[0] = 'a', s[1] = 'b'
     -> 子序列为 'ab'
     
     当 mask = 0b111 = 7:
     -> 选 s[0] = 'a', s[1] = 'b', s[2] = 'c'
     -> 子序列为 'abc'
     ```
   - 公共子序列   
   ```text
   给定:
   s1 = abcde
   s2 = ace
   找出 `同时在 s1 和 s2 中出现且顺序不变的子序列`
   
   方法:
   - 穷举 s1 的所有子序列(2^n)，检查是否是 s2 的子序列(双指针判定)
   - 或反过来遍历 s2 的所有子序列判断
   - 这种方法 `时间复杂度非常高(指数级)`，一般仅用于面试小规模验证
   ```
   - 最长公共子序列(LCS)
   ```text
   给定:
   s1 = abcde
   s2 = ace
   求: ace, 长度: 3
   
   方法: 动态规划(DP)
   状态定义: dp[i][j] = s1[0..i) 与 s2[0..j) 的最长公共子序列长度
   状态转移:
   如果: s1[i - 1] = s2[j - 1], dp[i][j] = dp[i - 1][j - 1] + 1
   否则: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
   
   初始化: 
   - dp[0][*] = 0
   - dp[*][0] = 0
   最终: dp[s1.len()][s2.len()]
   ```

6. LIS 在树中的使用(Diff)
   ```text
   父节点下的子节点:
   旧顺序: ['a', 'b', 'c', 'd', 'e']
   新顺序: ['b', 'd', 'a', 'e', 'c']
   
   1. 建立旧 key -> 索引映射
   old_index_map = {
      'a': 0,
      'b': 1,
      'c': 2,
      'd': 3,
      'e': 4
   }
   
   2. 将 new 映射为 old 中的索引序列
   遍历 new:
   - b -> 1
   - d -> 3
   - a -> 0
   - e -> 4
   - c -> 2
   得到索引序列: [1, 3, 0, 4, 2]
   
   3. 在索引序列上求 LIS
   得到 LIS = [1, 3, 4], 在 new 中对应的索引:
   - 0: b
   - 1: d
   - 3: e
   
   4. 无需移动节点(LIS)
    - b: 0
    - d: 1
    - e: 3
    这些元素只需要在移动时保持顺序即可，无需动
   
   5. 需要移动的节点(非LIS)
   遍历 new:
   index          val            mapped         是否在LIS
   0              b              1              ✅
   1              d              3              ✅
   2              a              0              ❌
   3              e              4              ✅
   4              c              2              ❌
   
   需要移动:
   - 2: a
   - 4: c
   
   6. 移动
      移动顺序原则
      - 从后往前移动可避免位置错乱
      - 或先移动需插入较前的元素，后移动靠后的元素
   
   6.1 移动 a 到 index 2(new)
       当前位置: a 在 old index 为 0
       目标: 放到 new index 为 2 的位置(在 d 后, e 前)
       
       在当前排列中可这样操作:
       - 将 a 从 index 0 移动到 'd' 后(index = 3)
       - 完成排列后: ['b', 'c', 'd', 'a', 'e']
   
   6.2 移动 c 到 index 4(new)
       当前位置: c 在 old index 为 1(因为之前 a 移动, c 已向前)
       目标: 放到 new index 为 4 的位置(在 e 后)
       
       在当前排列中可这样操作:
       - 将 c 从 index 1 移动到 'e' 后(末尾)
       - 完成排列后: ['b', 'd', 'a', 'e', 'c'] 
   ```