/**
   1751. 最多可以参加的会议数目 II
   力扣: https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/description/
   题目: 给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，
        如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。
        你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。
        会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。
        请你返回能得到的会议价值 最大和 。

   示例:
       1. 输入: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
          输出: 7
          解释：选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7

       2. 输入: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
          输出: 10
          解释: 参加会议 2 ，得到价值和为 10
          你没法再参加别的会议了，因为跟会议 2 有重叠。你 不 需要参加满 k 个会议

       3. 输入: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
          输出: 9
          解释: 尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。

    解:  使用 DP + 二分查找

    1. 是否可用 DP
    1.1 最优子结构
        在最多参加 k 个会议、会议之间不能重叠的条件下，求最大价值和
        若按结束时间对会议排序, 考虑第 i 个会议:
        如果选择第 i 个会议 , 则问题转化为: 在所有 `与第 i 个会议不重叠的前序会议` 中，求解“选择 j − 1 个会议的最优解”，再加上第 i 个会议的价值
        因此: 会议价值最大和的最优解可以由子问题(选择 j − 1 个互不重叠会议的最优价值) + 第 i 个会议的价值构成
    1.2 重叠子问题
        在递归或枚举不同选择组合的过程中，会多次遇到相同的子问题（例如“只考虑前 i 个会议、选择 j 个会议”的状态会被重复访问）
    1.3 无后效性
        在最多参加 k 个会议、会议之间不能重叠的条件下，求最大价值和的最优解只取决于当前所处的子问题状态（例如前 i 个会议、可再选择 j 个会议），与之前是通过什么顺序或方式到达该状态无关

    2. 定义状态(State)
       什么是状态?
       - 状态是子问题的标识，用来唯一描述子问题，让我们知道当前计算的“场景”是什么。

       获取状态:
       第 i 个会议的价值, 如果选择当前会议, 则最大会议价值由 `选择 j − 1 个、且与第 i 个会议不重叠的会议的最优价值 + 第 i 个会议的价值构成`
       因此: dp[i][j] 为在只考虑前 i 个会议的情况下, 最多选择 j 个会议所能获得的最大价值和

    3. 列出选择(Choice)
       为了前 i 个会议、最多选择 j 个会议的最大价值和, 有两种选择:
       - 不选择第 i 个会议, 此时 dp[i][j] 保持不变（继续保持前 i−1 个会议的最优值）
       - 选择第 i 个会议, 可以从子问题 dp[p(i)][j - 1](其中 p(i) 表示所有与第 i 个会议不重叠的会议中，结束时间最晚的下标) 转移过来, 表示 `选择 j − 1 个、且与第 i 个会议不重叠的会议的最优价值` 再加上 `第 i 个会议的价值构成`

    4. 写出转移方程(递推公式)
       - 不选第 i 个会议: dp[i-1][j]
       - 选第 i 个会议: dp[p(i)][j-1] + value_i
       将“选择”转化为最优性方程: dp[i][j] = max(dp[i - 1][j], dp[p(i)][j - 1] + value_i), i >=1 且 j >= 1
       - dp[i][j]: 前 i 个会议、最多选择 j 个会议时的最大价值和
       - dp[i-1][j]：不选择第 i 个会议
       - dp[p(i)][j - 1]: 选择 j − 1 个、且与第 i 个会议不重叠的前序会议的最优价值
       - + value_i: 加上当前第 i 个会议的价值

    5. 边界条件(初始化)
       dp[0][j] = 0 - 当没有会议可选时(i = 0)，无论最多可选 j 个会议，最大价值和为 0
       dp[i][0] = 0 - 当最多可选会议数为 0 时(j = 0)，无论考虑多少个会议，最大价值和为 0

    6. 计算顺序
       因为 dp[i][j] = max(dp[i - 1][j], dp[p(i)][j - 1] + value_i), i >=1 且 j >= 1, 因此:
       - 必须从小到大计算 i 和 j，保证 dp[i - 1][j] 和 dp[p(i)][j - 1] 在计算 dp[i][j] 前已被计算
       - 外层循环: 遍历 i = 1 .. n(从 1 到 n 个会议)
       - 内层循环: 遍历 j = 1 .. k(从 1 到 最多k 个可选会议)

     7. 返回结果
        最终要求 `在最多参加 k 个会议、会议之间不能重叠的条件下，求最大价值和`，因此直接返回:
        dp[n][k], 表示考虑前 n 个会议、最多选择 k 个会议时能获得的最大价值和

               j=0  j=1       j=2       j=3       ...       j=k
        i=0     0    0          0        0        ...       0    <- 没有会议
        i=1     0   dp[1][1]  dp[1][2]  dp[1][3]  ...
        i=2     0   dp[2][1]  dp[2][2]  dp[2][3]  ...
        i=3     0   dp[3][1]  dp[3][2]  dp[3][3]  ...
        ...
        i=n     0   dp[n][1]  dp[n][2]  dp[n][3]  ...

        dp[0][*] 表示没有会议的情况, dp[*][0] 表示最多选 0 个会议


    计算 p(i)
        编号 i            start              end              value
        1                2                  3                 5
        2                2                  5                 6
        3                4                  6                 4
        4                6                  7                 10
        5                7                  9                 3

       1. 求 p(1)
          会议1: 时间 1 ~ 3
          前面没有会议
          p(1) = -1

       2. 求 p(2)
          会议2: 时间 2 ~ 5
          之前会议:
             * 会议 1 ~ 3
               - 会议 1 的结束时间 3 >= 会议 2 的开始时间 2 → 冲突
          没有会议能接在会议 2 前面
          p(2) = -1

       3. 求 p(3)
          会议3: 时间 4 ~ 6
          之前会议:
             * 会议 1 ~ 3
               - 会议 1 的结束时间 3 < 会议 3 的开始时间 4 → 不冲突
             * 会议 2 ~ 5
               - 会议 2 的结束时间 5 >= 会议 3 的开始时间 4 → 冲突
          能接在 `会议 3` 前面的会议只有 `会议 1`
          p(3) = 1

       4. 求 p(4)
          会议 4: 时间 6 ~ 7
          之前会议:
            * 会议 1 ~ 3
              - 会议 1 的结束时间 3 < 会议 4 的开始时间 6 → 不冲突
            * 会议 2 ~ 5
              - 会议 2 的结束时间 5 < 会议 4 的开始时间 6 → 不冲突
            * 会议 4 ~ 6
              - 会议 3 的结束时间 6 >= 会议 4 的开始时间 6 → 冲突(结束时间等于开始也算冲突)
          能接在 `会议 4` 前面的会议只有 `会议 1` 和 `会议 2`
          p(4) = 2

       5. 求 p(5)
          会议 5: 时间 7 ~ 9
          之前的会议:
            * 会议 1 ~ 3
              - 会议 1 的结束时间 3 < 会议 5 的开始时间 7 → 不冲突
            * 会议 2 ~ 5
              - 会议 2 的结束时间 5 < 会议 5 的开始时间 7 → 不冲突
            * 会议 4 ~ 6
              - 会议 3 的结束时间 6 < 会议 5 的开始时间 7 → 不冲突
            * 会议 6 ~ 7
              - 会议 3 的结束时间 7 >= 会议 5 的开始时间 7 → 冲突(结束时间等于开始也算冲突)
         能接在 `会议 4` 前面的会议只有 `会议 1` 、`会议 2` 和 `会议 3`
         p(5) = 3

         最终 p(i) 数组
         编号 i          时间              p(i)          说明
         1              1～3              -1            前面无会议
         2              2～5              -1            会议 1 冲突
         3              4～6              1             接在会议 1 后面
         4              6～7              2             接在会议 2 后面(`会议 1` 和 `会议 2`)
         5              7～9              3             接在会议 3 后面(`会议 1` 、`会议 2` 和 `会议 3`)

    会议按结束时间升序排好序, 即: end[1] <= end[2] <= end[3] <= ... <= end[n]
    p(i) = 所有结束时间 < start[i] 的会议中，结束最靠后的那个
    所以需要找到所有 end[e] < start[i] 的个数(即: index 最大的那个的会议的编号), 使用二分查找算法

    时间复杂度: O(n log n + nk)
    空间复杂度: O(k + n) 原地排序
*/
pub fn max_value(events: Vec<Vec<i32>>, k: i32) -> i32 {
    if events.is_empty() || k == 0 {
        return 0;
    }

    let n = events.len();

    let mut events = events.clone();

    // 1. 按结束时间排序
    events.sort_by_key(|e| e[1]);

    // 2. 预处理 p(i) : 对每个会议 i，找到前一个不重叠的会议索引
    let mut ends: Vec<i32> = events.iter().map(|e| e[1]).collect();
    let mut p = vec![-1; n]; // p[i] = 前一个与 i 不重叠的会议索引

    for i in 0..n {
        let mut left = 0;
        let mut right = i as i32 - 1;
        let mut idx = -1;
        while left <= right {
            let mid = left + (right - left) / 2;
            if ends[mid as usize] < events[i][0] {
                idx = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        p[i] = idx;
    }

    // 3. 定义 dp[i][j]：前 i 个会议，最多选 j 个会议的最大价值
    let k = k as usize;
    let mut dp = vec![vec![0; k + 1]; n + 1]; // dp[0][*] 表示没有会议的情况, dp[*][0] 表示最多选 0 个会议

    // 4. 填表（按会议顺序 + 选择数）
    for i in 1..=n {
        for j in 1..=k {
            let not_take = dp[i - 1][j];
            let take = if p[i - 1] != -1 {
                dp[p[i - 1] as usize + 1][j - 1] + events[i - 1][2]
            } else {
                // 如果没有前置不重叠会议，则相当于从 dp[0][j-1] 转移（即 0）
                dp[0][j - 1] + events[i - 1][2]
            };

            dp[i][j] = std::cmp::max(not_take, take);
        }
    }

    // 5. 返回结果
    dp[n][k]
}
