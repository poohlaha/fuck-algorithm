/*!
1562. 查找大小为 M 的最新分组
地址: https://leetcode.cn/problems/find-latest-group-of-size-m/description/
问题: 给你一个数组 `arr`, 该数组表示一个从 `1` 到 `n` 的数字排列，有一个长度为 `n` 的二进制字符串，该字符串上的所有位最初都设置为 `0`
     在从 `1` 到 `n` 的每个步骤 `i` 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 `arr[i]` 的位将会设为 `1` 。
     给你一个整数 `m` ，请你找出二进制字符串上存在长度为 `m` 的一组 `1` 的最后步骤。一组 `1` 是一个连续的、由 `1` 组成的子串，且左右两边不再有可以延伸的 `1`
     返回存在长度 `恰好` 为 `m` 的 一组 `1`  的最后步骤。如果不存在这样的步骤，请返回 `-1 `

提示:
  1. n == arr.length
  2. 1 <= n <= 10的5次方
  3. 1 <= arr[i] <= n
  4. arr 的所有整数 `互不相同`
  5. 1 <= m <= arr.length

条件总结:
  1. 长度恰好为 `m`: 查找连续的 1 的子串，长度 `刚好是 m`，`不能大于也不能小于`
  2. 一组 `1`: `一段连续的 1`，`不能和其他 1 连成一块`，这段的 `前后必须是 0` 或 `数组边界`
  3. 最后步骤: 不是找第一次出现这个长度的情况，而是 `最后一次`(也就是 `i 最大的那一次`)
  ps:
   - 长度恰好是 `m`
   - 左边是 0 或边界
   - 右边是 0 或边界
*/

mod difference;
mod region;
pub mod test;
mod z;
